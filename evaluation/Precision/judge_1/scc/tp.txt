$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,650,667
default,70505.java,524,546
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,504,515
default,25053.java,509,520
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,97399.java,607,628
default,97399.java,134,152
----------------------------------------
    public boolean checkPasswd(String guess) {
        try {
            Connection conn = getDBConnection();
            Statement stmt = conn.createStatement();
            String dbQuery = "SELECT COUNT(U_ID) FROM Users WHERE (U_ID='" + getUID() + "' AND Passwd=password('" + guess + "'))";
            ResultSet results = stmt.executeQuery(dbQuery);
            if (results.getInt("COUNT(U_ID)") == 1) {
                return true;
            } else {
                return false;
            }
        } catch (SQLException e) {
            System.out.println(e);
        } catch (ClassNotFoundException e) {
            System.out.println(e);
        } catch (InstantiationException e) {
            System.out.println(e);
        } catch (IllegalAccessException e) {
            System.out.println(e);
        }
        return false;
    }
----------------------------------------
    public boolean readMessage(ListMessage msg) {
        try {
            Connection conn = Ozymandias.getDBConnection();
            Statement stmt = conn.createStatement();
            String dbQuery = "SELECT COUNT(M_ID) FROM ReadMessages WHERE (U_ID='" + getUID() + "' AND M_ID='" + msg.getMID() + "')";
            ResultSet results = stmt.executeQuery(dbQuery);
            int count = results.getInt("COUNT(M_ID)");
            if (count > 0) return true;
        } catch (SQLException e) {
            System.out.println(e);
        } catch (ClassNotFoundException e) {
            System.out.println(e);
        } catch (InstantiationException e) {
            System.out.println(e);
        } catch (IllegalAccessException e) {
            System.out.println(e);
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,2058.java,573,587
default,79290.java,567,581
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "passwd").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "passwd").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98981.java,629,646
default,129715.java,631,648
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95679.java,48,62
default,123890.java,48,62
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44208.java,667,685
default,70505.java,548,570
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,570,590
default,44208.java,546,568
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,570,590
default,25053.java,667,685
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42661.java,75,91
default,45154.java,75,91
----------------------------------------
    private void open(File f) {
        try {
            ImageInputStream iis = ImageIO.createImageInputStream(f);
            Iterator iter = ImageIO.getImageReadersByFormatName("DICOM");
            ImageReader reader = (ImageReader) iter.next();
            reader.setInput(iis, false);
            JPanel p = new ImageBox(reader);
            JFrame jf = new JFrame("ImageDisplay - Display Panel");
            jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            jf.getContentPane().add(p);
            jf.pack();
            jf.setSize(Math.min(jf.getWidth(), 800), Math.min(jf.getHeight(), 600));
            jf.setVisible(true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
----------------------------------------
    private void open(File f) {
        try {
            ImageInputStream iis = ImageIO.createImageInputStream(f);
            Iterator iter = ImageIO.getImageReadersByFormatName("DICOM");
            ImageReader reader = (ImageReader) iter.next();
            reader.setInput(iis, false);
            JPanel p = new ImageBox(reader);
            JFrame jf = new JFrame("ImageDisplay - Display Panel");
            jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            jf.getContentPane().add(p);
            jf.pack();
            jf.setSize(Math.min(jf.getWidth(), 800), Math.min(jf.getHeight(), 600));
            jf.setVisible(true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65413.java,669,687
default,103146.java,629,646
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,85301.java,159,173
default,76337.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24621.java,459,472
default,103146.java,459,472
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4439.java,629,646
default,6937.java,570,590
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4439.java,667,685
default,19573.java,546,568
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53104.java,493,507
default,118344.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53104.java,493,507
default,103146.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,15343.java,394,404
default,65413.java,394,404
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,15343.java,667,685
default,25053.java,629,646
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,104327.java,53,65
default,39812.java,44,56
----------------------------------------
    static void jar(File jar, Iterable<File> classPath, File base, File... files) throws IOException {
        System.err.println("jar...");
        Manifest m = new Manifest();
        if (classPath != null) {
            Attributes mainAttrs = m.getMainAttributes();
            mainAttrs.put(Attributes.Name.MANIFEST_VERSION, "1.0");
            mainAttrs.put(Attributes.Name.CLASS_PATH, join(classPath, " "));
        }
        OutputStream out = new BufferedOutputStream(new FileOutputStream(jar));
        JarOutputStream j = new JarOutputStream(out, m);
        add(j, base, files);
        j.close();
    }
----------------------------------------
    static void jar(File jar, Iterable<File> classPath, File base, File... files) throws IOException {
        System.err.println("jar...");
        Manifest m = new Manifest();
        if (classPath != null) {
            Attributes mainAttrs = m.getMainAttributes();
            mainAttrs.put(Attributes.Name.MANIFEST_VERSION, "1.0");
            mainAttrs.put(Attributes.Name.CLASS_PATH, join(classPath, " "));
        }
        OutputStream out = new BufferedOutputStream(new FileOutputStream(jar));
        JarOutputStream j = new JarOutputStream(out, m);
        add(j, base, files);
        j.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55062.java,474,489
default,16429.java,474,489
----------------------------------------
    public static void main(String[] args) {
        if (args.length > 1) {
            System.out.println("usage: jnamed [conf]");
            System.exit(0);
        }
        jnamed s;
        try {
            String conf;
            if (args.length == 1) conf = args[0]; else conf = "jnamed.conf";
            s = new jnamed(conf);
        } catch (IOException e) {
            System.out.println(e);
        } catch (ZoneTransferException e) {
            System.out.println(e);
        }
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length > 1) {
            System.out.println("usage: jnamed [conf]");
            System.exit(0);
        }
        jnamed s;
        try {
            String conf;
            if (args.length == 1) conf = args[0]; else conf = "jnamed.conf";
            s = new jnamed(conf);
        } catch (IOException e) {
            System.out.println(e);
        } catch (ZoneTransferException e) {
            System.out.println(e);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,97360.java,495,509
default,25053.java,394,404
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,116906.java,394,404
default,6937.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72323.java,440,452
default,44208.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72323.java,570,590
default,32654.java,629,646
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95068.java,6,18
default,84690.java,6,18
----------------------------------------
    public static void main(String[] args) {
        try {
            String jar = "./test340.jar";
            URLClassLoader theLoader = new URLClassLoader(new URL[] { new URL("file:" + jar) });
            Object theLoadedClass = Class.forName("test340c", true, theLoader).newInstance();
            String[] array = new String[] {};
            Method main = theLoadedClass.getClass().getMethod("main", new Class[] { array.getClass() });
            main.invoke(theLoadedClass, new Object[] { new String[] {} });
        } catch (Throwable t) {
            System.exit(42);
        }
        System.exit(43);
    }
----------------------------------------
    public static void main(String[] args) {
        try {
            String jar = "./test340.jar";
            URLClassLoader theLoader = new URLClassLoader(new URL[] { new URL("file:" + jar) });
            Object theLoadedClass = Class.forName("test340c", true, theLoader).newInstance();
            String[] array = new String[] {};
            Method main = theLoadedClass.getClass().getMethod("main", new Class[] { array.getClass() });
            main.invoke(theLoadedClass, new Object[] { new String[] {} });
        } catch (Throwable t) {
            System.exit(42);
        }
        System.exit(43);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,124843.java,394,404
default,32654.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,124843.java,667,685
default,24621.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,124843.java,648,665
default,25053.java,667,685
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103762.java,667,685
default,6320.java,546,568
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103762.java,667,685
default,92220.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62365.java,570,590
default,65413.java,524,546
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109369.java,493,507
default,124843.java,394,404
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109369.java,648,665
default,90330.java,404,426
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,119807.java,939,952
default,119807.java,320,331
----------------------------------------
    @Test
    public void test51() throws Exception {
        String data = "\"\\xfa\\u0afa\\xFA\\u0AFA\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\"\\xfa\\u0afa\\xFA\\u0AFA\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test15() throws Exception {
        String data = "\"data \r\n here\"";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("data \r\n here", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"data \r\n here\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,27552.java,648,665
default,103146.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103270.java,24,42
default,76967.java,24,42
----------------------------------------
    public Interactive() {
        theGraph = new JDrawEditor(JDrawEditor.MODE_PLAY);
        try {
            theGraph.loadFile("interactive.jdw");
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, e.getMessage(), "Error loading file", JOptionPane.ERROR_MESSAGE);
            System.exit(1);
        }
        btn1 = getObject("Button1");
        btn2 = getObject("Button2");
        checkbox = getObject("Checkbox");
        textArea = (JDLabel) getObject("textArea");
        addText("");
        btn1.addValueListener(this);
        btn2.addValueListener(this);
        checkbox.addValueListener(this);
        setContentPane(theGraph);
        setTitle("Interactive");
    }
----------------------------------------
    public Interactive() {
        theGraph = new JDrawEditor(JDrawEditor.MODE_PLAY);
        try {
            theGraph.loadFile("interactive.jdw");
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, e.getMessage(), "Error loading file", JOptionPane.ERROR_MESSAGE);
            System.exit(1);
        }
        btn1 = getObject("Button1");
        btn2 = getObject("Button2");
        checkbox = getObject("Checkbox");
        textArea = (JDLabel) getObject("textArea");
        addText("");
        btn1.addValueListener(this);
        btn2.addValueListener(this);
        checkbox.addValueListener(this);
        setContentPane(theGraph);
        setTitle("Interactive");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63015.java,461,474
default,25053.java,459,472
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63015.java,572,592
default,15343.java,546,568
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,118405.java,308,322
default,98981.java,308,322
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95529.java,87,103
default,61819.java,87,103
----------------------------------------
    private static void write(File pdfFile, File dcmFile, Dataset ds) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(pdfFile), BUFFER_SIZE);
        try {
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dcmFile));
            try {
                ds.writeFile(out, null);
                final int doclen = (int) pdfFile.length();
                ds.writeHeader(out, DcmEncodeParam.EVR_LE, Tags.EncapsulatedDocument, VRs.OB, (doclen + 1) & ~1);
                copy(in, out);
                if ((doclen & 1) != 0) out.write(0);
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }
----------------------------------------
    private static void write(File pdfFile, File dcmFile, Dataset ds) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(pdfFile), BUFFER_SIZE);
        try {
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dcmFile));
            try {
                ds.writeFile(out, null);
                final int doclen = (int) pdfFile.length();
                ds.writeHeader(out, DcmEncodeParam.EVR_LE, Tags.EncapsulatedDocument, VRs.OB, (doclen + 1) & ~1);
                copy(in, out);
                if ((doclen & 1) != 0) out.write(0);
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,39035.java,247,261
default,39035.java,98,113
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test1() throws Exception {
        CsvReader reader = CsvReader.parse("1,2");
        Assert.assertEquals("", reader.getRawRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1,2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,39035.java,1005,1019
default,119807.java,1040,1055
----------------------------------------
    @Test
    public void test56() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, '\t', Charset.forName("ISO-8859-1"));
        writer.write("1,2");
        writer.write("3");
        writer.write("blah \"some stuff in quotes\"");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
    }
----------------------------------------
    @Test
    public void test58() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, '\t', Charset.forName("ISO-8859-1"));
        writer.write("data\r\nmore data");
        writer.write(" 3\t", false);
        writer.write(" 3\t");
        writer.write(" 3\t", true);
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,39035.java,1097,1112
default,124923.java,1040,1055
----------------------------------------
    @Test
    public void test72() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        Assert.assertEquals('\0', writer.getRecordDelimiter());
        writer.setRecordDelimiter(';');
        Assert.assertEquals(';', writer.getRecordDelimiter());
        writer.write("a;b");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"a;b\";", data);
    }
----------------------------------------
    @Test
    public void test58() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, '\t', Charset.forName("ISO-8859-1"));
        writer.write("data\r\nmore data");
        writer.write(" 3\t", false);
        writer.write(" 3\t");
        writer.write(" 3\t", true);
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,39035.java,1495,1509
default,124923.java,1097,1112
----------------------------------------
    @Test
    public void test122() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.write("1,2");
        writer.write(null);
        writer.write("3 ", true);
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"1,2\",,\"3 \"\r\n", data);
    }
----------------------------------------
    @Test
    public void test72() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        Assert.assertEquals('\0', writer.getRecordDelimiter());
        writer.setRecordDelimiter(';');
        Assert.assertEquals(';', writer.getRecordDelimiter());
        writer.write("a;b");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"a;b\";", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19731.java,134,160
default,63072.java,134,160
----------------------------------------
    private static final String makeTypeObject(String rType) {
        if ("boolean".equals(rType)) {
            return "Boolean";
        }
        if ("byte".equals(rType)) {
            return "Byte";
        }
        if ("char".equals(rType)) {
            return "Char";
        }
        if ("short".equals(rType)) {
            return "Short";
        }
        if ("int".equals(rType)) {
            return "Integer";
        }
        if ("long".equals(rType)) {
            return "Long";
        }
        if ("float".equals(rType)) {
            return "Float";
        }
        if ("double".equals(rType)) {
            return "Double";
        }
        return rType;
    }
----------------------------------------
    private static final String makeTypeObject(String rType) {
        if ("boolean".equals(rType)) {
            return "Boolean";
        }
        if ("byte".equals(rType)) {
            return "Byte";
        }
        if ("char".equals(rType)) {
            return "Char";
        }
        if ("short".equals(rType)) {
            return "Short";
        }
        if ("int".equals(rType)) {
            return "Integer";
        }
        if ("long".equals(rType)) {
            return "Long";
        }
        if ("float".equals(rType)) {
            return "Float";
        }
        if ("double".equals(rType)) {
            return "Double";
        }
        return rType;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98684.java,667,685
default,53104.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70088.java,461,474
default,118405.java,459,472
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35053.java,570,590
default,135495.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35053.java,648,665
default,6320.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35053.java,648,665
default,103762.java,667,685
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,86322.java,570,590
default,33872.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,86322.java,570,590
default,103146.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,86322.java,648,665
default,72323.java,629,646
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,86322.java,667,685
default,53104.java,546,568
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51702.java,573,587
default,74245.java,573,587
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,123760.java,159,173
default,10254.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,101871.java,48,62
default,22724.java,48,62
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42612.java,629,646
default,97360.java,548,570
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98990.java,459,472
default,135495.java,440,452
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,125700.java,179,191
default,97676.java,179,191
----------------------------------------
        public void run() {
            try {
                Runtime.getRuntime().exec("ssh " + hostname + " " + main.testAppAbsPath + " -j " + jobId + " -p 1 -c " + maxMessageNumber + " -d " + main.delay);
                if (!main.portalEmul) {
                    TestClient tc = new TestClient(main.mainMonitorURL, this.jobId, this.maxMessageNumber, main);
                } else {
                    main.tfm.startTraceFileMonitoring(this.jobId, main.mainMonitorURL);
                    PortalEmulWatcher pew = new PortalEmulWatcher(this.main);
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
----------------------------------------
        public void run() {
            try {
                Runtime.getRuntime().exec("ssh " + hostname + " " + main.testAppAbsPath + " -j " + jobId + " -p 1 -c " + maxMessageNumber + " -d " + main.delay);
                if (!main.portalEmul) {
                    TestClient tc = new TestClient(main.mainMonitorURL, this.jobId, this.maxMessageNumber, main);
                } else {
                    main.tfm.startTraceFileMonitoring(this.jobId, main.mainMonitorURL);
                    PortalEmulWatcher pew = new PortalEmulWatcher(this.main);
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96072.java,573,587
default,60222.java,537,551
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("key-passwd", "dcm4che").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "dcmsnd.key")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts")), cfg.getProperty("tls-cacerts-passwd", "dcm4che").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration - " + ex.getMessage());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63929.java,73,85
default,16697.java,73,85
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98990.java,667,685
default,35053.java,522,544
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65489.java,48,62
default,29717.java,48,62
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5657.java,186,203
default,39035.java,167,184
----------------------------------------
    @Test
    public void test6() throws Exception {
        String data = "1\r\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test5() throws Exception {
        String data = "1\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5657.java,803,816
default,119807.java,909,922
----------------------------------------
    @Test
    public void test44() throws Exception {
        String data = "line 1\\nline 2,line 1\\\nline 2";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("line 1\nline 2", reader.get(0));
        Assert.assertEquals("line 1\nline 2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test49() throws Exception {
        String data = "\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5657.java,1567,1580
default,39035.java,1097,1112
----------------------------------------
    @Test
    public void test132() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1,\\2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"1,\\\\2\"\r\n", data);
    }
----------------------------------------
    @Test
    public void test72() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        Assert.assertEquals('\0', writer.getRecordDelimiter());
        writer.setRecordDelimiter(';');
        Assert.assertEquals(';', writer.getRecordDelimiter());
        writer.write("a;b");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"a;b\";", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80510.java,407,422
default,124923.java,186,203
----------------------------------------
    @Test
    public void test21() throws Exception {
        String data = "'bob said, ''Hey!''',2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        reader.setTextQualifier('\'');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, 'Hey!'", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test6() throws Exception {
        String data = "1\r\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80510.java,320,331
default,5657.java,939,952
----------------------------------------
    @Test
    public void test15() throws Exception {
        String data = "\"data \r\n here\"";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("data \r\n here", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"data \r\n here\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test51() throws Exception {
        String data = "\"\\xfa\\u0afa\\xFA\\u0AFA\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\"\\xfa\\u0afa\\xFA\\u0AFA\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80510.java,545,557
default,5657.java,247,261
----------------------------------------
    @Test
    public void test29() throws Exception {
        String data = "\"double\\\"\\\"double quotes\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("double\"\"double quotes", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"double\\\"\\\"double quotes\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80510.java,803,816
default,39035.java,803,816
----------------------------------------
    @Test
    public void test44() throws Exception {
        String data = "line 1\\nline 2,line 1\\\nline 2";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("line 1\nline 2", reader.get(0));
        Assert.assertEquals("line 1\nline 2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test44() throws Exception {
        String data = "line 1\\nline 2,line 1\\\nline 2";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("line 1\nline 2", reader.get(0));
        Assert.assertEquals("line 1\nline 2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80510.java,909,922
default,5657.java,954,967
----------------------------------------
    @Test
    public void test49() throws Exception {
        String data = "\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test52() throws Exception {
        String data = "\\xfa\\u0afa\\xFA\\u0AFA";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\\xfa\\u0afa\\xFA\\u0AFA", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80510.java,1460,1476
default,39035.java,1548,1565
----------------------------------------
    @Test
    public void test120() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.write("1,2");
        writer.endRecord();
        buffer = stream.toByteArray();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("", data);
        writer.flush();
        buffer = stream.toByteArray();
        stream.close();
        data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"1,2\"\r\n", data);
        writer.close();
    }
----------------------------------------
    @Test
    public void test131() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setUseTextQualifier(false);
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1,\\\r\n2");
        writer.endRecord();
        writer.setRecordDelimiter(';');
        writer.write("1,\\;2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28532.java,186,203
default,80510.java,115,130
----------------------------------------
    @Test
    public void test6() throws Exception {
        String data = "1\r\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test2() throws Exception {
        String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, \"Hey!\"", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28532.java,407,422
default,119807.java,167,184
----------------------------------------
    @Test
    public void test21() throws Exception {
        String data = "'bob said, ''Hey!''',2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        reader.setTextQualifier('\'');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, 'Hey!'", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test5() throws Exception {
        String data = "1\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28532.java,407,422
default,124923.java,167,184
----------------------------------------
    @Test
    public void test21() throws Exception {
        String data = "'bob said, ''Hey!''',2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        reader.setTextQualifier('\'');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, 'Hey!'", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test5() throws Exception {
        String data = "1\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28532.java,407,422
default,39035.java,528,543
----------------------------------------
    @Test
    public void test21() throws Exception {
        String data = "'bob said, ''Hey!''',2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        reader.setTextQualifier('\'');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, 'Hey!'", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test28() throws Exception {
        String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, \"Hey!\"", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28532.java,132,146
default,80510.java,589,601
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test32() throws Exception {
        String data = "\"Mac \"The Knife\" Peter\",\"Boswell, Jr.\"";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("Mac ", reader.get(0));
        Assert.assertEquals("Boswell, Jr.", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("\"Mac \"The Knife\" Peter\",\"Boswell, Jr.\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28532.java,528,543
default,124923.java,148,165
----------------------------------------
    @Test
    public void test28() throws Exception {
        String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, \"Hey!\"", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test4() throws Exception {
        String data = "1\r2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28532.java,954,967
default,80510.java,803,816
----------------------------------------
    @Test
    public void test52() throws Exception {
        String data = "\\xfa\\u0afa\\xFA\\u0AFA";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\\xfa\\u0afa\\xFA\\u0AFA", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test44() throws Exception {
        String data = "line 1\\nline 2,line 1\\\nline 2";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("line 1\nline 2", reader.get(0));
        Assert.assertEquals("line 1\nline 2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28532.java,1495,1509
default,80510.java,1005,1019
----------------------------------------
    @Test
    public void test122() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.write("1,2");
        writer.write(null);
        writer.write("3 ", true);
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"1,2\",,\"3 \"\r\n", data);
    }
----------------------------------------
    @Test
    public void test56() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, '\t', Charset.forName("ISO-8859-1"));
        writer.write("1,2");
        writer.write("3");
        writer.write("blah \"some stuff in quotes\"");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28532.java,1531,1546
default,80510.java,1400,1417
----------------------------------------
    @Test
    public void test124() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setRecordDelimiter(';');
        writer.setUseTextQualifier(false);
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1;2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\;2;", data);
    }
----------------------------------------
    @Test
    public void test117() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        Assert.assertEquals('#', writer.getComment());
        writer.setComment('~');
        Assert.assertEquals('~', writer.getComment());
        writer.setRecordDelimiter(';');
        writer.write("1");
        writer.endRecord();
        writer.writeComment("blah");
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1;~blah;", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,137594.java,648,665
default,27552.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,100859.java,159,173
default,40097.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,137594.java,629,646
default,70088.java,572,592
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,92452.java,437,455
default,56485.java,686,704
----------------------------------------
    private byte[] moveAutoAddItem(HTTPurl urlData, HashMap<String, String> headers) throws Exception {
        int id = -1;
        try {
            id = Integer.parseInt(urlData.getParameter("id"));
        } catch (Exception e) {
        }
        int dir = 1;
        try {
            dir = Integer.parseInt(urlData.getParameter("dir"));
        } catch (Exception e) {
        }
        boolean direction = false;
        if (dir == 1) direction = true;
        if (id != -1) store.moveEpgItem(id, direction);
        StringBuffer buff = new StringBuffer();
        buff.append("HTTP/1.0 302 Moved Temporarily\n");
        buff.append("Location: /servlet/KBAutoAddRes\n\n");
        return buff.toString().getBytes();
    }
----------------------------------------
    private byte[] moveAutoAddItem(HTTPurl urlData) throws Exception {
        int id = -1;
        try {
            id = Integer.parseInt(urlData.getParameter("id"));
        } catch (Exception e) {
        }
        int dir = 1;
        try {
            dir = Integer.parseInt(urlData.getParameter("dir"));
        } catch (Exception e) {
        }
        boolean direction = false;
        if (dir == 1) direction = true;
        if (id != -1) store.moveEpgItem(id, direction);
        StringBuffer buff = new StringBuffer();
        buff.append("HTTP/1.0 302 Moved Temporarily\n");
        buff.append("Location: /servlet/" + urlData.getServletClass() + "?action=01\n\n");
        return buff.toString().getBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56216.java,308,322
default,53104.java,308,322
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56216.java,440,452
default,6937.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56216.java,570,590
default,44208.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56216.java,570,590
default,45549.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24692.java,339,373
default,40759.java,339,373
----------------------------------------
    void processTemplateRegion(Vector region) throws IOException {
        String inLine = (String) region.elementAt(0);
        int command = getTemplateCommand(inLine);
        switch(command) {
            case FOREACH:
                processForeachRegion(region);
                break;
            case LOOP:
                processLoopRegion(region);
                break;
            case COUNT:
                processCountRegion(region);
                break;
            case SPLIT:
                processSplitRegion(region);
                break;
            case JOIN:
                processJoinRegion(region);
                break;
            case LET:
                processLetRegion(region);
                break;
            case EVAL:
                processEvalRegion(region);
                break;
            case IF:
                processCondRegion(region);
                break;
            case INCLUDE:
                processIncludeRegion(region);
                break;
            default:
                throw new IOException("Invalid command");
        }
    }
----------------------------------------
    void processTemplateRegion(Vector region) throws IOException {
        String inLine = (String) region.elementAt(0);
        int command = getTemplateCommand(inLine);
        switch(command) {
            case FOREACH:
                processForeachRegion(region);
                break;
            case LOOP:
                processLoopRegion(region);
                break;
            case COUNT:
                processCountRegion(region);
                break;
            case SPLIT:
                processSplitRegion(region);
                break;
            case JOIN:
                processJoinRegion(region);
                break;
            case LET:
                processLetRegion(region);
                break;
            case EVAL:
                processEvalRegion(region);
                break;
            case IF:
                processCondRegion(region);
                break;
            case INCLUDE:
                processIncludeRegion(region);
                break;
            default:
                throw new IOException("Invalid command");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24692.java,683,708
default,40759.java,656,681
----------------------------------------
    private int evalExpr(StreamTokenizer st) throws IOException {
        int val = evalTerm(st);
        int token = st.nextToken();
        while (token == '+' || token == '-' || token == '|' || token == '^') {
            int t = evalTerm(st);
            switch(token) {
                case '+':
                    val += t;
                    break;
                case '-':
                    val -= t;
                    break;
                case '|':
                    val |= t;
                    break;
                case '^':
                    val ^= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25052.java,220,242
default,31976.java,664,686
----------------------------------------
    public boolean writer__endFile() {
        boolean endOK = true;
        String fileName = _getFullFileName();
        String filePath = writer__iOutputFolder + "\\" + fileName;
        if (writer__iBackup) {
            try {
                writer__backup(filePath, fileName, writer__iBackupFolder);
            } catch (Exception e) {
                writer__handleException(writer__UITEXT_UnableToBackupFile + filePath + writer__UITEXT_ToBackupFolder + writer__iBackupFolder, e);
                endOK = false;
            }
        }
        if (endOK && writer__iSave) {
            try {
                writer__save(filePath, writer__iCurrentText.toString());
                writer__userMessage(writer__UITEXT_SavedFile + filePath + writer__UITEXT_NewLine);
            } catch (Exception e) {
                writer__handleException(writer__UITEXT_UnableToSaveFile + filePath, e);
                endOK = false;
            }
        }
        return endOK;
    }
----------------------------------------
    public boolean writer__endFile() {
        boolean endOK = true;
        String fileName = _getFullFileName();
        String filePath = writer__iOutputFolder + "\\" + fileName;
        if (writer__iBackup) {
            try {
                writer__backup(filePath, fileName, writer__iBackupFolder);
            } catch (Exception e) {
                writer__handleException(writer__UITEXT_UnableToBackupFile + filePath + writer__UITEXT_ToBackupFolder + writer__iBackupFolder, e);
                endOK = false;
            }
        }
        if (endOK && writer__iSave) {
            try {
                writer__save(filePath, writer__iCurrentText.toString());
                writer__userMessage(writer__UITEXT_SavedFile + filePath + writer__UITEXT_NewLine);
            } catch (Exception e) {
                writer__handleException(writer__UITEXT_UnableToSaveFile + filePath, e);
                endOK = false;
            }
        }
        return endOK;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14709.java,662,680
default,118405.java,667,685
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79012.java,604,617
default,14709.java,599,612
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6658.java,183,197
default,106637.java,183,197
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,121641.java,132,140
default,77425.java,132,140
----------------------------------------
    private static void put(Dataset ds, int[] tagPath, String val) {
        Dataset item = ds;
        int lastIndex = tagPath.length - 1;
        for (int i = 0; i < lastIndex; ++i) {
            Dataset tmp = item.getItem(tagPath[i]);
            item = tmp != null ? tmp : item.putSQ(tagPath[i]).addNewItem();
        }
        if (val.length() != 0) item.putXX(tagPath[lastIndex], val); else if (!item.contains(tagPath[lastIndex])) item.putXX(tagPath[lastIndex]);
    }
----------------------------------------
    private static void put(Dataset ds, int[] tagPath, String val) {
        Dataset item = ds;
        int lastIndex = tagPath.length - 1;
        for (int i = 0; i < lastIndex; ++i) {
            Dataset tmp = item.getItem(tagPath[i]);
            item = tmp != null ? tmp : item.putSQ(tagPath[i]).addNewItem();
        }
        if (val.length() != 0) item.putXX(tagPath[lastIndex], val); else if (!item.contains(tagPath[lastIndex])) item.putXX(tagPath[lastIndex]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94944.java,604,617
default,70505.java,606,619
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94944.java,648,665
default,4439.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5621.java,648,665
default,90330.java,506,523
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5621.java,459,472
default,118344.java,459,472
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5621.java,648,665
default,44208.java,570,590
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5621.java,629,646
default,103762.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49247.java,667,685
default,6937.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49247.java,667,685
default,129715.java,631,648
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49247.java,667,685
default,103762.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,8952.java,570,590
default,103146.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,8952.java,629,646
default,5621.java,629,646
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,66239.java,365,379
default,30925.java,233,247
----------------------------------------
    public void truncate(Message in, int length, int maxLength) {
        TSIGRecord tsig = in.getTSIG();
        if (tsig != null) maxLength -= tsig.getWireLength();
        length -= truncateSection(in, maxLength, length, Section.ADDITIONAL);
        if (length < maxLength) return;
        in.getHeader().setFlag(Flags.TC);
        if (tsig != null) {
            in.removeAllRecords(Section.ANSWER);
            in.removeAllRecords(Section.AUTHORITY);
            return;
        }
        length -= truncateSection(in, maxLength, length, Section.AUTHORITY);
        if (length < maxLength) return;
        length -= truncateSection(in, maxLength, length, Section.ANSWER);
    }
----------------------------------------
    public void truncate(Message in, int length, int maxLength) {
        TSIGRecord tsig = in.getTSIG();
        if (tsig != null) maxLength -= tsig.getWireLength();
        length -= truncateSection(in, maxLength, length, Section.ADDITIONAL);
        if (length < maxLength) return;
        in.getHeader().setFlag(Flags.TC);
        if (tsig != null) {
            in.removeAllRecords(Section.ANSWER);
            in.removeAllRecords(Section.AUTHORITY);
            return;
        }
        length -= truncateSection(in, maxLength, length, Section.AUTHORITY);
        if (length < maxLength) return;
        length -= truncateSection(in, maxLength, length, Section.ANSWER);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40375.java,487,504
default,79012.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40375.java,487,504
default,6937.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40375.java,525,543
default,72323.java,522,544
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,93943.java,115,130
default,124923.java,186,203
----------------------------------------
    @Test
    public void test2() throws Exception {
        String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, \"Hey!\"", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test6() throws Exception {
        String data = "1\r\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,93943.java,545,557
default,119807.java,655,667
----------------------------------------
    @Test
    public void test29() throws Exception {
        String data = "\"double\\\"\\\"double quotes\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("double\"\"double quotes", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"double\\\"\\\"double quotes\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test36() throws Exception {
        String data = "\"some \\stuff\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("some stuff", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"some \\stuff\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,93943.java,247,261
default,5657.java,492,504
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test26() throws Exception {
        String data = "\"Mac \"The Knife\" Peter\",\"Boswell, Jr.\"";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("Mac ", reader.get(0));
        Assert.assertEquals("Boswell, Jr.", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("\"Mac \"The Knife\" Peter\",\"Boswell, Jr.\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,93943.java,1346,1360
default,5657.java,1330,1344
----------------------------------------
    @Test
    public void test92() throws Exception {
        byte[] buffer;
        String test = "test";
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        PrintWriter writer = new PrintWriter(stream);
        writer.println(test);
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        CsvReader reader = new CsvReader(new ByteArrayInputStream(buffer), ',', Charset.forName("ISO-8859-1"));
        reader.readRecord();
        Assert.assertEquals(test, reader.get(0));
        reader.close();
    }
----------------------------------------
    @Test
    public void test91() throws Exception {
        byte[] buffer;
        String test = "test";
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        PrintWriter writer = new PrintWriter(stream);
        writer.println(test);
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        CsvReader reader = new CsvReader(new ByteArrayInputStream(buffer), Charset.forName("ISO-8859-1"));
        reader.readRecord();
        Assert.assertEquals(test, reader.get(0));
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,71085.java,355,367
default,127646.java,285,296
----------------------------------------
    public boolean pstepOverBranch(int thread) {
        int addr = reg.hardwareIP();
        boolean over_branch = true;
        boolean stillrunning;
        boolean skip_prolog = false;
        breakpoint bpSaved = bpset.lookup(addr);
        threadstep.setStepBreakpoint(thread, over_branch, skip_prolog);
        if (bpSaved != null) bpset.clearBreakpoint(bpSaved);
        stillrunning = continueCheckingForSignal(thread, PRINTASSEMBLY, false);
        threadstep.clearStepBreakpoint(thread);
        if (stillrunning && bpSaved != null) bpset.setBreakpoint(bpSaved);
        return stillrunning;
    }
----------------------------------------
    public boolean pstep(int thread, int printMode, boolean skip_prolog) {
        int addr = reg.hardwareIP();
        boolean stillrunning;
        boolean over_branch = false;
        breakpoint bpSaved = bpset.lookup(addr);
        threadstep.setStepBreakpoint(thread, over_branch, skip_prolog);
        if (bpSaved != null) bpset.clearBreakpoint(bpSaved);
        stillrunning = continueCheckingForSignal(thread, printMode, false);
        threadstep.clearStepBreakpoint(thread);
        if (stillrunning && bpSaved != null) bpset.setBreakpoint(bpSaved);
        return stillrunning;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43679.java,132,140
default,19974.java,132,140
----------------------------------------
    private static void put(Dataset ds, int[] tagPath, String val) {
        Dataset item = ds;
        int lastIndex = tagPath.length - 1;
        for (int i = 0; i < lastIndex; ++i) {
            Dataset tmp = item.getItem(tagPath[i]);
            item = tmp != null ? tmp : item.putSQ(tagPath[i]).addNewItem();
        }
        if (val.length() != 0) item.putXX(tagPath[lastIndex], val); else if (!item.contains(tagPath[lastIndex])) item.putXX(tagPath[lastIndex]);
    }
----------------------------------------
    private static void put(Dataset ds, int[] tagPath, String val) {
        Dataset item = ds;
        int lastIndex = tagPath.length - 1;
        for (int i = 0; i < lastIndex; ++i) {
            Dataset tmp = item.getItem(tagPath[i]);
            item = tmp != null ? tmp : item.putSQ(tagPath[i]).addNewItem();
        }
        if (val.length() != 0) item.putXX(tagPath[lastIndex], val); else if (!item.contains(tagPath[lastIndex])) item.putXX(tagPath[lastIndex]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,46050.java,159,173
default,100859.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114239.java,247,261
default,124923.java,924,937
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test50() throws Exception {
        String data = "\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114239.java,559,571
default,114239.java,247,261
----------------------------------------
    @Test
    public void test30() throws Exception {
        String data = "\"double\\\\\\\\double backslash\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("double\\\\double backslash", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"double\\\\\\\\double backslash\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114239.java,545,557
default,39035.java,909,922
----------------------------------------
    @Test
    public void test29() throws Exception {
        String data = "\"double\\\"\\\"double quotes\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("double\"\"double quotes", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"double\\\"\\\"double quotes\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test49() throws Exception {
        String data = "\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114239.java,655,667
default,80510.java,132,146
----------------------------------------
    @Test
    public void test36() throws Exception {
        String data = "\"some \\stuff\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("some stuff", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"some \\stuff\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114239.java,924,937
default,119807.java,789,801
----------------------------------------
    @Test
    public void test50() throws Exception {
        String data = "\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test43() throws Exception {
        String data = "\"line 1\\nline 2\",\"line 1\\\nline 2\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("line 1\nline 2", reader.get(0));
        Assert.assertEquals("line 1\nline 2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114239.java,1082,1095
default,119807.java,1097,1112
----------------------------------------
    @Test
    public void test71() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setForceQualifier(true);
        writer.write(" data ");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"data\"\r\n", data);
    }
----------------------------------------
    @Test
    public void test72() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        Assert.assertEquals('\0', writer.getRecordDelimiter());
        writer.setRecordDelimiter(';');
        Assert.assertEquals(';', writer.getRecordDelimiter());
        writer.write("a;b");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"a;b\";", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114239.java,1531,1546
default,28532.java,1155,1170
----------------------------------------
    @Test
    public void test124() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setRecordDelimiter(';');
        writer.setUseTextQualifier(false);
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1;2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\;2;", data);
    }
----------------------------------------
    @Test
    public void test75() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.write("1");
        writer.endRecord();
        writer.writeComment("blah");
        writer.write("2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\r\n#blah\r\n2\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114239.java,1400,1417
default,93943.java,1005,1019
----------------------------------------
    @Test
    public void test117() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        Assert.assertEquals('#', writer.getComment());
        writer.setComment('~');
        Assert.assertEquals('~', writer.getComment());
        writer.setRecordDelimiter(';');
        writer.write("1");
        writer.endRecord();
        writer.writeComment("blah");
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1;~blah;", data);
    }
----------------------------------------
    @Test
    public void test56() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, '\t', Charset.forName("ISO-8859-1"));
        writer.write("1,2");
        writer.write("3");
        writer.write("blah \"some stuff in quotes\"");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,820.java,570,590
default,86322.java,629,646
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,820.java,570,590
default,32654.java,629,646
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,58268.java,74,92
default,24840.java,69,94
----------------------------------------
            public void run() {
                while (true) {
                    try {
                        Object item;
                        if ((item = lq.removeItem()) != null) {
                            itemsRead++;
                            System.out.println("Reader (" + num + "): " + item);
                        }
                        sleep(100);
                    } catch (LockableQueue.ClosedException ce) {
                        System.out.println("Reader (" + num + "): (expected) " + ce);
                        break;
                    } catch (Exception e) {
                        System.out.println("Reader (" + num + "): (unexpected)" + e);
                        break;
                    }
                }
                System.out.println("Reader (" + num + "): Items Read = " + itemsRead);
            }
----------------------------------------
    public static void startReader2(final int num, final LockableQueue lq) {
        new Thread() {

            int itemsRead = 0;

            public void run() {
                while (true) {
                    try {
                        Object item;
                        if ((item = lq.removeItem()) != null) {
                            itemsRead++;
                            System.out.println("Reader (" + num + "): " + item);
                        }
                        sleep(100);
                    } catch (LockableQueue.ClosedException ce) {
                        System.out.println("Reader (" + num + "): (expected) " + ce);
                        break;
                    } catch (Exception e) {
                        System.out.println("Reader (" + num + "): (unexpected)" + e);
                        break;
                    }
                }
                System.out.println("Reader (" + num + "): Items Read = " + itemsRead);
            }
        }.start();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,820.java,667,685
default,124843.java,667,685
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95647.java,570,590
default,27552.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95647.java,367,379
default,72323.java,367,379
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95647.java,570,590
default,49247.java,546,568
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95647.java,394,404
default,53104.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,120736.java,620,630
default,23528.java,620,630
----------------------------------------
    private String evalIf(StreamTokenizer st) throws IOException {
        if (st.nextToken() != '(') throw new IOException("Missing '('");
        boolean cond = evalCond(st);
        if (st.nextToken() != ',') throw new IOException("Missing ','");
        String valtrue = evalStrExpr(st);
        if (st.nextToken() != ',') throw new IOException("Missing ','");
        String valfalse = evalStrExpr(st);
        if (st.nextToken() != ')') throw new IOException("Missing ')'");
        if (cond) return valtrue;
        return valfalse;
    }
----------------------------------------
    private String evalIf(StreamTokenizer st) throws IOException {
        if (st.nextToken() != '(') throw new IOException("Missing '('");
        boolean cond = evalCond(st);
        if (st.nextToken() != ',') throw new IOException("Missing ','");
        String valtrue = evalStrExpr(st);
        if (st.nextToken() != ',') throw new IOException("Missing ','");
        String valfalse = evalStrExpr(st);
        if (st.nextToken() != ')') throw new IOException("Missing ')'");
        if (cond) return valtrue;
        return valfalse;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,102943.java,159,173
default,128157.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,2909.java,339,373
default,24692.java,339,373
----------------------------------------
    void processTemplateRegion(Vector region) throws IOException {
        String inLine = (String) region.elementAt(0);
        int command = getTemplateCommand(inLine);
        switch(command) {
            case FOREACH:
                processForeachRegion(region);
                break;
            case LOOP:
                processLoopRegion(region);
                break;
            case COUNT:
                processCountRegion(region);
                break;
            case SPLIT:
                processSplitRegion(region);
                break;
            case JOIN:
                processJoinRegion(region);
                break;
            case LET:
                processLetRegion(region);
                break;
            case EVAL:
                processEvalRegion(region);
                break;
            case IF:
                processCondRegion(region);
                break;
            case INCLUDE:
                processIncludeRegion(region);
                break;
            default:
                throw new IOException("Invalid command");
        }
    }
----------------------------------------
    void processTemplateRegion(Vector region) throws IOException {
        String inLine = (String) region.elementAt(0);
        int command = getTemplateCommand(inLine);
        switch(command) {
            case FOREACH:
                processForeachRegion(region);
                break;
            case LOOP:
                processLoopRegion(region);
                break;
            case COUNT:
                processCountRegion(region);
                break;
            case SPLIT:
                processSplitRegion(region);
                break;
            case JOIN:
                processJoinRegion(region);
                break;
            case LET:
                processLetRegion(region);
                break;
            case EVAL:
                processEvalRegion(region);
                break;
            case IF:
                processCondRegion(region);
                break;
            case INCLUDE:
                processIncludeRegion(region);
                break;
            default:
                throw new IOException("Invalid command");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44026.java,629,646
default,103762.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44026.java,648,665
default,820.java,629,646
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,134647.java,367,379
default,63015.java,367,379
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,134647.java,570,590
default,95647.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,21681.java,440,452
default,79012.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,21681.java,629,646
default,97360.java,631,648
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,21681.java,667,685
default,79012.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,1481.java,73,85
default,28918.java,73,85
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,26963.java,159,173
default,102943.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57585.java,435,447
default,42612.java,440,452
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57585.java,275,284
default,103146.java,280,289
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            System.out.println(POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]");
            ds.writeDataset(getTransformerHandler(tf, xslt), dict);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57585.java,504,515
default,820.java,509,520
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57585.java,643,660
default,86322.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57585.java,643,660
default,90330.java,506,523
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57585.java,435,447
default,35053.java,440,452
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57585.java,643,660
default,24621.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,36322.java,394,404
default,135495.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76704.java,915,937
default,28942.java,964,988
----------------------------------------
    public void doListInstruction(String command, String[] args) {
        int count;
        int addr = -1;
        try {
            switch(args.length) {
                case 0:
                    addr = user.reg.currentIP();
                    jdp_console.writeOutput(user.mem.listInstruction(addr, 10));
                    break;
                case 1:
                    addr = parseHex32(args[0]);
                    jdp_console.writeOutput(user.mem.listInstruction(addr, 10));
                    break;
                default:
                    addr = parseHex32(args[0]);
                    count = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.listInstruction(addr, count));
                    break;
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("bad address: " + args[0]);
        }
    }
----------------------------------------
    public void doMemoryRead(String command, String[] args) {
        int addr, count;
        switch(args.length) {
            case 0:
                printHelp(command);
                break;
            case 1:
                try {
                    addr = parseHex32(args[0]);
                    jdp_console.writeOutput(user.mem.print(addr, 5));
                } catch (NumberFormatException e) {
                    jdp_console.writeOutput("bad address: " + args[0]);
                }
                break;
            default:
                try {
                    addr = parseHex32(args[0]);
                    count = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.print(addr, count));
                } catch (NumberFormatException e) {
                    jdp_console.writeOutput("bad address or count: " + args[0] + ", " + args[1]);
                }
                break;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,36322.java,667,685
default,94944.java,629,646
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,36322.java,629,646
default,118405.java,546,568
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,36322.java,629,646
default,118405.java,629,646
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6652.java,6,18
default,60087.java,6,18
----------------------------------------
    public static void main(String[] args) {
        try {
            String jar = "./test340.jar";
            URLClassLoader theLoader = new URLClassLoader(new URL[] { new URL("file:" + jar) });
            Object theLoadedClass = Class.forName("test340c", true, theLoader).newInstance();
            String[] array = new String[] {};
            Method main = theLoadedClass.getClass().getMethod("main", new Class[] { array.getClass() });
            main.invoke(theLoadedClass, new Object[] { new String[] {} });
        } catch (Throwable t) {
            System.exit(42);
        }
        System.exit(43);
    }
----------------------------------------
    public static void main(String[] args) {
        try {
            String jar = "./test340.jar";
            URLClassLoader theLoader = new URLClassLoader(new URL[] { new URL("file:" + jar) });
            Object theLoadedClass = Class.forName("test340c", true, theLoader).newInstance();
            String[] array = new String[] {};
            Method main = theLoadedClass.getClass().getMethod("main", new Class[] { array.getClass() });
            main.invoke(theLoadedClass, new Object[] { new String[] {} });
        } catch (Throwable t) {
            System.exit(42);
        }
        System.exit(43);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28903.java,183,197
default,83354.java,183,197
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,50971.java,667,685
default,124843.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,50971.java,648,665
default,134647.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90854.java,783,797
default,68876.java,795,809
----------------------------------------
        private void emitEmitCall(String opcode, int[] args, int count, int level, int size) {
            emitTab(level);
            emit("emit" + opcode);
            for (int i = 0; i < count; i++) emit("_" + encoding[args[i]]);
            if (size != 0) emit("_" + encoding[size]);
            if (count == 0) emit("();\n"); else {
                emit("(");
                for (int i = 0; i < count; i++) {
                    emit("\n");
                    emitTab(level + 1);
                    emitArgs(i, args[i]);
                    if (i == count - 1) emit(");\n"); else emit(",");
                }
            }
        }
----------------------------------------
        private void emitEmitCall(String opcode, int[] args, int count, int level, int size) {
            emitTab(level);
            emit("emit" + opcode);
            for (int i = 0; i < count; i++) emit("_" + encoding[args[i]]);
            if (size != 0) emit("_" + encoding[size]);
            if (count == 0) emit("();\n"); else {
                emit("(");
                for (int i = 0; i < count; i++) {
                    emit("\n");
                    emitTab(level + 1);
                    emitArgs(i, args[i]);
                    if (i == count - 1) emit(");\n"); else emit(",");
                }
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114331.java,629,646
default,53104.java,522,544
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,367,379
default,44208.java,367,379
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,280,289
default,92220.java,280,289
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,572,592
default,44208.java,667,685
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,572,592
default,103146.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,495,509
default,109369.java,394,404
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,39577.java,308,326
default,86222.java,308,326
----------------------------------------
    private Object getObjectInputStream(String servlet_name, Object send) {
        Object object = null;
        try {
            URLConnection con = getServletConnection(servlet_name);
            OutputStream outstream = con.getOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(outstream);
            oos.writeObject(send);
            oos.flush();
            oos.close();
            InputStream instr = con.getInputStream();
            ObjectInputStream inputFromServlet = new ObjectInputStream(instr);
            object = inputFromServlet.readObject();
            inputFromServlet.close();
            instr.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return object;
    }
----------------------------------------
    private Object getObjectInputStream(String servlet_name, Object send) {
        Object object = null;
        try {
            URLConnection con = getServletConnection(servlet_name);
            OutputStream outstream = con.getOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(outstream);
            oos.writeObject(send);
            oos.flush();
            oos.close();
            InputStream instr = con.getInputStream();
            ObjectInputStream inputFromServlet = new ObjectInputStream(instr);
            object = inputFromServlet.readObject();
            inputFromServlet.close();
            instr.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return object;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,650,667
default,124843.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,606,619
default,98684.java,604,617
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,650,667
default,103762.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,631,648
default,98981.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76192.java,570,590
default,94944.java,629,646
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76192.java,629,646
default,57585.java,541,563
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76192.java,570,590
default,4439.java,570,590
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76192.java,667,685
default,5621.java,522,544
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,20528.java,159,173
default,62476.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,64200.java,629,646
default,79012.java,522,544
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,64200.java,648,665
default,109369.java,629,646
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28711.java,48,62
default,6000.java,48,62
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132787.java,509,520
default,103146.java,509,520
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132787.java,667,685
default,6937.java,629,646
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,10736.java,159,173
default,104630.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,10736.java,159,173
default,100859.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132787.java,667,685
default,8952.java,648,665
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132787.java,629,646
default,53104.java,522,544
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42993.java,275,284
default,21681.java,280,289
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            System.out.println(POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]");
            ds.writeDataset(getTransformerHandler(tf, xslt), dict);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42993.java,624,641
default,116906.java,648,665
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42993.java,435,447
default,8952.java,440,452
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42993.java,624,641
default,36322.java,629,646
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42993.java,643,660
default,79012.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,107779.java,487,504
default,44026.java,570,590
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,107779.java,525,543
default,50971.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,107779.java,506,523
default,19573.java,629,646
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28782.java,459,472
default,103762.java,459,472
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28782.java,648,665
default,86322.java,667,685
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28782.java,604,617
default,44026.java,604,617
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28782.java,648,665
default,57585.java,541,563
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76927.java,87,103
default,58057.java,87,103
----------------------------------------
    private static void write(File pdfFile, File dcmFile, Dataset ds) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(pdfFile), BUFFER_SIZE);
        try {
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dcmFile));
            try {
                ds.writeFile(out, null);
                final int doclen = (int) pdfFile.length();
                ds.writeHeader(out, DcmEncodeParam.EVR_LE, Tags.EncapsulatedDocument, VRs.OB, (doclen + 1) & ~1);
                copy(in, out);
                if ((doclen & 1) != 0) out.write(0);
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }
----------------------------------------
    private static void write(File pdfFile, File dcmFile, Dataset ds) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(pdfFile), BUFFER_SIZE);
        try {
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dcmFile));
            try {
                ds.writeFile(out, null);
                final int doclen = (int) pdfFile.length();
                ds.writeHeader(out, DcmEncodeParam.EVR_LE, Tags.EncapsulatedDocument, VRs.OB, (doclen + 1) & ~1);
                copy(in, out);
                if ((doclen & 1) != 0) out.write(0);
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51991.java,73,85
default,127689.java,73,85
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,87896.java,629,646
default,86322.java,522,544
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,87896.java,394,404
default,33872.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,87896.java,629,646
default,124843.java,546,568
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,87896.java,648,665
default,103146.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,87896.java,648,665
default,6320.java,667,685
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,54081.java,763,778
default,102885.java,761,776
----------------------------------------
        SplitRecord split() {
            int splitArg = -1;
            int splitTest = -1;
            int splitDiff = 1000;
            for (int arg = 0; arg < 4; arg++) {
                for (int test = 0; test < encoding.length; test++) {
                    int c = getEncodingSplit(arg, test);
                    if (c == 0) return new SplitRecord(arg, test); else if (c < splitDiff) {
                        splitArg = arg;
                        splitTest = test;
                        splitDiff = c;
                    }
                }
            }
            return new SplitRecord(splitArg, splitTest);
        }
----------------------------------------
        SplitRecord split() {
            int splitArg = -1;
            int splitTest = -1;
            int splitDiff = 1000;
            for (int arg = 0; arg < 4; arg++) {
                for (int test = 0; test < encoding.length; test++) {
                    int c = getEncodingSplit(arg, test);
                    if (c == 0) return new SplitRecord(arg, test); else if (c < splitDiff) {
                        splitArg = arg;
                        splitTest = test;
                        splitDiff = c;
                    }
                }
            }
            return new SplitRecord(splitArg, splitTest);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,87896.java,648,665
default,8952.java,667,685
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,130398.java,159,173
default,100171.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,29134.java,24,42
default,76967.java,24,42
----------------------------------------
    public Interactive() {
        theGraph = new JDrawEditor(JDrawEditor.MODE_PLAY);
        try {
            theGraph.loadFile("interactive.jdw");
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, e.getMessage(), "Error loading file", JOptionPane.ERROR_MESSAGE);
            System.exit(1);
        }
        btn1 = getObject("Button1");
        btn2 = getObject("Button2");
        checkbox = getObject("Checkbox");
        textArea = (JDLabel) getObject("textArea");
        addText("");
        btn1.addValueListener(this);
        btn2.addValueListener(this);
        checkbox.addValueListener(this);
        setContentPane(theGraph);
        setTitle("Interactive");
    }
----------------------------------------
    public Interactive() {
        theGraph = new JDrawEditor(JDrawEditor.MODE_PLAY);
        try {
            theGraph.loadFile("interactive.jdw");
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, e.getMessage(), "Error loading file", JOptionPane.ERROR_MESSAGE);
            System.exit(1);
        }
        btn1 = getObject("Button1");
        btn2 = getObject("Button2");
        checkbox = getObject("Checkbox");
        textArea = (JDLabel) getObject("textArea");
        addText("");
        btn1.addValueListener(this);
        btn2.addValueListener(this);
        checkbox.addValueListener(this);
        setContentPane(theGraph);
        setTitle("Interactive");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24546.java,570,590
default,116906.java,667,685
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24546.java,667,685
default,90330.java,487,504
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24546.java,648,665
default,137594.java,629,646
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,93572.java,159,173
default,101144.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,93572.java,159,173
default,117763.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,31264.java,73,85
default,22306.java,73,85
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,71930.java,311,323
default,120736.java,325,337
----------------------------------------
    int getTemplateCommand(String line) {
        int startMatch = line.indexOf(templateMarker) + templateMarker.length() + 1;
        if (DEBUG) System.out.println("getting template command :" + line.substring(startMatch));
        for (int i = 0; i < commands.length; ++i) {
            String current = commands[i];
            if (line.regionMatches(startMatch, current, 0, current.length())) {
                params = line.substring(startMatch + current.length());
                if (DEBUG) System.out.println("command is " + commands[i] + ". params =" + params);
                return i;
            }
        }
        return INVALID_COMMAND;
    }
----------------------------------------
    int getTemplateCommand(String line) {
        int startMatch = line.indexOf(templateMarker) + templateMarker.length() + 1;
        if (DEBUG) System.out.println("getting template command :" + line.substring(startMatch));
        for (int i = 0; i < commands.length; ++i) {
            String current = commands[i];
            if (line.regionMatches(startMatch, current, 0, current.length())) {
                params = line.substring(startMatch + current.length());
                if (DEBUG) System.out.println("command is " + commands[i] + ". params =" + params);
                return i;
            }
        }
        return INVALID_COMMAND;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,71930.java,637,662
default,2909.java,656,681
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,71930.java,664,689
default,24692.java,656,681
----------------------------------------
    private int evalExpr(StreamTokenizer st) throws IOException {
        int val = evalTerm(st);
        int token = st.nextToken();
        while (token == '+' || token == '-' || token == '|' || token == '^') {
            int t = evalTerm(st);
            switch(token) {
                case '+':
                    val += t;
                    break;
                case '-':
                    val -= t;
                    break;
                case '|':
                    val |= t;
                    break;
                case '^':
                    val ^= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,27443.java,229,242
default,63608.java,229,242
----------------------------------------
    private void compareDirectories(File dirA, File dirB, String basePath) {
        TreeSet filenames = new TreeSet();
        addFiles(filenames, dirA);
        addFiles(filenames, dirB);
        Iterator i = filenames.iterator();
        String filename;
        while (i.hasNext()) {
            filename = (String) i.next();
            File fileA = makeFile(dirA, filename);
            File fileB = makeFile(dirB, filename);
            if (isFile(fileA) || isFile(fileB)) compareFile(fileA, fileB, true, basePath);
            if (isDir(fileA) || isDir(fileB)) compareDirectories(fileA, fileB, basePath);
        }
    }
----------------------------------------
    private void compareDirectories(File dirA, File dirB, String basePath) {
        TreeSet filenames = new TreeSet();
        addFiles(filenames, dirA);
        addFiles(filenames, dirB);
        Iterator i = filenames.iterator();
        String filename;
        while (i.hasNext()) {
            filename = (String) i.next();
            File fileA = makeFile(dirA, filename);
            File fileB = makeFile(dirB, filename);
            if (isFile(fileA) || isFile(fileB)) compareFile(fileA, fileB, true, basePath);
            if (isDir(fileA) || isDir(fileB)) compareDirectories(fileA, fileB, basePath);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12172.java,159,173
default,115646.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12819.java,570,590
default,86322.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12819.java,440,452
default,109369.java,440,452
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12819.java,493,507
default,53104.java,394,404
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12819.java,648,665
default,129715.java,572,592
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72460.java,35,47
default,113275.java,35,47
----------------------------------------
    public static String findInPath(String path, String fn, boolean mustBeFile) {
        StringTokenizer st = new StringTokenizer(path, File.pathSeparator);
        while (st.hasMoreTokens()) {
            String dirname = st.nextToken();
            try {
                File f = new File(dirname + File.separator + fn);
                System.out.println(" * " + f + " (" + f.exists() + ", " + f.isFile() + ")");
                if (f.exists() && (!mustBeFile || f.isFile())) return f.getPath();
            } catch (Exception fex) {
            }
        }
        return null;
    }
----------------------------------------
    public static String findInPath(String path, String fn, boolean mustBeFile) {
        StringTokenizer st = new StringTokenizer(path, File.pathSeparator);
        while (st.hasMoreTokens()) {
            String dirname = st.nextToken();
            try {
                File f = new File(dirname + File.separator + fn);
                System.out.println(" * " + f + " (" + f.exists() + ", " + f.isFile() + ")");
                if (f.exists() && (!mustBeFile || f.isFile())) return f.getPath();
            } catch (Exception fex) {
            }
        }
        return null;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12819.java,667,685
default,24621.java,648,665
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12819.java,648,665
default,19573.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,3931.java,355,367
default,2619.java,284,295
----------------------------------------
    public boolean pstepOverBranch(int thread) {
        int addr = reg.hardwareIP();
        boolean over_branch = true;
        boolean stillrunning;
        boolean skip_prolog = false;
        breakpoint bpSaved = bpset.lookup(addr);
        threadstep.setStepBreakpoint(thread, over_branch, skip_prolog);
        if (bpSaved != null) bpset.clearBreakpoint(bpSaved);
        stillrunning = continueCheckingForSignal(thread, PRINTASSEMBLY, false);
        threadstep.clearStepBreakpoint(thread);
        if (stillrunning && bpSaved != null) bpset.setBreakpoint(bpSaved);
        return stillrunning;
    }
----------------------------------------
    public boolean pstep(int thread, int printMode, boolean skip_prolog) {
        int addr = reg.hardwareIP();
        boolean stillrunning;
        boolean over_branch = false;
        breakpoint bpSaved = bpset.lookup(addr);
        threadstep.setStepBreakpoint(thread, over_branch, skip_prolog);
        if (bpSaved != null) bpset.clearBreakpoint(bpSaved);
        stillrunning = continueCheckingForSignal(thread, printMode, false);
        threadstep.clearStepBreakpoint(thread);
        if (stillrunning && bpSaved != null) bpset.setBreakpoint(bpSaved);
        return stillrunning;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96339.java,459,472
default,86322.java,440,452
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96339.java,667,685
default,57585.java,662,680
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,52174.java,984,1008
default,136560.java,915,937
----------------------------------------
    public void doMemoryRead(String command, String[] args) {
        int addr, count;
        switch(args.length) {
            case 0:
                printHelp(command);
                break;
            case 1:
                try {
                    addr = parseHex32(args[0]);
                    jdp_console.writeOutput(user.mem.print(addr, 5));
                } catch (NumberFormatException e) {
                    jdp_console.writeOutput("bad address: " + args[0]);
                }
                break;
            default:
                try {
                    addr = parseHex32(args[0]);
                    count = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.print(addr, count));
                } catch (NumberFormatException e) {
                    jdp_console.writeOutput("bad address or count: " + args[0] + ", " + args[1]);
                }
                break;
        }
    }
----------------------------------------
    public void doListInstruction(String command, String[] args) {
        int count;
        int addr = -1;
        try {
            switch(args.length) {
                case 0:
                    addr = user.reg.currentIP();
                    jdp_console.writeOutput(user.mem.listInstruction(addr, 10));
                    break;
                case 1:
                    addr = parseHex32(args[0]);
                    jdp_console.writeOutput(user.mem.listInstruction(addr, 10));
                    break;
                default:
                    addr = parseHex32(args[0]);
                    count = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.listInstruction(addr, count));
                    break;
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("bad address: " + args[0]);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96339.java,667,685
default,53104.java,648,665
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95380.java,165,191
default,35733.java,165,191
----------------------------------------
    public void run() {
        try {
            writer.println("READY");
            String command = null;
            int status;
            while ((command = reader.readLine()) != null && command.equals("TTS")) {
                requestReceivedTime = System.currentTimeMillis();
                status = handleSynthesisRequest();
                if (status == INVALID_SAMPLE_RATE) {
                    println("Invalid sample rate\nexit.");
                    return;
                } else if (metrics) {
                    System.out.println("Time To Sending First Byte: " + (socketAudioPlayer.getFirstByteSentTime() - requestReceivedTime) + " ms");
                }
            }
            if (command != null) {
                if (command.equals("DONE")) {
                    socket.close();
                    println("... closed socket connection");
                } else {
                    println("invalid command: " + command);
                }
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
----------------------------------------
    public void run() {
        try {
            writer.println("READY");
            String command = null;
            int status;
            while ((command = reader.readLine()) != null && command.equals("TTS")) {
                requestReceivedTime = System.currentTimeMillis();
                status = handleSynthesisRequest();
                if (status == INVALID_SAMPLE_RATE) {
                    println("Invalid sample rate\nexit.");
                    return;
                } else if (metrics) {
                    System.out.println("Time To Sending First Byte: " + (socketAudioPlayer.getFirstByteSentTime() - requestReceivedTime) + " ms");
                }
            }
            if (command != null) {
                if (command.equals("DONE")) {
                    socket.close();
                    println("... closed socket connection");
                } else {
                    println("invalid command: " + command);
                }
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,85127.java,570,590
default,42993.java,565,585
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,85127.java,394,404
default,24546.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,85127.java,648,665
default,24546.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,115,130
default,93943.java,132,146
----------------------------------------
    @Test
    public void test2() throws Exception {
        String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, \"Hey!\"", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,263,274
default,119807.java,263,274
----------------------------------------
    @Test
    public void test11() throws Exception {
        String data = "\"July 4th, 2005\"";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("July 4th, 2005", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"July 4th, 2005\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test11() throws Exception {
        String data = "\"July 4th, 2005\"";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("July 4th, 2005", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"July 4th, 2005\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,247,261
default,80510.java,939,952
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test51() throws Exception {
        String data = "\"\\xfa\\u0afa\\xFA\\u0AFA\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\"\\xfa\\u0afa\\xFA\\u0AFA\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,247,261
default,39035.java,148,165
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test4() throws Exception {
        String data = "1\r2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,247,261
default,93943.java,803,816
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test44() throws Exception {
        String data = "line 1\\nline 2,line 1\\\nline 2";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("line 1\nline 2", reader.get(0));
        Assert.assertEquals("line 1\nline 2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,939,952
default,124923.java,924,937
----------------------------------------
    @Test
    public void test51() throws Exception {
        String data = "\"\\xfa\\u0afa\\xFA\\u0AFA\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\"\\xfa\\u0afa\\xFA\\u0AFA\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test50() throws Exception {
        String data = "\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,954,967
default,28532.java,954,967
----------------------------------------
    @Test
    public void test52() throws Exception {
        String data = "\\xfa\\u0afa\\xFA\\u0AFA";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\\xfa\\u0afa\\xFA\\u0AFA", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test52() throws Exception {
        String data = "\\xfa\\u0afa\\xFA\\u0AFA";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\\xfa\\u0afa\\xFA\\u0AFA", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,954,967
default,93943.java,247,261
----------------------------------------
    @Test
    public void test52() throws Exception {
        String data = "\\xfa\\u0afa\\xFA\\u0AFA";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\\xfa\\u0afa\\xFA\\u0AFA", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,1137,1153
default,124923.java,1040,1055
----------------------------------------
    @Test
    public void test74() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.setUseTextQualifier(false);
        writer.write("1,2");
        writer.write("3");
        writer.write("blah \"some stuff in quotes\"");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
    }
----------------------------------------
    @Test
    public void test58() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, '\t', Charset.forName("ISO-8859-1"));
        writer.write("data\r\nmore data");
        writer.write(" 3\t", false);
        writer.write(" 3\t");
        writer.write(" 3\t", true);
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,1548,1565
default,28532.java,1567,1580
----------------------------------------
    @Test
    public void test131() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setUseTextQualifier(false);
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1,\\\r\n2");
        writer.endRecord();
        writer.setRecordDelimiter(';');
        writer.write("1,\\;2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
    }
----------------------------------------
    @Test
    public void test132() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1,\\2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"1,\\\\2\"\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,1531,1546
default,114239.java,1137,1153
----------------------------------------
    @Test
    public void test124() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setRecordDelimiter(';');
        writer.setUseTextQualifier(false);
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1;2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\;2;", data);
    }
----------------------------------------
    @Test
    public void test74() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.setUseTextQualifier(false);
        writer.write("1,2");
        writer.write("3");
        writer.write("blah \"some stuff in quotes\"");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,1400,1417
default,122249.java,1005,1019
----------------------------------------
    @Test
    public void test117() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        Assert.assertEquals('#', writer.getComment());
        writer.setComment('~');
        Assert.assertEquals('~', writer.getComment());
        writer.setRecordDelimiter(';');
        writer.write("1");
        writer.endRecord();
        writer.writeComment("blah");
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1;~blah;", data);
    }
----------------------------------------
    @Test
    public void test56() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, '\t', Charset.forName("ISO-8859-1"));
        writer.write("1,2");
        writer.write("3");
        writer.write("blah \"some stuff in quotes\"");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122249.java,1495,1509
default,93943.java,1021,1038
----------------------------------------
    @Test
    public void test122() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.write("1,2");
        writer.write(null);
        writer.write("3 ", true);
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"1,2\",,\"3 \"\r\n", data);
    }
----------------------------------------
    @Test
    public void test57() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, '\t', Charset.forName("ISO-8859-1"));
        Assert.assertTrue(writer.getUseTextQualifier());
        writer.setUseTextQualifier(false);
        Assert.assertFalse(writer.getUseTextQualifier());
        writer.write("1,2");
        writer.write("3");
        writer.write("blah \"some stuff in quotes\"");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122366.java,974,988
default,129984.java,974,988
----------------------------------------
    String substitute(String input, String var, String value) throws IOException {
        StringBuffer out = new StringBuffer();
        int varlen = var.length();
        int oidx = 0;
        for (; ; ) {
            int idx = input.indexOf(var, oidx);
            if (idx == -1) break;
            out.append(input.substring(oidx, idx));
            idx += varlen;
            out.append(value);
            oidx = idx;
        }
        out.append(input.substring(oidx));
        return out.toString();
    }
----------------------------------------
    String substitute(String input, String var, String value) throws IOException {
        StringBuffer out = new StringBuffer();
        int varlen = var.length();
        int oidx = 0;
        for (; ; ) {
            int idx = input.indexOf(var, oidx);
            if (idx == -1) break;
            out.append(input.substring(oidx, idx));
            idx += varlen;
            out.append(value);
            oidx = idx;
        }
        out.append(input.substring(oidx));
        return out.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122366.java,683,708
default,14977.java,656,681
----------------------------------------
    private int evalExpr(StreamTokenizer st) throws IOException {
        int val = evalTerm(st);
        int token = st.nextToken();
        while (token == '+' || token == '-' || token == '|' || token == '^') {
            int t = evalTerm(st);
            switch(token) {
                case '+':
                    val += t;
                    break;
                case '-':
                    val -= t;
                    break;
                case '|':
                    val |= t;
                    break;
                case '^':
                    val ^= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35432.java,648,665
default,90330.java,428,448
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35432.java,570,590
default,96339.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35432.java,629,646
default,14709.java,624,641
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,105863.java,159,173
default,48890.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35432.java,629,646
default,24621.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76392.java,440,452
default,56216.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76392.java,459,472
default,96339.java,440,452
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76392.java,493,507
default,103146.java,394,404
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76392.java,667,685
default,21681.java,648,665
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76392.java,667,685
default,19573.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76392.java,667,685
default,6320.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55109.java,394,404
default,44026.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55109.java,570,590
default,15343.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55109.java,394,404
default,32654.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76392.java,648,665
default,70088.java,631,648
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55109.java,648,665
default,28782.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55109.java,667,685
default,96339.java,629,646
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62679.java,570,590
default,28782.java,667,685
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62679.java,459,472
default,124843.java,459,472
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62679.java,459,472
default,27552.java,440,452
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62679.java,570,590
default,118344.java,546,568
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,8528.java,293,309
default,24692.java,303,323
----------------------------------------
    void buildIncludeRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing filename in INCLUDE");
        String file_name = pst.nextToken();
        LineNumberReader old_in = in;
        in = new LineNumberReader(new FileReader(file_name));
        String inLine;
        for (inLine = readLine(); inLine != null; inLine = readLine()) {
            if (isTemplateLine(inLine)) {
                region.addElement(buildTemplateRegion(inLine));
            } else {
                if (DEBUG) System.out.println("adding line to region :" + inLine);
                region.addElement(inLine);
            }
        }
        in = old_in;
    }
----------------------------------------
    void buildIncludeRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing filename in INCLUDE");
        String file_name = pst.nextToken();
        LineNumberReader old_in = in;
        try {
            in = new LineNumberReader(new FileReader(file_name));
        } catch (java.io.FileNotFoundException e) {
            in = new LineNumberReader(new FileReader(inDir + file_name));
        }
        String inLine;
        for (inLine = readLine(); inLine != null; inLine = readLine()) {
            if (isTemplateLine(inLine)) {
                region.addElement(buildTemplateRegion(inLine));
            } else {
                if (DEBUG) System.out.println("adding line to region :" + inLine);
                region.addElement(inLine);
            }
        }
        in = old_in;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,81123.java,631,648
default,24621.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,81123.java,606,619
default,36322.java,604,617
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65107.java,159,173
default,100859.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,81123.java,669,687
default,57585.java,624,641
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,66268.java,325,337
default,129984.java,325,337
----------------------------------------
    int getTemplateCommand(String line) {
        int startMatch = line.indexOf(templateMarker) + templateMarker.length() + 1;
        if (DEBUG) System.out.println("getting template command :" + line.substring(startMatch));
        for (int i = 0; i < commands.length; ++i) {
            String current = commands[i];
            if (line.regionMatches(startMatch, current, 0, current.length())) {
                params = line.substring(startMatch + current.length());
                if (DEBUG) System.out.println("command is " + commands[i] + ". params =" + params);
                return i;
            }
        }
        return INVALID_COMMAND;
    }
----------------------------------------
    int getTemplateCommand(String line) {
        int startMatch = line.indexOf(templateMarker) + templateMarker.length() + 1;
        if (DEBUG) System.out.println("getting template command :" + line.substring(startMatch));
        for (int i = 0; i < commands.length; ++i) {
            String current = commands[i];
            if (line.regionMatches(startMatch, current, 0, current.length())) {
                params = line.substring(startMatch + current.length());
                if (DEBUG) System.out.println("command is " + commands[i] + ". params =" + params);
                return i;
            }
        }
        return INVALID_COMMAND;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,66268.java,907,922
default,71930.java,888,903
----------------------------------------
    Vector substituteInRegion(Vector region, String var, String[] fields, String[] fieldData) throws IOException {
        Vector newRegion = new Vector(region.size());
        for (int i = 0; i < region.size(); i++) {
            Object el = region.elementAt(i);
            try {
                String s = (String) el;
                String r = substitute(s, var, fields, fieldData);
                newRegion.addElement(r);
            } catch (ClassCastException e) {
                Vector s = (Vector) el;
                Vector r = substituteInRegion(s, var, fields, fieldData);
                newRegion.addElement(r);
            }
        }
        return newRegion;
    }
----------------------------------------
    Vector substituteInRegion(Vector region, String var, String[] fields, String[] fieldData) throws IOException {
        Vector newRegion = new Vector(region.size());
        for (int i = 0; i < region.size(); i++) {
            Object el = region.elementAt(i);
            try {
                String s = (String) el;
                String r = substitute(s, var, fields, fieldData);
                newRegion.addElement(r);
            } catch (ClassCastException e) {
                Vector s = (Vector) el;
                Vector r = substituteInRegion(s, var, fields, fieldData);
                newRegion.addElement(r);
            }
        }
        return newRegion;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72294.java,442,454
default,6320.java,440,452
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72294.java,495,509
default,95647.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72294.java,442,454
default,6937.java,440,452
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56025.java,11,28
default,107391.java,11,28
----------------------------------------
    public static void main(String[] argv) {
        try {
            int num = 1;
            if (argv.length > 0) {
                num = Integer.parseInt(argv[0]);
            }
            Thread[] threadList = new Thread[num];
            for (int i = 0; i < num; ++i) {
                threadList[i] = new TestRuntimeExec(i);
                threadList[i].start();
            }
            for (int i = 0; i < num; ++i) threadList[i].join();
            System.out.println("All test threads finished");
        } catch (Exception e) {
            System.out.println("TestRuntimeExec: FAILED");
            System.exit(1);
        }
    }
----------------------------------------
    public static void main(String[] argv) {
        try {
            int num = 1;
            if (argv.length > 0) {
                num = Integer.parseInt(argv[0]);
            }
            Thread[] threadList = new Thread[num];
            for (int i = 0; i < num; ++i) {
                threadList[i] = new TestRuntimeExec(i);
                threadList[i].start();
            }
            for (int i = 0; i < num; ++i) threadList[i].join();
            System.out.println("All test threads finished");
        } catch (Exception e) {
            System.out.println("TestRuntimeExec: FAILED");
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115412.java,159,173
default,105863.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72294.java,669,687
default,76192.java,667,685
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72294.java,650,667
default,45549.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133515.java,394,404
default,109369.java,394,404
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133515.java,629,646
default,25053.java,546,568
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133515.java,570,590
default,50971.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133515.java,493,507
default,118405.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133515.java,570,590
default,103762.java,629,646
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133515.java,570,590
default,40375.java,525,543
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133515.java,570,590
default,45549.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40654.java,495,509
default,81123.java,495,509
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40654.java,631,648
default,12819.java,648,665
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40654.java,631,648
default,85127.java,629,646
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40654.java,669,687
default,97360.java,631,648
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40654.java,631,648
default,98684.java,546,568
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115118.java,629,646
default,87896.java,648,665
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115118.java,440,452
default,114331.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115118.java,394,404
default,114331.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,120462.java,73,85
default,76845.java,73,85
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
    private static void encapsulate(Configuration cfg, File pdfFile, File dcmFile) throws IOException {
        final DcmObjectFactory df = DcmObjectFactory.getInstance();
        Dataset ds = df.newDataset();
        for (Iterator it = cfg.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e = (Map.Entry) it.next();
            put(ds, toTags(StringUtils.split((String) e.getKey(), '/')), (String) e.getValue());
        }
        addUIDs(ds);
        addContentDateTime(ds);
        ds.setFileMetaInfo(df.newFileMetaInfo(ds, UIDs.ExplicitVRLittleEndian));
        write(pdfFile, dcmFile, ds);
        System.out.println("Encapsulate " + pdfFile + " into " + dcmFile);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115118.java,667,685
default,40654.java,650,667
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115118.java,667,685
default,132787.java,648,665
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14833.java,159,173
default,45886.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115701.java,48,62
default,28225.java,60,74
----------------------------------------
    public void save() throws IOException {
        File backup = new File(file.getAbsolutePath() + "~");
        ;
        file.renameTo(backup);
        OutputFormat format = new OutputFormat(doc);
        format.setEncoding("ISO-8859-15");
        format.setLineSeparator(LineSeparator.Unix);
        format.setIndenting(true);
        format.setLineWidth(0);
        format.setPreserveSpace(false);
        XMLSerializer serializer = new XMLSerializer(new FileWriter(file), format);
        serializer.asDOMSerializer();
        serializer.serialize(doc);
        changed = false;
    }
----------------------------------------
    public void save() throws IOException {
        File backup = new File(file.getAbsolutePath() + "~");
        ;
        OutputFormat format = new OutputFormat(doc);
        format.setEncoding("ISO-8859-15");
        format.setLineSeparator(LineSeparator.Unix);
        format.setIndenting(true);
        format.setLineWidth(0);
        format.setPreserveSpace(false);
        XMLSerializer serializer = new XMLSerializer(new FileWriter(backup), format);
        serializer.asDOMSerializer();
        serializer.serialize(doc);
        changed = false;
        backup.renameTo(file);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,131657.java,48,62
default,88616.java,48,62
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23875.java,570,590
default,24546.java,667,685
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23875.java,570,590
default,134647.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23875.java,648,665
default,42612.java,570,590
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23875.java,648,665
default,42612.java,667,685
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23875.java,648,665
default,133515.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23409.java,629,646
default,42993.java,662,680
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23409.java,604,617
default,97360.java,606,619
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23409.java,667,685
default,15343.java,546,568
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23409.java,493,507
default,98684.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23409.java,440,452
default,23875.java,440,452
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59932.java,115,130
default,114239.java,115,130
----------------------------------------
    @Test
    public void test2() throws Exception {
        String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, \"Hey!\"", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test2() throws Exception {
        String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, \"Hey!\"", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59932.java,132,146
default,119807.java,528,543
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test28() throws Exception {
        String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("bob said, \"Hey!\"", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals("3", reader.get(2));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(3, reader.getColumnCount());
        Assert.assertEquals("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59932.java,167,184
default,114239.java,132,146
----------------------------------------
    @Test
    public void test5() throws Exception {
        String data = "1\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23409.java,648,665
default,76192.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59932.java,559,571
default,124923.java,939,952
----------------------------------------
    @Test
    public void test30() throws Exception {
        String data = "\"double\\\\\\\\double backslash\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("double\\\\double backslash", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"double\\\\\\\\double backslash\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test51() throws Exception {
        String data = "\"\\xfa\\u0afa\\xFA\\u0AFA\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\"\\xfa\\u0afa\\xFA\\u0AFA\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59932.java,939,952
default,80510.java,909,922
----------------------------------------
    @Test
    public void test51() throws Exception {
        String data = "\"\\xfa\\u0afa\\xFA\\u0AFA\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\"\\xfa\\u0afa\\xFA\\u0AFA\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test49() throws Exception {
        String data = "\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59932.java,1005,1019
default,119807.java,1531,1546
----------------------------------------
    @Test
    public void test56() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, '\t', Charset.forName("ISO-8859-1"));
        writer.write("1,2");
        writer.write("3");
        writer.write("blah \"some stuff in quotes\"");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
    }
----------------------------------------
    @Test
    public void test124() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setRecordDelimiter(';');
        writer.setUseTextQualifier(false);
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1;2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\;2;", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59932.java,939,952
default,93943.java,247,261
----------------------------------------
    @Test
    public void test51() throws Exception {
        String data = "\"\\xfa\\u0afa\\xFA\\u0AFA\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\"\\xfa\\u0afa\\xFA\\u0AFA\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59932.java,1137,1153
default,122249.java,1531,1546
----------------------------------------
    @Test
    public void test74() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.setUseTextQualifier(false);
        writer.write("1,2");
        writer.write("3");
        writer.write("blah \"some stuff in quotes\"");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
    }
----------------------------------------
    @Test
    public void test124() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setRecordDelimiter(';');
        writer.setUseTextQualifier(false);
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1;2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\;2;", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43190.java,570,590
default,15343.java,667,685
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43190.java,604,617
default,129715.java,606,619
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43190.java,440,452
default,118405.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59278.java,180,196
default,29731.java,241,257
----------------------------------------
    private void archiveOldItem(ScheduleItem removedItem) {
        try {
            SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd@HHmmssS");
            String archiveName = new DllWrapper().getAllUserPath() + "archive\\Schedule-" + df.format(removedItem.getStart()) + " (" + removedItem.getChannel() + ") (" + removedItem.getName() + ").sof";
            File outFile = new File(archiveName);
            outFile = outFile.getCanonicalFile();
            File parent = outFile.getParentFile();
            if (parent.exists() == false) parent.mkdirs();
            FileOutputStream fos = new FileOutputStream(outFile);
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(removedItem);
            oos.close();
        } catch (Exception e) {
            System.out.println("Error trying to archive old Schedule Item:");
            e.printStackTrace();
        }
    }
----------------------------------------
    private void archiveOldItem(ScheduleItem removedItem) {
        try {
            SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd@HHmmssS");
            String archiveName = new DllWrapper().getAllUserPath() + "archive\\Schedule-" + df.format(removedItem.getStart()) + " (" + removedItem.getChannel() + ") (" + removedItem.getName() + ").sof";
            File outFile = new File(archiveName);
            outFile = outFile.getCanonicalFile();
            File parent = outFile.getParentFile();
            if (parent.exists() == false) parent.mkdirs();
            FileOutputStream fos = new FileOutputStream(outFile);
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(removedItem);
            oos.close();
        } catch (Exception e) {
            System.out.println("Error trying to archive old Schedule Item:");
            e.printStackTrace();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43190.java,629,646
default,40654.java,524,546
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43190.java,648,665
default,40654.java,669,687
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96485.java,75,91
default,113089.java,75,91
----------------------------------------
    private void open(File f) {
        try {
            ImageInputStream iis = ImageIO.createImageInputStream(f);
            Iterator iter = ImageIO.getImageReadersByFormatName("DICOM");
            ImageReader reader = (ImageReader) iter.next();
            reader.setInput(iis, false);
            JPanel p = new ImageBox(reader);
            JFrame jf = new JFrame("ImageDisplay - Display Panel");
            jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            jf.getContentPane().add(p);
            jf.pack();
            jf.setSize(Math.min(jf.getWidth(), 800), Math.min(jf.getHeight(), 600));
            jf.setVisible(true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
----------------------------------------
    private void open(File f) {
        try {
            ImageInputStream iis = ImageIO.createImageInputStream(f);
            Iterator iter = ImageIO.getImageReadersByFormatName("DICOM");
            ImageReader reader = (ImageReader) iter.next();
            reader.setInput(iis, false);
            JPanel p = new ImageBox(reader);
            JFrame jf = new JFrame("ImageDisplay - Display Panel");
            jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            jf.getContentPane().add(p);
            jf.pack();
            jf.setSize(Math.min(jf.getWidth(), 800), Math.min(jf.getHeight(), 600));
            jf.setVisible(true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,125218.java,186,203
default,119807.java,247,261
----------------------------------------
    @Test
    public void test6() throws Exception {
        String data = "1\r\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,125218.java,186,203
default,93943.java,186,203
----------------------------------------
    @Test
    public void test6() throws Exception {
        String data = "1\r\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test6() throws Exception {
        String data = "1\r\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,125218.java,924,937
default,125218.java,803,816
----------------------------------------
    @Test
    public void test50() throws Exception {
        String data = "\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test44() throws Exception {
        String data = "line 1\\nline 2,line 1\\\nline 2";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("line 1\nline 2", reader.get(0));
        Assert.assertEquals("line 1\nline 2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,125218.java,1097,1112
default,114239.java,1548,1565
----------------------------------------
    @Test
    public void test72() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        Assert.assertEquals('\0', writer.getRecordDelimiter());
        writer.setRecordDelimiter(';');
        Assert.assertEquals(';', writer.getRecordDelimiter());
        writer.write("a;b");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"a;b\";", data);
    }
----------------------------------------
    @Test
    public void test131() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setUseTextQualifier(false);
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1,\\\r\n2");
        writer.endRecord();
        writer.setRecordDelimiter(';');
        writer.write("1,\\;2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,13801.java,976,990
default,2909.java,974,988
----------------------------------------
    String substitute(String input, String var, String value) throws IOException {
        StringBuffer out = new StringBuffer();
        int varlen = var.length();
        int oidx = 0;
        for (; ; ) {
            int idx = input.indexOf(var, oidx);
            if (idx == -1) break;
            out.append(input.substring(oidx, idx));
            idx += varlen;
            out.append(value);
            oidx = idx;
        }
        out.append(input.substring(oidx));
        return out.toString();
    }
----------------------------------------
    String substitute(String input, String var, String value) throws IOException {
        StringBuffer out = new StringBuffer();
        int varlen = var.length();
        int oidx = 0;
        for (; ; ) {
            int idx = input.indexOf(var, oidx);
            if (idx == -1) break;
            out.append(input.substring(oidx, idx));
            idx += varlen;
            out.append(value);
            oidx = idx;
        }
        out.append(input.substring(oidx));
        return out.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,47096.java,889,905
default,124942.java,778,794
----------------------------------------
    private boolean matchResultToObject(String methodName, Object expectedResult, Object returnedResult) {
        if (expectedResult.equals(returnedResult)) {
            System.out.println("SUCCESS@" + methodName);
            System.out.println("EXPECTED");
            System.out.println(expectedResult);
            System.out.println("RETURNED");
            System.out.println(returnedResult + "\n");
            return true;
        } else {
            System.out.println("FAILURE@" + methodName);
            System.out.println("EXPECTED");
            System.out.println(expectedResult);
            System.out.println("RETURNED");
            System.out.println(returnedResult + "\n");
            return false;
        }
    }
----------------------------------------
    private boolean matchResultToObject(String methodName, Object expectedResult, Object returnedResult) {
        if (expectedResult.equals(returnedResult)) {
            System.out.println("SUCCESS@" + methodName);
            System.out.println("EXPECTED");
            System.out.println(expectedResult);
            System.out.println("RETURNED");
            System.out.println(returnedResult + "\n");
            return true;
        } else {
            System.out.println("FAILURE@" + methodName);
            System.out.println("EXPECTED");
            System.out.println(expectedResult);
            System.out.println("RETURNED");
            System.out.println(returnedResult + "\n");
            return false;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129185.java,9,26
default,75105.java,11,28
----------------------------------------
    public static void main(String[] argv) {
        try {
            int num = 1;
            if (argv.length > 0) {
                num = Integer.parseInt(argv[0]);
            }
            Thread[] threadList = new Thread[num];
            for (int i = 0; i < num; ++i) {
                threadList[i] = new TestRuntimeExec(i);
                threadList[i].start();
            }
            for (int i = 0; i < num; ++i) threadList[i].join();
            System.out.println("All test threads finished");
        } catch (Exception e) {
            System.out.println("TestRuntimeExec: FAILED");
            System.exit(1);
        }
    }
----------------------------------------
    public static void main(String[] argv) {
        try {
            int num = 1;
            if (argv.length > 0) {
                num = Integer.parseInt(argv[0]);
            }
            Thread[] threadList = new Thread[num];
            for (int i = 0; i < num; ++i) {
                threadList[i] = new TestRuntimeExec(i);
                threadList[i].start();
            }
            for (int i = 0; i < num; ++i) threadList[i].join();
            System.out.println("All test threads finished");
        } catch (Exception e) {
            System.out.println("TestRuntimeExec: FAILED");
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,89117.java,1144,1159
default,51140.java,1140,1153
----------------------------------------
    public String getTargetURL(String id, String def) {
        String data = def;
        try {
            String httpDir = getProperty("path.httproot");
            String themeDir = getProperty("path.theme");
            String path = httpDir + File.separator + "themes" + File.separator + themeDir + File.separator + "xsl" + File.separator + "target.urls";
            Properties prop = new Properties();
            FileInputStream fileStream = new FileInputStream(path);
            prop.load(fileStream);
            fileStream.close();
            data = prop.getProperty(id, def);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }
----------------------------------------
    public String getTargetURL(String id, String def) {
        String data = def;
        try {
            String httpDir = getProperty("path.httproot");
            String themeDir = getProperty("path.theme");
            String path = httpDir + File.separator + "themes" + File.separator + themeDir + File.separator + "xsl" + File.separator + "target.urls";
            Properties prop = new Properties();
            prop.load(new FileInputStream(path));
            data = prop.getProperty(id, def);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,47340.java,159,173
default,115646.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65102.java,48,62
default,56674.java,48,62
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5251.java,394,404
default,42612.java,493,507
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5251.java,280,289
default,81123.java,280,289
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5251.java,648,665
default,134647.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42106.java,440,452
default,103146.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5251.java,629,646
default,23875.java,522,544
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42106.java,440,452
default,133515.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42106.java,629,646
default,27552.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79086.java,394,404
default,42993.java,389,399
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79086.java,570,590
default,57585.java,643,660
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79086.java,570,590
default,51700.java,669,687
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79086.java,648,665
default,43190.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79086.java,629,646
default,32654.java,522,544
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32536.java,570,590
default,36322.java,570,590
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32536.java,604,617
default,25053.java,604,617
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32536.java,570,590
default,93897.java,546,568
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32536.java,509,520
default,96339.java,509,520
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32536.java,667,685
default,70505.java,524,546
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32536.java,648,665
default,137594.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,119524.java,589,603
default,70284.java,573,587
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32536.java,648,665
default,92220.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32536.java,667,685
default,72294.java,548,570
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16641.java,394,404
default,42612.java,394,404
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16641.java,629,646
default,103146.java,522,544
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16641.java,667,685
default,90330.java,525,543
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,58531.java,570,590
default,15343.java,629,646
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,58531.java,570,590
default,103762.java,546,568
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,58531.java,629,646
default,53104.java,648,665
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,58531.java,648,665
default,4439.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57168.java,570,590
default,103146.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57168.java,570,590
default,95647.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57168.java,667,685
default,129715.java,572,592
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,106112.java,132,146
default,93943.java,655,667
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test36() throws Exception {
        String data = "\"some \\stuff\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("some stuff", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"some \\stuff\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,106112.java,247,261
default,80510.java,909,922
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test49() throws Exception {
        String data = "\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,106112.java,1567,1580
default,59932.java,1155,1170
----------------------------------------
    @Test
    public void test132() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.write("1,\\2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"1,\\\\2\"\r\n", data);
    }
----------------------------------------
    @Test
    public void test75() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.write("1");
        writer.endRecord();
        writer.writeComment("blah");
        writer.write("2");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1\r\n#blah\r\n2\r\n", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,106112.java,1511,1529
default,28532.java,1400,1417
----------------------------------------
    @Test
    public void test123() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        writer.write("#123");
        writer.endRecord();
        writer.setEscapeMode(CsvWriter.ESCAPE_MODE_BACKSLASH);
        writer.setUseTextQualifier(false);
        writer.write("#123");
        writer.endRecord();
        writer.write("#");
        writer.endRecord();
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
    }
----------------------------------------
    @Test
    public void test117() throws Exception {
        byte[] buffer;
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        CsvWriter writer = new CsvWriter(stream, ',', Charset.forName("ISO-8859-1"));
        Assert.assertEquals('#', writer.getComment());
        writer.setComment('~');
        Assert.assertEquals('~', writer.getComment());
        writer.setRecordDelimiter(';');
        writer.write("1");
        writer.endRecord();
        writer.writeComment("blah");
        writer.close();
        buffer = stream.toByteArray();
        stream.close();
        String data = Charset.forName("ISO-8859-1").decode(ByteBuffer.wrap(buffer)).toString();
        Assert.assertEquals("1;~blah;", data);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,121888.java,159,173
default,46050.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40796.java,6,23
default,65897.java,11,28
----------------------------------------
    public static void main(String[] argv) {
        try {
            int num = 1;
            if (argv.length > 0) {
                num = Integer.parseInt(argv[0]);
            }
            Thread[] threadList = new Thread[num];
            for (int i = 0; i < num; ++i) {
                threadList[i] = new TestRuntimeExec(i);
                threadList[i].start();
            }
            for (int i = 0; i < num; ++i) threadList[i].join();
            System.out.println("All test threads finished");
        } catch (Exception e) {
            System.out.println("TestRuntimeExec: FAILED");
            System.exit(1);
        }
    }
----------------------------------------
    public static void main(String[] argv) {
        try {
            int num = 1;
            if (argv.length > 0) {
                num = Integer.parseInt(argv[0]);
            }
            Thread[] threadList = new Thread[num];
            for (int i = 0; i < num; ++i) {
                threadList[i] = new TestRuntimeExec(i);
                threadList[i].start();
            }
            for (int i = 0; i < num; ++i) threadList[i].join();
            System.out.println("All test threads finished");
        } catch (Exception e) {
            System.out.println("TestRuntimeExec: FAILED");
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65982.java,570,590
default,24621.java,546,568
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65982.java,394,404
default,14709.java,488,502
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65982.java,280,289
default,81123.java,280,289
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65982.java,629,646
default,72294.java,650,667
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73352.java,572,592
default,90330.java,380,402
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73352.java,572,592
default,25053.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80832.java,148,165
default,119807.java,132,146
----------------------------------------
    @Test
    public void test4() throws Exception {
        String data = "1\r2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80832.java,132,146
default,119807.java,559,571
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test30() throws Exception {
        String data = "\"double\\\\\\\\double backslash\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("double\\\\double backslash", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"double\\\\\\\\double backslash\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80832.java,132,146
default,5657.java,132,146
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test3() throws Exception {
        String data = ",";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("", reader.get(1));
        Assert.assertEquals(',', reader.getDelimiter());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals(",", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80832.java,186,203
default,119807.java,247,261
----------------------------------------
    @Test
    public void test6() throws Exception {
        String data = "1\r\n2";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("1", reader.getRawRecord());
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("2", reader.get(0));
        Assert.assertEquals(1L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test10() throws Exception {
        String data = "1\r2\n";
        CsvReader reader = CsvReader.parse(data);
        reader.setDelimiter('\r');
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("1", reader.get(0));
        Assert.assertEquals("2", reader.get(1));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(2, reader.getColumnCount());
        Assert.assertEquals("1\r2", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        Assert.assertEquals("", reader.getRawRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73352.java,650,667
default,81123.java,524,546
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73352.java,669,687
default,115118.java,648,665
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73352.java,650,667
default,118405.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73352.java,650,667
default,8952.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80832.java,320,331
default,28532.java,924,937
----------------------------------------
    @Test
    public void test15() throws Exception {
        String data = "\"data \r\n here\"";
        CsvReader reader = CsvReader.parse(data);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("data \r\n here", reader.get(0));
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertEquals("\"data \r\n here\"", reader.getRawRecord());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test50() throws Exception {
        String data = "\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(false);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80832.java,939,952
default,119807.java,909,922
----------------------------------------
    @Test
    public void test51() throws Exception {
        String data = "\"\\xfa\\u0afa\\xFA\\u0AFA\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("", reader.get(0));
        Assert.assertEquals("\"\\xfa\\u0afa\\xFA\\u0AFA\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
    @Test
    public void test49() throws Exception {
        String data = "\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"";
        CsvReader reader = CsvReader.parse(data);
        reader.setUseTextQualifier(true);
        reader.setEscapeMode(CsvReader.ESCAPE_MODE_BACKSLASH);
        Assert.assertTrue(reader.readRecord());
        Assert.assertEquals("\n\r\t\b\fzAAAAA", reader.get(0));
        Assert.assertEquals("\"\\n\\r\\t\\b\\f\\e\\v\\a\\z\\d065\\o101\\101\\x41\\u0041\"", reader.getRawRecord());
        Assert.assertEquals(0L, reader.getCurrentRecord());
        Assert.assertEquals(1, reader.getColumnCount());
        Assert.assertFalse(reader.readRecord());
        reader.close();
    }
----------------------------------------
