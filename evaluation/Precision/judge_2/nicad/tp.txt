$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35234.java,164,591
default,104167.java,164,591
----------------------------------------
    private byte[] showEPG(HTTPurl urlData, HashMap<String, String> headers) throws Exception {
        Calendar now = Calendar.getInstance();
        now.set(Calendar.SECOND, 0);
        now.set(Calendar.MILLISECOND, 0);
        int year = -1;
        try {
            year = Integer.parseInt(urlData.getParameter("year"));
        } catch (Exception e) {
        }
        if (year == -1) year = now.get(Calendar.YEAR);
        int month = -1;
        try {
            month = Integer.parseInt(urlData.getParameter("month"));
        } catch (Exception e) {
        }
        if (month == -1) month = now.get(Calendar.MONTH) + 1;
        int day = -1;
        try {
            day = Integer.parseInt(urlData.getParameter("day"));
        } catch (Exception e) {
        }
        if (day == -1) day = now.get(Calendar.DATE);
        int startHour = -1;
        try {
            startHour = Integer.parseInt(urlData.getParameter("start"));
        } catch (Exception e) {
        }
        if (startHour == -1) startHour = now.get(Calendar.HOUR_OF_DAY);
        int timeSpan = 3;
        try {
            timeSpan = Integer.parseInt(urlData.getParameter("span"));
        } catch (Exception e) {
        }
        String selected = urlData.getParameter("selected");
        if (selected == null || selected.length() == 0) selected = "";
        SimpleDateFormat df = new SimpleDateFormat("h:mma");
        SimpleDateFormat df2 = new SimpleDateFormat("yyyyMMddHHmmss Z");
        boolean showUnlinked = store.getProperty("epg.showunlinked").equals("1");
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        DOMImplementation di = db.getDOMImplementation();
        Document doc = di.createDocument("", "epg", null);
        Element root = doc.getDocumentElement();
        root.setAttribute("year", new Integer(year).toString());
        root.setAttribute("month", new Integer(month).toString());
        root.setAttribute("day", new Integer(day).toString());
        root.setAttribute("start", new Integer(startHour).toString());
        root.setAttribute("show", new Integer(timeSpan).toString());
        Element itemEl = null;
        Element elm = null;
        Text text = null;
        Calendar startPointer = Calendar.getInstance();
        startPointer.set(Calendar.SECOND, 0);
        startPointer.set(Calendar.MINUTE, 0);
        startPointer.set(Calendar.MILLISECOND, 0);
        startPointer.set(Calendar.YEAR, year);
        startPointer.set(Calendar.MONTH, month - 1);
        startPointer.set(Calendar.DATE, day);
        startPointer.set(Calendar.HOUR_OF_DAY, startHour);
        long nowLong = new Date().getTime();
        long startLong = startPointer.getTime().getTime();
        long minPast = (nowLong - startLong) / (1000 * 60);
        if (minPast < (timeSpan * 60) && minPast > -1) {
            itemEl = doc.createElement("now_pointer");
            itemEl.setAttribute("min", new Integer((int) minPast).toString());
            root.appendChild(itemEl);
        }
        int hour = startHour;
        String xm = "am";
        if (hour > 12) hour = startHour - 12;
        if (startHour >= 12) xm = "pm";
        if (hour == 0) hour = 12;
        int min = 0;
        int totalCols = timeSpan * 2;
        for (int x = 0; x < totalCols; x++) {
            itemEl = doc.createElement("time");
            text = doc.createTextNode(hour + ":" + intToStr(min) + xm);
            itemEl.appendChild(text);
            root.appendChild(itemEl);
            min += 30;
            if (min == 60) {
                hour += 1;
                min = 0;
            }
            if (hour == 12 && min == 0) {
                if (xm.equals("am")) xm = "pm"; else xm = "am";
            }
            if (hour == 13) {
                hour = 1;
            }
        }
        GuideStore epgStore = GuideStore.getInstance();
        Vector<String[]> channelMap = epgStore.getChannelMap();
        for (int x = 0; x < channelMap.size(); x++) {
            String[] map = (String[]) channelMap.get(x);
            Element channel = doc.createElement("channel");
            channel.setAttribute("id", map[0]);
            Element disName = doc.createElement("display-name");
            Text chaName = doc.createTextNode(map[0]);
            disName.appendChild(chaName);
            channel.appendChild(disName);
            root.appendChild(channel);
        }
        Calendar start = Calendar.getInstance();
        start.set(Calendar.YEAR, year);
        start.set(Calendar.MONTH, month - 1);
        start.set(Calendar.DATE, day);
        start.set(Calendar.HOUR_OF_DAY, startHour);
        start.set(Calendar.MINUTE, 0);
        start.set(Calendar.SECOND, 0);
        start.add(Calendar.SECOND, -1);
        start.set(Calendar.MILLISECOND, 0);
        Calendar end = Calendar.getInstance();
        end.setTime(start.getTime());
        end.add(Calendar.HOUR_OF_DAY, timeSpan);
        Calendar startTime = Calendar.getInstance();
        startTime.set(Calendar.MILLISECOND, 0);
        start.add(Calendar.HOUR_OF_DAY, (-1 * (timeSpan - 1)));
        String prevLink = "/servlet/" + urlData.getServletClass() + "?action=01&" + "year=" + start.get(Calendar.YEAR) + "&" + "month=" + (start.get(Calendar.MONTH) + 1) + "&" + "day=" + start.get(Calendar.DATE) + "&" + "start=" + start.get(Calendar.HOUR_OF_DAY) + "&" + "span=" + timeSpan;
        start.add(Calendar.HOUR_OF_DAY, (timeSpan - 1));
        root.setAttribute("title", store.dayName.get(new Integer(start.get(Calendar.DAY_OF_WEEK))) + " (" + start.get(Calendar.DATE) + "/" + (start.get(Calendar.MONTH) + 1) + "/" + start.get(Calendar.YEAR) + ")");
        start.add(Calendar.HOUR_OF_DAY, (timeSpan + 1));
        String nextLink = "/servlet/" + urlData.getServletClass() + "?action=01&" + "year=" + start.get(Calendar.YEAR) + "&" + "month=" + (start.get(Calendar.MONTH) + 1) + "&" + "day=" + start.get(Calendar.DATE) + "&" + "start=" + start.get(Calendar.HOUR_OF_DAY) + "&" + "span=" + timeSpan;
        start.add(Calendar.HOUR_OF_DAY, (-1 * (timeSpan + 1)));
        itemEl = doc.createElement("navigation");
        elm = doc.createElement("next");
        text = doc.createTextNode(nextLink);
        elm.appendChild(text);
        itemEl.appendChild(elm);
        elm = doc.createElement("previous");
        text = doc.createTextNode(prevLink);
        elm.appendChild(text);
        itemEl.appendChild(elm);
        elm = doc.createElement("selected");
        text = doc.createTextNode(selected);
        elm.appendChild(text);
        itemEl.appendChild(elm);
        root.appendChild(itemEl);
        HashMap<String, Vector<ScheduleItem>> schedulesLeftOver = new HashMap<String, Vector<ScheduleItem>>();
        Set<String> wsChannels = store.getChannels().keySet();
        boolean channelMapped = true;
        for (int x = 0; x < channelMap.size(); x++) {
            String[] map = (String[]) channelMap.get(x);
            String channelName = map[0];
            if (channelName == null || !wsChannels.contains(map[0])) {
                channelName = "Not Mapped";
                channelMapped = false;
            } else {
                channelMapped = true;
                GuideItem[] programs = epgStore.getProgramsInc(start.getTime(), end.getTime(), map[1]);
                Vector<ScheduleItem> schItems = new Vector<ScheduleItem>();
                store.getSchedulesWhenInc(start.getTime(), end.getTime(), channelName, schItems);
                int colCount = 0;
                for (int y = 0; y < programs.length; y++) {
                    GuideItem item = programs[y];
                    start.add(Calendar.SECOND, 1);
                    startTime.setTime(item.getStart());
                    long pastStart = startTime.getTime().getTime() - start.getTime().getTime();
                    if (y == 0 && pastStart > 0) {
                        Element program_PH = doc.createElement("programme");
                        program_PH.setAttribute("start", df.format(start.getTime()));
                        program_PH.setAttribute("stop", df.format(item.getStart()));
                        program_PH.setAttribute("channel", channelName);
                        Element titleElement = doc.createElement("title");
                        Text titleText = doc.createTextNode("EMPTY");
                        titleElement.appendChild(titleText);
                        program_PH.appendChild(titleElement);
                        Element subTitleElement = doc.createElement("sub-title");
                        Text subTitleText = doc.createTextNode("empty");
                        subTitleElement.appendChild(subTitleText);
                        program_PH.appendChild(subTitleElement);
                        Element descElement = doc.createElement("desc");
                        Text descText = doc.createTextNode("empty");
                        descElement.appendChild(descText);
                        program_PH.appendChild(descElement);
                        Element lengthElement = doc.createElement("length");
                        lengthElement.setAttribute("units", "minutes");
                        Text lengthText = doc.createTextNode(new Long(pastStart / (1000 * 60)).toString());
                        lengthElement.appendChild(lengthText);
                        program_PH.appendChild(lengthElement);
                        Element programLengthElement = doc.createElement("programLength");
                        programLengthElement.setAttribute("units", "minutes");
                        Text programLengthText = doc.createTextNode(new Long(pastStart / (1000 * 60)).toString());
                        programLengthElement.appendChild(programLengthText);
                        program_PH.appendChild(programLengthElement);
                        root.appendChild(program_PH);
                        colCount += (int) (pastStart / (1000 * 60));
                    }
                    start.add(Calendar.SECOND, -1);
                    if (y > 0) {
                        long skip = item.getStart().getTime() - (programs[y - 1].getStart().getTime() + (programs[y - 1].getDuration() * 1000 * 60));
                        if (skip > 0) {
                            System.out.println("Skipping : " + skip);
                            Element program_PH = doc.createElement("programme");
                            program_PH.setAttribute("start", df.format(programs[y - 1].getStop()));
                            program_PH.setAttribute("stop", df.format(item.getStart()));
                            program_PH.setAttribute("channel", channelName);
                            Element titleElement = doc.createElement("title");
                            Text titleText = doc.createTextNode("EMPTY");
                            titleElement.appendChild(titleText);
                            program_PH.appendChild(titleElement);
                            Element subTitleElement = doc.createElement("sub-title");
                            Text subTitleText = doc.createTextNode("empty");
                            subTitleElement.appendChild(subTitleText);
                            program_PH.appendChild(subTitleElement);
                            Element descElement = doc.createElement("desc");
                            Text descText = doc.createTextNode("empty");
                            descElement.appendChild(descText);
                            program_PH.appendChild(descElement);
                            Element lengthElement = doc.createElement("length");
                            lengthElement.setAttribute("units", "minutes");
                            Text lengthText = doc.createTextNode(new Long(skip / (1000 * 60)).toString());
                            lengthElement.appendChild(lengthText);
                            program_PH.appendChild(lengthElement);
                            Element programLengthElement = doc.createElement("programLength");
                            programLengthElement.setAttribute("units", "minutes");
                            Text programLengthText = doc.createTextNode(new Long(skip / (1000 * 60)).toString());
                            programLengthElement.appendChild(programLengthText);
                            program_PH.appendChild(programLengthElement);
                            root.appendChild(program_PH);
                            colCount += (int) (skip / (1000 * 60));
                        }
                    }
                    ScheduleItem programSchedule = null;
                    for (int schIndex = 0; schIndex < schItems.size(); schIndex++) {
                        ScheduleItem sch = schItems.get(schIndex);
                        GuideItem createdFrom = sch.getCreatedFrom();
                        if (createdFrom != null) {
                            if (createdFrom.matches(item)) {
                                schItems.remove(schIndex);
                                programSchedule = sch;
                                break;
                            }
                        }
                    }
                    Element program = doc.createElement("programme");
                    program.setAttribute("start", df.format(item.getStart()));
                    program.setAttribute("stop", df.format(item.getStop()));
                    program.setAttribute("channel", channelName);
                    Element titleElement = doc.createElement("title");
                    Text titleText = doc.createTextNode(removeChars(item.getName()));
                    titleElement.appendChild(titleText);
                    program.appendChild(titleElement);
                    Element subTitleElement = doc.createElement("sub-title");
                    Text subTitleText = doc.createTextNode(removeChars(item.getSubName()));
                    subTitleElement.appendChild(subTitleText);
                    program.appendChild(subTitleElement);
                    for (int index = 0; index < item.getCategory().size(); index++) {
                        Element catElement = doc.createElement("category");
                        Text catText = doc.createTextNode(item.getCategory().get(index));
                        catElement.appendChild(catText);
                        program.appendChild(catElement);
                    }
                    Element descElement = doc.createElement("desc");
                    Text descText = doc.createTextNode(removeChars(item.getDescription()));
                    descElement.appendChild(descText);
                    program.appendChild(descElement);
                    int fits = 0;
                    int colSpan = item.getDuration();
                    if (item.getStart().getTime() < start.getTime().getTime() && item.getStop().getTime() > end.getTime().getTime()) {
                        fits = 1;
                        colSpan = (timeSpan * 60);
                    } else if (y == 0 && start.getTime().getTime() > item.getStart().getTime()) {
                        fits = 2;
                        colSpan -= ((start.getTime().getTime() - item.getStart().getTime()) / (1000 * 60)) + 1;
                    } else if (y == programs.length - 1 && (item.getStop().getTime() - 5000) > end.getTime().getTime()) {
                        fits = 3;
                        colSpan = (timeSpan * 60) - colCount;
                    }
                    colCount += colSpan;
                    Element lengthElement = doc.createElement("length");
                    lengthElement.setAttribute("units", "minutes");
                    lengthElement.setAttribute("fits", new Integer(fits).toString());
                    Text lengthText = doc.createTextNode(new Integer(colSpan).toString());
                    lengthElement.appendChild(lengthText);
                    program.appendChild(lengthElement);
                    Element programLengthElement = doc.createElement("programLength");
                    programLengthElement.setAttribute("units", "minutes");
                    Text programLengthText = doc.createTextNode(new Long(item.getDuration()).toString());
                    programLengthElement.appendChild(programLengthText);
                    program.appendChild(programLengthElement);
                    String addLink = "";
                    if (channelMapped) {
                        addLink = "/servlet/KBScheduleDataRes?action=11" + "&channel=" + URLEncoder.encode(map[0], "UTF-8") + "&id=" + item.toString();
                    }
                    Element infoUrlElement = doc.createElement("progAdd");
                    Text infoUrlText = doc.createTextNode(addLink);
                    infoUrlElement.appendChild(infoUrlText);
                    program.appendChild(infoUrlElement);
                    String detailsLink = "";
                    if (channelMapped) {
                        detailsLink = "/servlet/KBEpgDataRes?action=05&" + "channel=" + URLEncoder.encode(map[0], "UTF-8") + "&id=" + URLEncoder.encode(item.toString(), "UTF-8");
                    }
                    Element detailsUrlElement = doc.createElement("showDetails");
                    Text detailsUrlText = doc.createTextNode(detailsLink);
                    detailsUrlElement.appendChild(detailsUrlText);
                    program.appendChild(detailsUrlElement);
                    Element fullTimes = doc.createElement("full_times");
                    fullTimes.setAttribute("start", df2.format(item.getStart()));
                    fullTimes.setAttribute("stop", df2.format(item.getStop()));
                    program.appendChild(fullTimes);
                    Element schElement = doc.createElement("scheduled");
                    if (programSchedule == null) {
                        schElement.setAttribute("state", "-1");
                    } else {
                        schElement.setAttribute("state", new Integer(programSchedule.getState()).toString());
                        Element schElementStart = doc.createElement("start");
                        Text schTextStart = doc.createTextNode(df.format(programSchedule.getStart()));
                        schElementStart.appendChild(schTextStart);
                        schElement.appendChild(schElementStart);
                        Element schElementStop = doc.createElement("stop");
                        Text schTextStop = doc.createTextNode(df.format(programSchedule.getStop()));
                        schElementStop.appendChild(schTextStop);
                        schElement.appendChild(schElementStop);
                    }
                    program.appendChild(schElement);
                    root.appendChild(program);
                }
                Vector<ScheduleItem> remainingItems = schedulesLeftOver.get(channelName);
                if (remainingItems == null) {
                    remainingItems = new Vector<ScheduleItem>();
                    schedulesLeftOver.put(channelName, remainingItems);
                }
                for (int schIndex = 0; schIndex < schItems.size(); schIndex++) {
                    ScheduleItem sch = schItems.get(schIndex);
                    remainingItems.add(sch);
                }
            }
        }
        Text textNode = null;
        Element elementNaode = null;
        for (int x = 0; x < channelMap.size(); x++) {
            String[] map = (String[]) channelMap.get(x);
            int padding = 0;
            int loops = 0;
            String chanName = map[0];
            if (chanName != null) {
                Vector<ScheduleItem> items = schedulesLeftOver.get(chanName);
                ScheduleItem[] schedules = (ScheduleItem[]) items.toArray(new ScheduleItem[0]);
                while (schedules.length > 0) {
                    Vector<ScheduleItem> overlap = new Vector<ScheduleItem>();
                    int colCount = 0;
                    for (int sch = 0; sch < schedules.length; sch++) {
                        ScheduleItem item = schedules[sch];
                        startTime.setTime(item.getStart());
                        startTime.set(Calendar.MILLISECOND, 0);
                        if (showUnlinked == false && item.getCreatedFrom() != null) {
                        } else if (sch > 0 && ((item.getStart().getTime() < schedules[sch - 1].getStop().getTime() && item.getStart().getTime() > schedules[sch - 1].getStart().getTime()) || (item.getStop().getTime() > schedules[sch - 1].getStart().getTime() && item.getStart().getTime() < schedules[sch - 1].getStop().getTime()))) {
                            overlap.add(item);
                        } else {
                            padding = 0;
                            startTime.setTime(item.getStart());
                            long pastStart = startTime.getTime().getTime() - start.getTime().getTime();
                            if (sch == 0 && pastStart > 0) {
                                padding = (int) (pastStart / (1000 * 60));
                                colCount += (int) (pastStart / (1000 * 60));
                            }
                            start.add(Calendar.SECOND, -1);
                            if (sch > 0) {
                                long skip = item.getStart().getTime() - (schedules[sch - 1].getStart().getTime() + (schedules[sch - 1].getDuration() * 1000 * 60));
                                if (skip > 0) {
                                    System.out.println("Skipping : " + skip);
                                    padding = ((int) (pastStart / (1000 * 60))) - colCount;
                                    colCount += (int) (skip / (1000 * 60));
                                }
                            }
                            int fits = 0;
                            int colSpan = item.getDuration();
                            if (item.getStart().getTime() < start.getTime().getTime() && item.getStop().getTime() > end.getTime().getTime()) {
                                colSpan = (timeSpan * 60);
                                fits = 1;
                            } else if (sch == 0 && start.getTime().getTime() > item.getStart().getTime()) {
                                colSpan -= ((start.getTime().getTime() - item.getStart().getTime()) / (1000 * 60)) + 1;
                                fits = 2;
                            } else if (item.getStop().getTime() > end.getTime().getTime()) {
                                long temp = end.getTime().getTime() - item.getStart().getTime();
                                temp = temp / (1000 * 60);
                                colSpan = (int) temp + 1;
                                fits = 3;
                            }
                            colCount += colSpan;
                            Element schedule = doc.createElement("schedule");
                            schedule.setAttribute("start", df.format(item.getStart()));
                            schedule.setAttribute("stop", df.format(item.getStop()));
                            schedule.setAttribute("duration", new Integer(item.getDuration()).toString());
                            schedule.setAttribute("span", new Integer(colSpan).toString());
                            schedule.setAttribute("prePadding", new Integer(padding).toString());
                            schedule.setAttribute("overlapCount", new Integer(loops).toString());
                            schedule.setAttribute("channel", chanName);
                            schedule.setAttribute("fits", new Integer(fits).toString());
                            elementNaode = doc.createElement("id");
                            textNode = doc.createTextNode(item.toString());
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            elementNaode = doc.createElement("title");
                            textNode = doc.createTextNode(removeChars(item.getName()));
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            elementNaode = doc.createElement("itemState");
                            textNode = doc.createTextNode(new Integer(item.getState()).toString());
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            elementNaode = doc.createElement("itemStatus");
                            textNode = doc.createTextNode(item.getStatus());
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            String action = "/servlet/KBScheduleDataRes?action=04&id=" + item.toString();
                            elementNaode = doc.createElement("progEdit");
                            textNode = doc.createTextNode(action);
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            root.appendChild(schedule);
                        }
                    }
                    schedules = (ScheduleItem[]) overlap.toArray(new ScheduleItem[0]);
                    loops++;
                }
            }
        }
        XSL transformer = new XSL(doc, "kb-epg.xsl", urlData, headers);
        String request = urlData.getReqString();
        int indexOf = request.indexOf("&selected=");
        if (indexOf > -1) {
            request = request.substring(0, indexOf);
        }
        transformer.addCookie("backURL", request);
        return transformer.doTransform();
    }
----------------------------------------
    private byte[] showEPG(HTTPurl urlData, HashMap headers) throws Exception {
        Calendar now = Calendar.getInstance();
        now.set(Calendar.SECOND, 0);
        now.set(Calendar.MILLISECOND, 0);
        int year = -1;
        try {
            year = Integer.parseInt(urlData.getParameter("year"));
        } catch (Exception e) {
        }
        if (year == -1) year = now.get(Calendar.YEAR);
        int month = -1;
        try {
            month = Integer.parseInt(urlData.getParameter("month"));
        } catch (Exception e) {
        }
        if (month == -1) month = now.get(Calendar.MONTH) + 1;
        int day = -1;
        try {
            day = Integer.parseInt(urlData.getParameter("day"));
        } catch (Exception e) {
        }
        if (day == -1) day = now.get(Calendar.DATE);
        int startHour = -1;
        try {
            startHour = Integer.parseInt(urlData.getParameter("start"));
        } catch (Exception e) {
        }
        if (startHour == -1) startHour = now.get(Calendar.HOUR_OF_DAY);
        int timeSpan = 3;
        try {
            timeSpan = Integer.parseInt(urlData.getParameter("span"));
        } catch (Exception e) {
        }
        String selected = urlData.getParameter("selected");
        if (selected == null || selected.length() == 0) selected = "";
        SimpleDateFormat df = new SimpleDateFormat("h:mma");
        SimpleDateFormat df2 = new SimpleDateFormat("yyyyMMddHHmmss Z");
        boolean showUnlinked = store.getProperty("EPG.ShowUnlinked").equals("1");
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        DOMImplementation di = db.getDOMImplementation();
        Document doc = di.createDocument("", "epg", null);
        Element root = doc.getDocumentElement();
        root.setAttribute("year", new Integer(year).toString());
        root.setAttribute("month", new Integer(month).toString());
        root.setAttribute("day", new Integer(day).toString());
        root.setAttribute("start", new Integer(startHour).toString());
        root.setAttribute("show", new Integer(timeSpan).toString());
        Element itemEl = null;
        Element elm = null;
        Text text = null;
        Calendar startPointer = Calendar.getInstance();
        startPointer.set(Calendar.SECOND, 0);
        startPointer.set(Calendar.MINUTE, 0);
        startPointer.set(Calendar.MILLISECOND, 0);
        startPointer.set(Calendar.YEAR, year);
        startPointer.set(Calendar.MONTH, month - 1);
        startPointer.set(Calendar.DATE, day);
        startPointer.set(Calendar.HOUR_OF_DAY, startHour);
        long nowLong = new Date().getTime();
        long startLong = startPointer.getTime().getTime();
        long minPast = (nowLong - startLong) / (1000 * 60);
        if (minPast < (timeSpan * 60) && minPast > -1) {
            itemEl = doc.createElement("now_pointer");
            itemEl.setAttribute("min", new Integer((int) minPast).toString());
            root.appendChild(itemEl);
        }
        int hour = startHour;
        String xm = "am";
        if (hour > 12) hour = startHour - 12;
        if (startHour >= 12) xm = "pm";
        if (hour == 0) hour = 12;
        int min = 0;
        int totalCols = timeSpan * 2;
        for (int x = 0; x < totalCols; x++) {
            itemEl = doc.createElement("time");
            text = doc.createTextNode(hour + ":" + intToStr(min) + xm);
            itemEl.appendChild(text);
            root.appendChild(itemEl);
            min += 30;
            if (min == 60) {
                hour += 1;
                min = 0;
            }
            if (hour == 12 && min == 0) {
                if (xm.equals("am")) xm = "pm"; else xm = "am";
            }
            if (hour == 13) {
                hour = 1;
            }
        }
        GuideStore epgStore = GuideStore.getInstance();
        Vector channelMap = epgStore.getChannelMap();
        for (int x = 0; x < channelMap.size(); x++) {
            String[] map = (String[]) channelMap.get(x);
            Element channel = doc.createElement("channel");
            channel.setAttribute("id", map[0]);
            Element disName = doc.createElement("display-name");
            Text chaName = doc.createTextNode(map[0]);
            disName.appendChild(chaName);
            channel.appendChild(disName);
            root.appendChild(channel);
        }
        Calendar start = Calendar.getInstance();
        start.set(Calendar.YEAR, year);
        start.set(Calendar.MONTH, month - 1);
        start.set(Calendar.DATE, day);
        start.set(Calendar.HOUR_OF_DAY, startHour);
        start.set(Calendar.MINUTE, 0);
        start.set(Calendar.SECOND, 0);
        start.add(Calendar.SECOND, -1);
        start.set(Calendar.MILLISECOND, 0);
        Calendar end = Calendar.getInstance();
        end.setTime(start.getTime());
        end.add(Calendar.HOUR_OF_DAY, timeSpan);
        Calendar startTime = Calendar.getInstance();
        startTime.set(Calendar.MILLISECOND, 0);
        start.add(Calendar.HOUR_OF_DAY, (-1 * (timeSpan - 1)));
        String prevLink = "/servlet/" + urlData.getServletClass() + "?action=01&" + "year=" + start.get(Calendar.YEAR) + "&" + "month=" + (start.get(Calendar.MONTH) + 1) + "&" + "day=" + start.get(Calendar.DATE) + "&" + "start=" + start.get(Calendar.HOUR_OF_DAY) + "&" + "span=" + timeSpan;
        start.add(Calendar.HOUR_OF_DAY, (timeSpan - 1));
        root.setAttribute("title", store.dayName.get(new Integer(start.get(Calendar.DAY_OF_WEEK))) + " (" + start.get(Calendar.DATE) + "/" + (start.get(Calendar.MONTH) + 1) + "/" + start.get(Calendar.YEAR) + ")");
        start.add(Calendar.HOUR_OF_DAY, (timeSpan + 1));
        String nextLink = "/servlet/" + urlData.getServletClass() + "?action=01&" + "year=" + start.get(Calendar.YEAR) + "&" + "month=" + (start.get(Calendar.MONTH) + 1) + "&" + "day=" + start.get(Calendar.DATE) + "&" + "start=" + start.get(Calendar.HOUR_OF_DAY) + "&" + "span=" + timeSpan;
        start.add(Calendar.HOUR_OF_DAY, (-1 * (timeSpan + 1)));
        itemEl = doc.createElement("navigation");
        elm = doc.createElement("next");
        text = doc.createTextNode(nextLink);
        elm.appendChild(text);
        itemEl.appendChild(elm);
        elm = doc.createElement("previous");
        text = doc.createTextNode(prevLink);
        elm.appendChild(text);
        itemEl.appendChild(elm);
        elm = doc.createElement("selected");
        text = doc.createTextNode(selected);
        elm.appendChild(text);
        itemEl.appendChild(elm);
        root.appendChild(itemEl);
        HashMap<String, Vector<ScheduleItem>> schedulesLeftOver = new HashMap<String, Vector<ScheduleItem>>();
        Set wsChannels = store.getChannels().keySet();
        boolean channelMapped = true;
        for (int x = 0; x < channelMap.size(); x++) {
            String[] map = (String[]) channelMap.get(x);
            String channelName = map[0];
            if (channelName == null || !wsChannels.contains(map[0])) {
                channelName = "Not Mapped";
                channelMapped = false;
            } else {
                channelMapped = true;
                GuideItem[] programs = epgStore.getProgramsInc(start.getTime(), end.getTime(), map[1]);
                Vector<ScheduleItem> schItems = new Vector<ScheduleItem>();
                store.getSchedulesWhenInc(start.getTime(), end.getTime(), channelName, schItems);
                int colCount = 0;
                for (int y = 0; y < programs.length; y++) {
                    GuideItem item = programs[y];
                    start.add(Calendar.SECOND, 1);
                    startTime.setTime(item.getStart());
                    long pastStart = startTime.getTime().getTime() - start.getTime().getTime();
                    if (y == 0 && pastStart > 0) {
                        Element program_PH = doc.createElement("programme");
                        program_PH.setAttribute("start", df.format(start.getTime()));
                        program_PH.setAttribute("stop", df.format(item.getStart()));
                        program_PH.setAttribute("channel", channelName);
                        Element titleElement = doc.createElement("title");
                        Text titleText = doc.createTextNode("EMPTY");
                        titleElement.appendChild(titleText);
                        program_PH.appendChild(titleElement);
                        Element subTitleElement = doc.createElement("sub-title");
                        Text subTitleText = doc.createTextNode("empty");
                        subTitleElement.appendChild(subTitleText);
                        program_PH.appendChild(subTitleElement);
                        Element descElement = doc.createElement("desc");
                        Text descText = doc.createTextNode("empty");
                        descElement.appendChild(descText);
                        program_PH.appendChild(descElement);
                        Element lengthElement = doc.createElement("length");
                        lengthElement.setAttribute("units", "minutes");
                        Text lengthText = doc.createTextNode(new Long(pastStart / (1000 * 60)).toString());
                        lengthElement.appendChild(lengthText);
                        program_PH.appendChild(lengthElement);
                        Element programLengthElement = doc.createElement("programLength");
                        programLengthElement.setAttribute("units", "minutes");
                        Text programLengthText = doc.createTextNode(new Long(pastStart / (1000 * 60)).toString());
                        programLengthElement.appendChild(programLengthText);
                        program_PH.appendChild(programLengthElement);
                        root.appendChild(program_PH);
                        colCount += (int) (pastStart / (1000 * 60));
                    }
                    start.add(Calendar.SECOND, -1);
                    if (y > 0) {
                        long skip = item.getStart().getTime() - (programs[y - 1].getStart().getTime() + (programs[y - 1].getDuration() * 1000 * 60));
                        if (skip > 0) {
                            System.out.println("Skipping : " + skip);
                            Element program_PH = doc.createElement("programme");
                            program_PH.setAttribute("start", df.format(programs[y - 1].getStop()));
                            program_PH.setAttribute("stop", df.format(item.getStart()));
                            program_PH.setAttribute("channel", channelName);
                            Element titleElement = doc.createElement("title");
                            Text titleText = doc.createTextNode("EMPTY");
                            titleElement.appendChild(titleText);
                            program_PH.appendChild(titleElement);
                            Element subTitleElement = doc.createElement("sub-title");
                            Text subTitleText = doc.createTextNode("empty");
                            subTitleElement.appendChild(subTitleText);
                            program_PH.appendChild(subTitleElement);
                            Element descElement = doc.createElement("desc");
                            Text descText = doc.createTextNode("empty");
                            descElement.appendChild(descText);
                            program_PH.appendChild(descElement);
                            Element lengthElement = doc.createElement("length");
                            lengthElement.setAttribute("units", "minutes");
                            Text lengthText = doc.createTextNode(new Long(skip / (1000 * 60)).toString());
                            lengthElement.appendChild(lengthText);
                            program_PH.appendChild(lengthElement);
                            Element programLengthElement = doc.createElement("programLength");
                            programLengthElement.setAttribute("units", "minutes");
                            Text programLengthText = doc.createTextNode(new Long(skip / (1000 * 60)).toString());
                            programLengthElement.appendChild(programLengthText);
                            program_PH.appendChild(programLengthElement);
                            root.appendChild(program_PH);
                            colCount += (int) (skip / (1000 * 60));
                        }
                    }
                    ScheduleItem programSchedule = null;
                    for (int schIndex = 0; schIndex < schItems.size(); schIndex++) {
                        ScheduleItem sch = schItems.get(schIndex);
                        GuideItem createdFrom = sch.getCreatedFrom();
                        if (createdFrom != null) {
                            if (createdFrom.matches(item)) {
                                schItems.remove(schIndex);
                                programSchedule = sch;
                                break;
                            }
                        }
                    }
                    Element program = doc.createElement("programme");
                    program.setAttribute("start", df.format(item.getStart()));
                    program.setAttribute("stop", df.format(item.getStop()));
                    program.setAttribute("channel", channelName);
                    Element titleElement = doc.createElement("title");
                    Text titleText = doc.createTextNode(removeChars(item.getName()));
                    titleElement.appendChild(titleText);
                    program.appendChild(titleElement);
                    Element subTitleElement = doc.createElement("sub-title");
                    Text subTitleText = doc.createTextNode(removeChars(item.getSubName()));
                    subTitleElement.appendChild(subTitleText);
                    program.appendChild(subTitleElement);
                    for (int index = 0; index < item.getCategory().size(); index++) {
                        Element catElement = doc.createElement("category");
                        Text catText = doc.createTextNode(item.getCategory().get(index));
                        catElement.appendChild(catText);
                        program.appendChild(catElement);
                    }
                    Element descElement = doc.createElement("desc");
                    Text descText = doc.createTextNode(removeChars(item.getDescription()));
                    descElement.appendChild(descText);
                    program.appendChild(descElement);
                    int fits = 0;
                    int colSpan = item.getDuration();
                    if (item.getStart().getTime() < start.getTime().getTime() && item.getStop().getTime() > end.getTime().getTime()) {
                        fits = 1;
                        colSpan = (timeSpan * 60);
                    } else if (y == 0 && start.getTime().getTime() > item.getStart().getTime()) {
                        fits = 2;
                        colSpan -= ((start.getTime().getTime() - item.getStart().getTime()) / (1000 * 60)) + 1;
                    } else if (y == programs.length - 1 && (item.getStop().getTime() - 5000) > end.getTime().getTime()) {
                        fits = 3;
                        colSpan = (timeSpan * 60) - colCount;
                    }
                    colCount += colSpan;
                    Element lengthElement = doc.createElement("length");
                    lengthElement.setAttribute("units", "minutes");
                    lengthElement.setAttribute("fits", new Integer(fits).toString());
                    Text lengthText = doc.createTextNode(new Integer(colSpan).toString());
                    lengthElement.appendChild(lengthText);
                    program.appendChild(lengthElement);
                    Element programLengthElement = doc.createElement("programLength");
                    programLengthElement.setAttribute("units", "minutes");
                    Text programLengthText = doc.createTextNode(new Long(item.getDuration()).toString());
                    programLengthElement.appendChild(programLengthText);
                    program.appendChild(programLengthElement);
                    String addLink = "";
                    if (channelMapped) {
                        addLink = "/servlet/KBScheduleDataRes?action=11" + "&channel=" + URLEncoder.encode(map[0], "UTF-8") + "&id=" + item.toString();
                    }
                    Element infoUrlElement = doc.createElement("progAdd");
                    Text infoUrlText = doc.createTextNode(addLink);
                    infoUrlElement.appendChild(infoUrlText);
                    program.appendChild(infoUrlElement);
                    String detailsLink = "";
                    if (channelMapped) {
                        detailsLink = "/servlet/KBEpgDataRes?action=05&" + "channel=" + URLEncoder.encode(map[0], "UTF-8") + "&id=" + URLEncoder.encode(item.toString(), "UTF-8");
                    }
                    Element detailsUrlElement = doc.createElement("showDetails");
                    Text detailsUrlText = doc.createTextNode(detailsLink);
                    detailsUrlElement.appendChild(detailsUrlText);
                    program.appendChild(detailsUrlElement);
                    Element fullTimes = doc.createElement("full_times");
                    fullTimes.setAttribute("start", df2.format(item.getStart()));
                    fullTimes.setAttribute("stop", df2.format(item.getStop()));
                    program.appendChild(fullTimes);
                    Element schElement = doc.createElement("scheduled");
                    if (programSchedule == null) {
                        schElement.setAttribute("state", "-1");
                    } else {
                        schElement.setAttribute("state", new Integer(programSchedule.getState()).toString());
                        Element schElementStart = doc.createElement("start");
                        Text schTextStart = doc.createTextNode(df.format(programSchedule.getStart()));
                        schElementStart.appendChild(schTextStart);
                        schElement.appendChild(schElementStart);
                        Element schElementStop = doc.createElement("stop");
                        Text schTextStop = doc.createTextNode(df.format(programSchedule.getStop()));
                        schElementStop.appendChild(schTextStop);
                        schElement.appendChild(schElementStop);
                    }
                    program.appendChild(schElement);
                    root.appendChild(program);
                }
                Vector<ScheduleItem> remainingItems = schedulesLeftOver.get(channelName);
                if (remainingItems == null) {
                    remainingItems = new Vector<ScheduleItem>();
                    schedulesLeftOver.put(channelName, remainingItems);
                }
                for (int schIndex = 0; schIndex < schItems.size(); schIndex++) {
                    ScheduleItem sch = schItems.get(schIndex);
                    remainingItems.add(sch);
                }
            }
        }
        Text textNode = null;
        Element elementNaode = null;
        for (int x = 0; x < channelMap.size(); x++) {
            String[] map = (String[]) channelMap.get(x);
            int padding = 0;
            int loops = 0;
            String chanName = map[0];
            if (chanName != null) {
                Vector<ScheduleItem> items = schedulesLeftOver.get(chanName);
                ScheduleItem[] schedules = (ScheduleItem[]) items.toArray(new ScheduleItem[0]);
                while (schedules.length > 0) {
                    Vector<ScheduleItem> overlap = new Vector<ScheduleItem>();
                    int colCount = 0;
                    for (int sch = 0; sch < schedules.length; sch++) {
                        ScheduleItem item = schedules[sch];
                        startTime.setTime(item.getStart());
                        startTime.set(Calendar.MILLISECOND, 0);
                        if (showUnlinked == false && item.getCreatedFrom() != null) {
                        } else if (sch > 0 && ((item.getStart().getTime() < schedules[sch - 1].getStop().getTime() && item.getStart().getTime() > schedules[sch - 1].getStart().getTime()) || (item.getStop().getTime() > schedules[sch - 1].getStart().getTime() && item.getStart().getTime() < schedules[sch - 1].getStop().getTime()))) {
                            overlap.add(item);
                        } else {
                            padding = 0;
                            startTime.setTime(item.getStart());
                            long pastStart = startTime.getTime().getTime() - start.getTime().getTime();
                            if (sch == 0 && pastStart > 0) {
                                padding = (int) (pastStart / (1000 * 60));
                                colCount += (int) (pastStart / (1000 * 60));
                            }
                            start.add(Calendar.SECOND, -1);
                            if (sch > 0) {
                                long skip = item.getStart().getTime() - (schedules[sch - 1].getStart().getTime() + (schedules[sch - 1].getDuration() * 1000 * 60));
                                if (skip > 0) {
                                    System.out.println("Skipping : " + skip);
                                    padding = ((int) (pastStart / (1000 * 60))) - colCount;
                                    colCount += (int) (skip / (1000 * 60));
                                }
                            }
                            int fits = 0;
                            int colSpan = item.getDuration();
                            if (item.getStart().getTime() < start.getTime().getTime() && item.getStop().getTime() > end.getTime().getTime()) {
                                colSpan = (timeSpan * 60);
                                fits = 1;
                            } else if (sch == 0 && start.getTime().getTime() > item.getStart().getTime()) {
                                colSpan -= ((start.getTime().getTime() - item.getStart().getTime()) / (1000 * 60)) + 1;
                                fits = 2;
                            } else if (item.getStop().getTime() > end.getTime().getTime()) {
                                long temp = end.getTime().getTime() - item.getStart().getTime();
                                temp = temp / (1000 * 60);
                                colSpan = (int) temp + 1;
                                fits = 3;
                            }
                            colCount += colSpan;
                            Element schedule = doc.createElement("schedule");
                            schedule.setAttribute("start", df.format(item.getStart()));
                            schedule.setAttribute("stop", df.format(item.getStop()));
                            schedule.setAttribute("duration", new Integer(item.getDuration()).toString());
                            schedule.setAttribute("span", new Integer(colSpan).toString());
                            schedule.setAttribute("prePadding", new Integer(padding).toString());
                            schedule.setAttribute("overlapCount", new Integer(loops).toString());
                            schedule.setAttribute("channel", chanName);
                            schedule.setAttribute("fits", new Integer(fits).toString());
                            elementNaode = doc.createElement("id");
                            textNode = doc.createTextNode(item.toString());
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            elementNaode = doc.createElement("title");
                            textNode = doc.createTextNode(removeChars(item.getName()));
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            elementNaode = doc.createElement("itemState");
                            textNode = doc.createTextNode(new Integer(item.getState()).toString());
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            elementNaode = doc.createElement("itemStatus");
                            textNode = doc.createTextNode(item.getStatus());
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            String action = "/servlet/KBScheduleDataRes?action=04&id=" + item.toString();
                            elementNaode = doc.createElement("progEdit");
                            textNode = doc.createTextNode(action);
                            elementNaode.appendChild(textNode);
                            schedule.appendChild(elementNaode);
                            root.appendChild(schedule);
                        }
                    }
                    schedules = (ScheduleItem[]) overlap.toArray(new ScheduleItem[0]);
                    loops++;
                }
            }
        }
        XSL transformer = new XSL(doc, "kb-epg.xsl", urlData, headers);
        String request = urlData.getReqString();
        int indexOf = request.indexOf("&selected=");
        if (indexOf > -1) {
            request = request.substring(0, indexOf);
        }
        transformer.addCookie("backURL", request);
        return transformer.doTransform();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28121.java,315,466
default,94873.java,391,568
----------------------------------------
    private void exportAllSettings(HTTPurl urlData, OutputStream outStream) throws Exception {
        CaptureDeviceList devList = CaptureDeviceList.getInstance();
        if (devList.getActiveDeviceCount() > 0) {
            PageTemplate template = new PageTemplate(store.getProperty("path.template").replace('\\', File.separatorChar) + File.separator + "SettingsLoad.html");
            StringBuffer buff = new StringBuffer();
            buff.append("<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>");
            template.replaceAll("$result", buff.toString());
            outStream.write(template.getPageBytes());
            return;
        }
        boolean matchList = "true".equalsIgnoreCase(urlData.getParameter("MatchList"));
        boolean autoAdd = "true".equalsIgnoreCase(urlData.getParameter("AutoAdd"));
        boolean channelMapping = "true".equalsIgnoreCase(urlData.getParameter("ChannelMapping"));
        boolean deviceSelection = "true".equalsIgnoreCase(urlData.getParameter("DeviceSelection"));
        boolean agentMapping = "true".equalsIgnoreCase(urlData.getParameter("AgentMapping"));
        boolean channels = "true".equalsIgnoreCase(urlData.getParameter("Channels"));
        boolean tasks = "true".equalsIgnoreCase(urlData.getParameter("Tasks"));
        boolean systemProp = "true".equalsIgnoreCase(urlData.getParameter("SystemProp"));
        boolean schedules = "true".equalsIgnoreCase(urlData.getParameter("Schedules"));
        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
        ZipOutputStream out = new ZipOutputStream(bytesOut);
        out.setComment("TV Scheduler Pro Settings file (Version: 1.0)");
        if (channels) {
            out.putNextEntry(new ZipEntry("Channels.xml"));
            StringBuffer channelData = new StringBuffer();
            store.saveChannels(channelData);
            byte[] channelBytes = channelData.toString().getBytes("UTF-8");
            out.write(channelBytes);
            out.closeEntry();
        }
        if (matchList) {
            out.putNextEntry(new ZipEntry("MatchList.xml"));
            StringBuffer matchData = new StringBuffer();
            store.saveMatchList(matchData);
            byte[] matchBytes = matchData.toString().getBytes("UTF-8");
            out.write(matchBytes);
            out.closeEntry();
        }
        if (autoAdd) {
            out.putNextEntry(new ZipEntry("EpgAutoAdd.xml"));
            StringBuffer addData = new StringBuffer();
            store.saveEpgAutoList(addData);
            byte[] addBytes = addData.toString().getBytes("UTF-8");
            out.write(addBytes);
            out.closeEntry();
        }
        if (tasks) {
            out.putNextEntry(new ZipEntry("Tasks.xml"));
            StringBuffer taskData = new StringBuffer();
            store.saveTaskList(taskData);
            byte[] taskBytes = taskData.toString().getBytes("UTF-8");
            out.write(taskBytes);
            out.closeEntry();
        }
        if (channelMapping) {
            GuideStore guideStore = GuideStore.getInstance();
            out.putNextEntry(new ZipEntry("ChannelMap.sof"));
            ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream();
            guideStore.saveChannelMap(chanMapBytes);
            out.write(chanMapBytes.toByteArray());
            out.closeEntry();
        }
        if (deviceSelection) {
            out.putNextEntry(new ZipEntry("CaptureDevices.sof"));
            ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream();
            devList.saveDeviceList(deviceBytes);
            out.write(deviceBytes.toByteArray());
            out.closeEntry();
        }
        if (agentMapping) {
            out.putNextEntry(new ZipEntry("AgentMap.sof"));
            ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream();
            store.saveAgentToThemeMap(agentMapBytes);
            out.write(agentMapBytes.toByteArray());
            out.closeEntry();
        }
        if (schedules) {
            out.putNextEntry(new ZipEntry("Times.sof"));
            ByteArrayOutputStream timesBytes = new ByteArrayOutputStream();
            store.saveSchedule(timesBytes);
            out.write(timesBytes.toByteArray());
            out.closeEntry();
        }
        if (systemProp) {
            HashMap<String, String> serverProp = new HashMap<String, String>();
            serverProp.put("Capture.path", store.getProperty("Capture.path"));
            serverProp.put("Capture.AverageDataRate", store.getProperty("Capture.AverageDataRate"));
            serverProp.put("Capture.AutoSelectMethod", store.getProperty("Capture.AutoSelectMethod"));
            serverProp.put("Capture.minSpace", store.getProperty("Capture.minSpace"));
            serverProp.put("Capture.IncludeCalculatedUsage", store.getProperty("Capture.IncludeCalculatedUsage"));
            serverProp.put("Capture.deftype", store.getProperty("Capture.deftype"));
            serverProp.put("Capture.filename.patterns", store.getProperty("Capture.filename.patterns"));
            serverProp.put("Capture.path.details", store.getProperty("Capture.path.details"));
            serverProp.put("Capture.CaptureFailedTimeout", store.getProperty("Capture.CaptureFailedTimeout"));
            serverProp.put("Schedule.buffer.start", store.getProperty("Schedule.buffer.start"));
            serverProp.put("Schedule.buffer.end", store.getProperty("Schedule.buffer.end"));
            serverProp.put("Schedule.buffer.end.epg", store.getProperty("Schedule.buffer.end.epg"));
            serverProp.put("Schedule.wake.system", store.getProperty("Schedule.wake.system"));
            serverProp.put("sch.autodel.action", store.getProperty("sch.autodel.action"));
            serverProp.put("sch.autodel.time", store.getProperty("sch.autodel.time"));
            serverProp.put("guide.source.http.pwd", store.getProperty("guide.source.http.pwd"));
            serverProp.put("guide.source.xml.channelList", store.getProperty("guide.source.xml.channelList"));
            serverProp.put("guide.source.type", store.getProperty("guide.source.type"));
            serverProp.put("guide.source.http", store.getProperty("guide.source.http"));
            serverProp.put("guide.source.file", store.getProperty("guide.source.file"));
            serverProp.put("guide.action.name", store.getProperty("guide.action.name"));
            serverProp.put("guide.source.http.usr", store.getProperty("guide.source.http.usr"));
            serverProp.put("guide.source.schedule", store.getProperty("guide.source.schedule"));
            serverProp.put("guide.warn.overlap", store.getProperty("guide.warn.overlap"));
            serverProp.put("proxy.server", store.getProperty("proxy.server"));
            serverProp.put("proxy.port", store.getProperty("proxy.port"));
            serverProp.put("proxy.server.usr", store.getProperty("proxy.server.usr"));
            serverProp.put("proxy.server.pwd", store.getProperty("proxy.server.pwd"));
            serverProp.put("email.server", store.getProperty("email.server"));
            serverProp.put("email.from.name", store.getProperty("email.from.name"));
            serverProp.put("email.to", store.getProperty("email.to"));
            serverProp.put("email.from", store.getProperty("email.from"));
            serverProp.put("Tasks.DefTask", store.getProperty("Tasks.DefTask"));
            serverProp.put("Tasks.PreTask", store.getProperty("Tasks.PreTask"));
            serverProp.put("Tasks.NoDataErrorTask", store.getProperty("Tasks.NoDataErrorTask"));
            serverProp.put("Tasks.StartErrorTask", store.getProperty("Tasks.StartErrorTask"));
            serverProp.put("filebrowser.DirsAtTop", store.getProperty("filebrowser.DirsAtTop"));
            serverProp.put("filebrowser.masks", store.getProperty("filebrowser.masks"));
            serverProp.put("server.kbLED", store.getProperty("server.kbLED"));
            ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(serverpropBytes);
            oos.writeObject(serverProp);
            oos.close();
            out.putNextEntry(new ZipEntry("ServerProperties.sof"));
            out.write(serverpropBytes.toByteArray());
            out.closeEntry();
        }
        out.flush();
        out.close();
        StringBuffer header = new StringBuffer();
        header.append("HTTP/1.1 200 OK\n");
        header.append("Content-Type: application/zip\n");
        header.append("Content-Length: " + bytesOut.size() + "\n");
        header.append("Content-Disposition: attachment; filename=\"TV Scheduler Pro Settings.zip\"\n");
        DateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy hh:mm:ss 'GMT'", new Locale("En", "Us", "Unix"));
        header.append("Last-Modified: " + df.format(new Date()) + "\n");
        header.append("\n");
        outStream.write(header.toString().getBytes());
        ByteArrayInputStream zipStream = new ByteArrayInputStream(bytesOut.toByteArray());
        byte[] bytes = new byte[4096];
        int read = zipStream.read(bytes);
        while (read > -1) {
            outStream.write(bytes, 0, read);
            outStream.flush();
            read = zipStream.read(bytes);
        }
    }
----------------------------------------
    private void exportAllSettings(HTTPurl urlData, OutputStream outStream) throws Exception {
        CaptureDeviceList devList = CaptureDeviceList.getInstance();
        if (devList.getActiveDeviceCount() > 0) {
            PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "SettingsLoad.html");
            StringBuffer buff = new StringBuffer();
            buff.append("<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>");
            template.replaceAll("$result", buff.toString());
            outStream.write(template.getPageBytes());
            return;
        }
        boolean matchList = "true".equalsIgnoreCase(urlData.getParameter("MatchList"));
        boolean autoAdd = "true".equalsIgnoreCase(urlData.getParameter("AutoAdd"));
        boolean channelMapping = "true".equalsIgnoreCase(urlData.getParameter("ChannelMapping"));
        boolean deviceSelection = "true".equalsIgnoreCase(urlData.getParameter("DeviceSelection"));
        boolean agentMapping = "true".equalsIgnoreCase(urlData.getParameter("AgentMapping"));
        boolean channels = "true".equalsIgnoreCase(urlData.getParameter("Channels"));
        boolean tasks = "true".equalsIgnoreCase(urlData.getParameter("Tasks"));
        boolean systemProp = "true".equalsIgnoreCase(urlData.getParameter("SystemProp"));
        boolean schedules = "true".equalsIgnoreCase(urlData.getParameter("Schedules"));
        boolean authSettings = "true".equalsIgnoreCase(urlData.getParameter("AuthSettings"));
        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
        ZipOutputStream out = new ZipOutputStream(bytesOut);
        out.setComment("TV Scheduler Pro Settings file (Version: 1.0)");
        if (channels) {
            out.putNextEntry(new ZipEntry("Channels.xml"));
            StringBuffer channelData = new StringBuffer();
            store.saveChannels(channelData);
            byte[] channelBytes = channelData.toString().getBytes("UTF-8");
            out.write(channelBytes);
            out.closeEntry();
        }
        if (matchList) {
            out.putNextEntry(new ZipEntry("MatchList.xml"));
            StringBuffer matchData = new StringBuffer();
            store.saveMatchList(matchData);
            byte[] matchBytes = matchData.toString().getBytes("UTF-8");
            out.write(matchBytes);
            out.closeEntry();
        }
        if (autoAdd) {
            out.putNextEntry(new ZipEntry("EpgAutoAdd.xml"));
            StringBuffer addData = new StringBuffer();
            store.saveEpgAutoList(addData);
            byte[] addBytes = addData.toString().getBytes("UTF-8");
            out.write(addBytes);
            out.closeEntry();
        }
        if (tasks) {
            out.putNextEntry(new ZipEntry("Tasks.xml"));
            StringBuffer taskData = new StringBuffer();
            store.saveTaskList(taskData);
            byte[] taskBytes = taskData.toString().getBytes("UTF-8");
            out.write(taskBytes);
            out.closeEntry();
        }
        if (channelMapping) {
            GuideStore guideStore = GuideStore.getInstance();
            out.putNextEntry(new ZipEntry("ChannelMap.sof"));
            ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream();
            guideStore.saveChannelMap(chanMapBytes);
            out.write(chanMapBytes.toByteArray());
            out.closeEntry();
        }
        if (deviceSelection) {
            out.putNextEntry(new ZipEntry("CaptureDevices.sof"));
            ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream();
            devList.saveDeviceList(deviceBytes);
            out.write(deviceBytes.toByteArray());
            out.closeEntry();
        }
        if (agentMapping) {
            out.putNextEntry(new ZipEntry("AgentMap.sof"));
            ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream();
            store.saveAgentToThemeMap(agentMapBytes);
            out.write(agentMapBytes.toByteArray());
            out.closeEntry();
        }
        if (schedules) {
            out.putNextEntry(new ZipEntry("Times.sof"));
            ByteArrayOutputStream timesBytes = new ByteArrayOutputStream();
            store.saveSchedule(timesBytes);
            out.write(timesBytes.toByteArray());
            out.closeEntry();
        }
        if (systemProp) {
            HashMap<String, String> serverProp = new HashMap<String, String>();
            serverProp.put("epg.showunlinked", store.getProperty("epg.showunlinked"));
            serverProp.put("path.theme", store.getProperty("path.theme"));
            serverProp.put("path.theme.epg", store.getProperty("path.theme.epg"));
            serverProp.put("capture.path", store.getProperty("capture.path"));
            serverProp.put("capture.averagedatarate", store.getProperty("capture.averagedatarate"));
            serverProp.put("capture.autoselectmethod", store.getProperty("capture.autoselectmethod"));
            serverProp.put("capture.minspacesoft", store.getProperty("capture.minspacesoft"));
            serverProp.put("capture.includecalculatedusage", store.getProperty("capture.includecalculatedusage"));
            serverProp.put("capture.deftype", store.getProperty("capture.deftype"));
            serverProp.put("capture.filename.patterns", store.getProperty("capture.filename.patterns"));
            serverProp.put("capture.path.details", store.getProperty("capture.path.details"));
            serverProp.put("capture.capturefailedtimeout", store.getProperty("capture.capturefailedtimeout"));
            serverProp.put("schedule.buffer.start", store.getProperty("schedule.buffer.start"));
            serverProp.put("schedule.buffer.end", store.getProperty("schedule.buffer.end"));
            serverProp.put("schedule.buffer.end.epg", store.getProperty("schedule.buffer.end.epg"));
            serverProp.put("schedule.wake.system", store.getProperty("schedule.wake.system"));
            serverProp.put("schedule.overlap", store.getProperty("schedule.overlap"));
            serverProp.put("sch.autodel.action", store.getProperty("sch.autodel.action"));
            serverProp.put("sch.autodel.time", store.getProperty("sch.autodel.time"));
            serverProp.put("guide.source.http.pwd", store.getProperty("guide.source.http.pwd"));
            serverProp.put("guide.source.xml.channelList", store.getProperty("guide.source.xml.channelList"));
            serverProp.put("guide.source.type", store.getProperty("guide.source.type"));
            serverProp.put("guide.source.http", store.getProperty("guide.source.http"));
            serverProp.put("guide.source.file", store.getProperty("guide.source.file"));
            serverProp.put("guide.action.name", store.getProperty("guide.action.name"));
            serverProp.put("guide.source.http.usr", store.getProperty("guide.source.http.usr"));
            serverProp.put("guide.source.schedule", store.getProperty("guide.source.schedule"));
            serverProp.put("guide.warn.overlap", store.getProperty("guide.warn.overlap"));
            serverProp.put("proxy.server", store.getProperty("proxy.server"));
            serverProp.put("proxy.port", store.getProperty("proxy.port"));
            serverProp.put("proxy.server.usr", store.getProperty("proxy.server.usr"));
            serverProp.put("proxy.server.pwd", store.getProperty("proxy.server.pwd"));
            serverProp.put("email.server", store.getProperty("email.server"));
            serverProp.put("email.from.name", store.getProperty("email.from.name"));
            serverProp.put("email.to", store.getProperty("email.to"));
            serverProp.put("email.from", store.getProperty("email.from"));
            serverProp.put("email.send.weeklyreport", store.getProperty("email.send.weeklyreport"));
            serverProp.put("email.send.capfinished", store.getProperty("email.send.capfinished"));
            serverProp.put("email.send.epgloaded", store.getProperty("email.send.epgloaded"));
            serverProp.put("email.send.onwarning", store.getProperty("email.send.onwarning"));
            serverProp.put("email.send.freespacelow", store.getProperty("email.send.freespacelow"));
            serverProp.put("email.send.serverstarted", store.getProperty("email.send.serverstarted"));
            serverProp.put("tasks.deftask", store.getProperty("tasks.deftask"));
            serverProp.put("tasks.pretask", store.getProperty("tasks.pretask"));
            serverProp.put("tasks.nodataerrortask", store.getProperty("tasks.nodataerrortask"));
            serverProp.put("tasks.starterrortask", store.getProperty("tasks.starterrortask"));
            serverProp.put("filebrowser.dirsattop", store.getProperty("filebrowser.dirsattop"));
            serverProp.put("filebrowser.masks", store.getProperty("filebrowser.masks"));
            serverProp.put("server.kbled", store.getProperty("server.kbled"));
            ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(serverpropBytes);
            oos.writeObject(serverProp);
            oos.close();
            out.putNextEntry(new ZipEntry("ServerProperties.sof"));
            out.write(serverpropBytes.toByteArray());
            out.closeEntry();
        }
        if (authSettings) {
            File authFile = new File(store.getProperty("path.data") + File.separator + "authentication.prop");
            if (authFile.exists()) {
                out.putNextEntry(new ZipEntry("authentication.prop"));
                FileInputStream is = new FileInputStream(authFile);
                byte[] buff = new byte[1024];
                int read = is.read(buff);
                while (read != -1) {
                    out.write(buff, 0, read);
                    read = is.read(buff);
                }
                out.closeEntry();
                is.close();
            }
        }
        out.flush();
        out.close();
        StringBuffer header = new StringBuffer();
        header.append("HTTP/1.1 200 OK\n");
        header.append("Content-Type: application/zip\n");
        header.append("Content-Length: " + bytesOut.size() + "\n");
        header.append("Content-Disposition: attachment; filename=\"TV Scheduler Pro Settings.zip\"\n");
        DateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy hh:mm:ss 'GMT'", new Locale("En", "Us", "Unix"));
        header.append("Last-Modified: " + df.format(new Date()) + "\n");
        header.append("\n");
        outStream.write(header.toString().getBytes());
        ByteArrayInputStream zipStream = new ByteArrayInputStream(bytesOut.toByteArray());
        byte[] bytes = new byte[4096];
        int read = zipStream.read(bytes);
        while (read > -1) {
            outStream.write(bytes, 0, read);
            outStream.flush();
            read = zipStream.read(bytes);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,60868.java,315,466
default,94873.java,391,568
----------------------------------------
    private void exportAllSettings(HTTPurl urlData, OutputStream outStream) throws Exception {
        CaptureDeviceList devList = CaptureDeviceList.getInstance();
        if (devList.getActiveDeviceCount() > 0) {
            PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "SettingsLoad.html");
            StringBuffer buff = new StringBuffer();
            buff.append("<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>");
            template.replaceAll("$result", buff.toString());
            outStream.write(template.getPageBytes());
            return;
        }
        boolean matchList = "true".equalsIgnoreCase(urlData.getParameter("MatchList"));
        boolean autoAdd = "true".equalsIgnoreCase(urlData.getParameter("AutoAdd"));
        boolean channelMapping = "true".equalsIgnoreCase(urlData.getParameter("ChannelMapping"));
        boolean deviceSelection = "true".equalsIgnoreCase(urlData.getParameter("DeviceSelection"));
        boolean agentMapping = "true".equalsIgnoreCase(urlData.getParameter("AgentMapping"));
        boolean channels = "true".equalsIgnoreCase(urlData.getParameter("Channels"));
        boolean tasks = "true".equalsIgnoreCase(urlData.getParameter("Tasks"));
        boolean systemProp = "true".equalsIgnoreCase(urlData.getParameter("SystemProp"));
        boolean schedules = "true".equalsIgnoreCase(urlData.getParameter("Schedules"));
        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
        ZipOutputStream out = new ZipOutputStream(bytesOut);
        out.setComment("TV Scheduler Pro Settings file (Version: 1.0)");
        if (channels) {
            out.putNextEntry(new ZipEntry("Channels.xml"));
            StringBuffer channelData = new StringBuffer();
            store.saveChannels(channelData);
            byte[] channelBytes = channelData.toString().getBytes("UTF-8");
            out.write(channelBytes);
            out.closeEntry();
        }
        if (matchList) {
            out.putNextEntry(new ZipEntry("MatchList.xml"));
            StringBuffer matchData = new StringBuffer();
            store.saveMatchList(matchData);
            byte[] matchBytes = matchData.toString().getBytes("UTF-8");
            out.write(matchBytes);
            out.closeEntry();
        }
        if (autoAdd) {
            out.putNextEntry(new ZipEntry("EpgAutoAdd.xml"));
            StringBuffer addData = new StringBuffer();
            store.saveEpgAutoList(addData);
            byte[] addBytes = addData.toString().getBytes("UTF-8");
            out.write(addBytes);
            out.closeEntry();
        }
        if (tasks) {
            out.putNextEntry(new ZipEntry("Tasks.xml"));
            StringBuffer taskData = new StringBuffer();
            store.saveTaskList(taskData);
            byte[] taskBytes = taskData.toString().getBytes("UTF-8");
            out.write(taskBytes);
            out.closeEntry();
        }
        if (channelMapping) {
            GuideStore guideStore = GuideStore.getInstance();
            out.putNextEntry(new ZipEntry("ChannelMap.sof"));
            ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream();
            guideStore.saveChannelMap(chanMapBytes);
            out.write(chanMapBytes.toByteArray());
            out.closeEntry();
        }
        if (deviceSelection) {
            out.putNextEntry(new ZipEntry("CaptureDevices.sof"));
            ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream();
            devList.saveDeviceList(deviceBytes);
            out.write(deviceBytes.toByteArray());
            out.closeEntry();
        }
        if (agentMapping) {
            out.putNextEntry(new ZipEntry("AgentMap.sof"));
            ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream();
            store.saveAgentToThemeMap(agentMapBytes);
            out.write(agentMapBytes.toByteArray());
            out.closeEntry();
        }
        if (schedules) {
            out.putNextEntry(new ZipEntry("Times.sof"));
            ByteArrayOutputStream timesBytes = new ByteArrayOutputStream();
            store.saveSchedule(timesBytes);
            out.write(timesBytes.toByteArray());
            out.closeEntry();
        }
        if (systemProp) {
            HashMap<String, String> serverProp = new HashMap<String, String>();
            serverProp.put("Capture.path", store.getProperty("Capture.path"));
            serverProp.put("Capture.AverageDataRate", store.getProperty("Capture.AverageDataRate"));
            serverProp.put("Capture.AutoSelectMethod", store.getProperty("Capture.AutoSelectMethod"));
            serverProp.put("Capture.minSpace", store.getProperty("Capture.minSpace"));
            serverProp.put("Capture.IncludeCalculatedUsage", store.getProperty("Capture.IncludeCalculatedUsage"));
            serverProp.put("Capture.deftype", store.getProperty("Capture.deftype"));
            serverProp.put("Capture.filename.patterns", store.getProperty("Capture.filename.patterns"));
            serverProp.put("Capture.path.details", store.getProperty("Capture.path.details"));
            serverProp.put("Capture.CaptureFailedTimeout", store.getProperty("Capture.CaptureFailedTimeout"));
            serverProp.put("Schedule.buffer.start", store.getProperty("Schedule.buffer.start"));
            serverProp.put("Schedule.buffer.end", store.getProperty("Schedule.buffer.end"));
            serverProp.put("Schedule.buffer.end.epg", store.getProperty("Schedule.buffer.end.epg"));
            serverProp.put("Schedule.wake.system", store.getProperty("Schedule.wake.system"));
            serverProp.put("sch.autodel.action", store.getProperty("sch.autodel.action"));
            serverProp.put("sch.autodel.time", store.getProperty("sch.autodel.time"));
            serverProp.put("guide.source.http.pwd", store.getProperty("guide.source.http.pwd"));
            serverProp.put("guide.source.xml.channelList", store.getProperty("guide.source.xml.channelList"));
            serverProp.put("guide.source.type", store.getProperty("guide.source.type"));
            serverProp.put("guide.source.http", store.getProperty("guide.source.http"));
            serverProp.put("guide.source.file", store.getProperty("guide.source.file"));
            serverProp.put("guide.action.name", store.getProperty("guide.action.name"));
            serverProp.put("guide.source.http.usr", store.getProperty("guide.source.http.usr"));
            serverProp.put("guide.source.schedule", store.getProperty("guide.source.schedule"));
            serverProp.put("guide.warn.overlap", store.getProperty("guide.warn.overlap"));
            serverProp.put("proxy.server", store.getProperty("proxy.server"));
            serverProp.put("proxy.port", store.getProperty("proxy.port"));
            serverProp.put("proxy.server.usr", store.getProperty("proxy.server.usr"));
            serverProp.put("proxy.server.pwd", store.getProperty("proxy.server.pwd"));
            serverProp.put("email.server", store.getProperty("email.server"));
            serverProp.put("email.from.name", store.getProperty("email.from.name"));
            serverProp.put("email.to", store.getProperty("email.to"));
            serverProp.put("email.from", store.getProperty("email.from"));
            serverProp.put("Tasks.DefTask", store.getProperty("Tasks.DefTask"));
            serverProp.put("Tasks.PreTask", store.getProperty("Tasks.PreTask"));
            serverProp.put("Tasks.NoDataErrorTask", store.getProperty("Tasks.NoDataErrorTask"));
            serverProp.put("Tasks.StartErrorTask", store.getProperty("Tasks.StartErrorTask"));
            serverProp.put("filebrowser.DirsAtTop", store.getProperty("filebrowser.DirsAtTop"));
            serverProp.put("filebrowser.masks", store.getProperty("filebrowser.masks"));
            serverProp.put("server.kbLED", store.getProperty("server.kbLED"));
            ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(serverpropBytes);
            oos.writeObject(serverProp);
            oos.close();
            out.putNextEntry(new ZipEntry("ServerProperties.sof"));
            out.write(serverpropBytes.toByteArray());
            out.closeEntry();
        }
        out.flush();
        out.close();
        StringBuffer header = new StringBuffer();
        header.append("HTTP/1.1 200 OK\n");
        header.append("Content-Type: application/zip\n");
        header.append("Content-Length: " + bytesOut.size() + "\n");
        header.append("Content-Disposition: attachment; filename=\"TV Scheduler Pro Settings.zip\"\n");
        DateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy hh:mm:ss 'GMT'", new Locale("En", "Us", "Unix"));
        header.append("Last-Modified: " + df.format(new Date()) + "\n");
        header.append("\n");
        outStream.write(header.toString().getBytes());
        ByteArrayInputStream zipStream = new ByteArrayInputStream(bytesOut.toByteArray());
        byte[] bytes = new byte[4096];
        int read = zipStream.read(bytes);
        while (read > -1) {
            outStream.write(bytes, 0, read);
            outStream.flush();
            read = zipStream.read(bytes);
        }
    }
----------------------------------------
    private void exportAllSettings(HTTPurl urlData, OutputStream outStream) throws Exception {
        CaptureDeviceList devList = CaptureDeviceList.getInstance();
        if (devList.getActiveDeviceCount() > 0) {
            PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "SettingsLoad.html");
            StringBuffer buff = new StringBuffer();
            buff.append("<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>");
            template.replaceAll("$result", buff.toString());
            outStream.write(template.getPageBytes());
            return;
        }
        boolean matchList = "true".equalsIgnoreCase(urlData.getParameter("MatchList"));
        boolean autoAdd = "true".equalsIgnoreCase(urlData.getParameter("AutoAdd"));
        boolean channelMapping = "true".equalsIgnoreCase(urlData.getParameter("ChannelMapping"));
        boolean deviceSelection = "true".equalsIgnoreCase(urlData.getParameter("DeviceSelection"));
        boolean agentMapping = "true".equalsIgnoreCase(urlData.getParameter("AgentMapping"));
        boolean channels = "true".equalsIgnoreCase(urlData.getParameter("Channels"));
        boolean tasks = "true".equalsIgnoreCase(urlData.getParameter("Tasks"));
        boolean systemProp = "true".equalsIgnoreCase(urlData.getParameter("SystemProp"));
        boolean schedules = "true".equalsIgnoreCase(urlData.getParameter("Schedules"));
        boolean authSettings = "true".equalsIgnoreCase(urlData.getParameter("AuthSettings"));
        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
        ZipOutputStream out = new ZipOutputStream(bytesOut);
        out.setComment("TV Scheduler Pro Settings file (Version: 1.0)");
        if (channels) {
            out.putNextEntry(new ZipEntry("Channels.xml"));
            StringBuffer channelData = new StringBuffer();
            store.saveChannels(channelData);
            byte[] channelBytes = channelData.toString().getBytes("UTF-8");
            out.write(channelBytes);
            out.closeEntry();
        }
        if (matchList) {
            out.putNextEntry(new ZipEntry("MatchList.xml"));
            StringBuffer matchData = new StringBuffer();
            store.saveMatchList(matchData);
            byte[] matchBytes = matchData.toString().getBytes("UTF-8");
            out.write(matchBytes);
            out.closeEntry();
        }
        if (autoAdd) {
            out.putNextEntry(new ZipEntry("EpgAutoAdd.xml"));
            StringBuffer addData = new StringBuffer();
            store.saveEpgAutoList(addData);
            byte[] addBytes = addData.toString().getBytes("UTF-8");
            out.write(addBytes);
            out.closeEntry();
        }
        if (tasks) {
            out.putNextEntry(new ZipEntry("Tasks.xml"));
            StringBuffer taskData = new StringBuffer();
            store.saveTaskList(taskData);
            byte[] taskBytes = taskData.toString().getBytes("UTF-8");
            out.write(taskBytes);
            out.closeEntry();
        }
        if (channelMapping) {
            GuideStore guideStore = GuideStore.getInstance();
            out.putNextEntry(new ZipEntry("ChannelMap.sof"));
            ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream();
            guideStore.saveChannelMap(chanMapBytes);
            out.write(chanMapBytes.toByteArray());
            out.closeEntry();
        }
        if (deviceSelection) {
            out.putNextEntry(new ZipEntry("CaptureDevices.sof"));
            ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream();
            devList.saveDeviceList(deviceBytes);
            out.write(deviceBytes.toByteArray());
            out.closeEntry();
        }
        if (agentMapping) {
            out.putNextEntry(new ZipEntry("AgentMap.sof"));
            ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream();
            store.saveAgentToThemeMap(agentMapBytes);
            out.write(agentMapBytes.toByteArray());
            out.closeEntry();
        }
        if (schedules) {
            out.putNextEntry(new ZipEntry("Times.sof"));
            ByteArrayOutputStream timesBytes = new ByteArrayOutputStream();
            store.saveSchedule(timesBytes);
            out.write(timesBytes.toByteArray());
            out.closeEntry();
        }
        if (systemProp) {
            HashMap<String, String> serverProp = new HashMap<String, String>();
            serverProp.put("epg.showunlinked", store.getProperty("epg.showunlinked"));
            serverProp.put("path.theme", store.getProperty("path.theme"));
            serverProp.put("path.theme.epg", store.getProperty("path.theme.epg"));
            serverProp.put("capture.path", store.getProperty("capture.path"));
            serverProp.put("capture.averagedatarate", store.getProperty("capture.averagedatarate"));
            serverProp.put("capture.autoselectmethod", store.getProperty("capture.autoselectmethod"));
            serverProp.put("capture.minspacesoft", store.getProperty("capture.minspacesoft"));
            serverProp.put("capture.includecalculatedusage", store.getProperty("capture.includecalculatedusage"));
            serverProp.put("capture.deftype", store.getProperty("capture.deftype"));
            serverProp.put("capture.filename.patterns", store.getProperty("capture.filename.patterns"));
            serverProp.put("capture.path.details", store.getProperty("capture.path.details"));
            serverProp.put("capture.capturefailedtimeout", store.getProperty("capture.capturefailedtimeout"));
            serverProp.put("schedule.buffer.start", store.getProperty("schedule.buffer.start"));
            serverProp.put("schedule.buffer.end", store.getProperty("schedule.buffer.end"));
            serverProp.put("schedule.buffer.end.epg", store.getProperty("schedule.buffer.end.epg"));
            serverProp.put("schedule.wake.system", store.getProperty("schedule.wake.system"));
            serverProp.put("schedule.overlap", store.getProperty("schedule.overlap"));
            serverProp.put("sch.autodel.action", store.getProperty("sch.autodel.action"));
            serverProp.put("sch.autodel.time", store.getProperty("sch.autodel.time"));
            serverProp.put("guide.source.http.pwd", store.getProperty("guide.source.http.pwd"));
            serverProp.put("guide.source.xml.channelList", store.getProperty("guide.source.xml.channelList"));
            serverProp.put("guide.source.type", store.getProperty("guide.source.type"));
            serverProp.put("guide.source.http", store.getProperty("guide.source.http"));
            serverProp.put("guide.source.file", store.getProperty("guide.source.file"));
            serverProp.put("guide.action.name", store.getProperty("guide.action.name"));
            serverProp.put("guide.source.http.usr", store.getProperty("guide.source.http.usr"));
            serverProp.put("guide.source.schedule", store.getProperty("guide.source.schedule"));
            serverProp.put("guide.warn.overlap", store.getProperty("guide.warn.overlap"));
            serverProp.put("proxy.server", store.getProperty("proxy.server"));
            serverProp.put("proxy.port", store.getProperty("proxy.port"));
            serverProp.put("proxy.server.usr", store.getProperty("proxy.server.usr"));
            serverProp.put("proxy.server.pwd", store.getProperty("proxy.server.pwd"));
            serverProp.put("email.server", store.getProperty("email.server"));
            serverProp.put("email.from.name", store.getProperty("email.from.name"));
            serverProp.put("email.to", store.getProperty("email.to"));
            serverProp.put("email.from", store.getProperty("email.from"));
            serverProp.put("email.send.weeklyreport", store.getProperty("email.send.weeklyreport"));
            serverProp.put("email.send.capfinished", store.getProperty("email.send.capfinished"));
            serverProp.put("email.send.epgloaded", store.getProperty("email.send.epgloaded"));
            serverProp.put("email.send.onwarning", store.getProperty("email.send.onwarning"));
            serverProp.put("email.send.freespacelow", store.getProperty("email.send.freespacelow"));
            serverProp.put("email.send.serverstarted", store.getProperty("email.send.serverstarted"));
            serverProp.put("tasks.deftask", store.getProperty("tasks.deftask"));
            serverProp.put("tasks.pretask", store.getProperty("tasks.pretask"));
            serverProp.put("tasks.nodataerrortask", store.getProperty("tasks.nodataerrortask"));
            serverProp.put("tasks.starterrortask", store.getProperty("tasks.starterrortask"));
            serverProp.put("filebrowser.dirsattop", store.getProperty("filebrowser.dirsattop"));
            serverProp.put("filebrowser.masks", store.getProperty("filebrowser.masks"));
            serverProp.put("server.kbled", store.getProperty("server.kbled"));
            ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(serverpropBytes);
            oos.writeObject(serverProp);
            oos.close();
            out.putNextEntry(new ZipEntry("ServerProperties.sof"));
            out.write(serverpropBytes.toByteArray());
            out.closeEntry();
        }
        if (authSettings) {
            File authFile = new File(store.getProperty("path.data") + File.separator + "authentication.prop");
            if (authFile.exists()) {
                out.putNextEntry(new ZipEntry("authentication.prop"));
                FileInputStream is = new FileInputStream(authFile);
                byte[] buff = new byte[1024];
                int read = is.read(buff);
                while (read != -1) {
                    out.write(buff, 0, read);
                    read = is.read(buff);
                }
                out.closeEntry();
                is.close();
            }
        }
        out.flush();
        out.close();
        StringBuffer header = new StringBuffer();
        header.append("HTTP/1.1 200 OK\n");
        header.append("Content-Type: application/zip\n");
        header.append("Content-Length: " + bytesOut.size() + "\n");
        header.append("Content-Disposition: attachment; filename=\"TV Scheduler Pro Settings.zip\"\n");
        DateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy hh:mm:ss 'GMT'", new Locale("En", "Us", "Unix"));
        header.append("Last-Modified: " + df.format(new Date()) + "\n");
        header.append("\n");
        outStream.write(header.toString().getBytes());
        ByteArrayInputStream zipStream = new ByteArrayInputStream(bytesOut.toByteArray());
        byte[] bytes = new byte[4096];
        int read = zipStream.read(bytes);
        while (read > -1) {
            outStream.write(bytes, 0, read);
            outStream.flush();
            read = zipStream.read(bytes);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25960.java,284,433
default,132930.java,268,417
----------------------------------------
    private void scanAll(HTTPurl urlData, OutputStream outStream) throws Exception {
        int country = 0;
        int region = 0;
        try {
            country = Integer.parseInt(urlData.getParameter("country"));
            region = Integer.parseInt(urlData.getParameter("region"));
        } catch (Exception e) {
            throw new Exception("country or region code not valid: " + e.toString());
        }
        PageTemplate template = new PageTemplate(store.getProperty("path.template").replace('\\', File.separatorChar) + File.separator + "channelscan.html");
        outStream.write(template.getPageBytes());
        CaptureDeviceList devList = CaptureDeviceList.getInstance();
        if (devList.getActiveDeviceCount() > 0) {
            outStream.write("Can not scan channels, Captures Running!".getBytes());
            return;
        }
        if (devList.getDeviceCount() == 0) {
            outStream.write("No Devices Available!".getBytes());
            return;
        }
        String out = "<form action=\"/servlet/" + urlData.getServletClass() + "\" method=\"POST\" accept-charset=\"UTF-8\">\n" + "<input type=\"hidden\" name=\"action\" value='05'>\n";
        outStream.write(out.getBytes());
        outStream.flush();
        ChannelList list = new ChannelList(store.getProperty("path.data") + File.separator + "stationdata.list");
        Channel[] channelList = list.getStations(country, region);
        list.close();
        try {
            int channelCount = 0;
            Channel ch = null;
            for (int x = 0; x < channelList.length; x++) {
                int channelsFound = 0;
                ch = channelList[x];
                if (ch != null) {
                    StringBuffer buff = new StringBuffer(2048);
                    buff.append("<table class='channelScanResult'>\n");
                    buff.append("<tr class=\"scanChannelHeading\">\n");
                    buff.append("<td class=\"scanChannelHeadingDataName\">" + ch.getName() + "</td>\n");
                    buff.append("<td class=\"scanChannelHeadingData\">Program</td>\n");
                    buff.append("<td class=\"scanChannelHeadingData\">Video</td>\n");
                    buff.append("<td class=\"scanChannelHeadingData\">Audio</td>\n");
                    buff.append("<td class=\"scanChannelHeadingData\">Add</td>\n");
                    buff.append("</tr>\n");
                    if (x > 0) Thread.sleep(5000);
                    CaptureDevice cap = (CaptureDevice) devList.getDevice(0);
                    String scanCommand = "scan.exe " + ch.getFrequency() + " " + ch.getBandWidth() + " \"" + cap.getID() + "\"";
                    System.out.println("Running channel scan command: " + scanCommand);
                    Runtime runner = Runtime.getRuntime();
                    String[] com = new String[4];
                    com[0] = "scan.exe";
                    com[1] = new Integer(ch.getFrequency()).toString();
                    com[2] = new Integer(ch.getBandWidth()).toString();
                    com[3] = "\"" + cap.getID() + "\"";
                    Process scan = runner.exec(com);
                    ScanResult result = new ScanResult(ch.getFrequency(), ch.getBandWidth());
                    result.readInput(scan.getInputStream());
                    result.parseXML();
                    Vector scanResult = result.getResult();
                    Channel chData = null;
                    for (int y = 0; y < scanResult.size(); y++) {
                        chData = (Channel) scanResult.get(y);
                        if (chData != null) {
                            buff.append("<tr class='scanChannelResult'>");
                            buff.append("<td>\n<input type='text' name='name" + channelCount + "' value='" + checkName(chData.getName()) + "'>\n");
                            buff.append("<input type='hidden' name='freq" + channelCount + "' value='" + chData.getFrequency() + "'>\n");
                            buff.append("<input type='hidden' name='band" + channelCount + "' value='" + chData.getBandWidth() + "'>\n");
                            buff.append("</td>\n\n");
                            buff.append("<td align='center'>" + chData.getProgramID());
                            buff.append("<input type='hidden' name='programid" + channelCount + "' value='" + chData.getProgramID() + "'>\n");
                            buff.append("</td>\n");
                            buff.append("<td align='center'>");
                            int count = getStreamTypeCount(chData, Channel.TYPE_VIDEO);
                            if (count == 0) {
                                buff.append("-1");
                                buff.append("<input type='hidden' name='videoid" + channelCount + "' value='-1'>\n");
                            }
                            if (count == 1) {
                                int[] data = getFirstOfType(chData, Channel.TYPE_VIDEO);
                                buff.append(data[0]);
                                buff.append("<input type='hidden' name='videoid" + channelCount + "' value='" + data[0] + "'>\n");
                            } else if (count > 1) {
                                buff.append("<SELECT NAME='videoid" + channelCount + "'>\n");
                                for (int st = 0; st < chData.getStreams().size(); st++) {
                                    int[] streamData = (int[]) chData.getStreams().get(st);
                                    if (streamData[1] == Channel.TYPE_VIDEO) {
                                        buff.append("<OPTION value=\"" + streamData[0] + "\">");
                                        buff.append(streamData[0]);
                                        buff.append("</OPTION>\n");
                                    }
                                }
                                buff.append("</SELECT>");
                            }
                            buff.append("</td>\n");
                            buff.append("<td align='center'>");
                            count = getStreamTypeCount(chData, Channel.TYPE_AUDIO_AC3);
                            count += getStreamTypeCount(chData, Channel.TYPE_AUDIO_MPG);
                            if (count == 0) {
                                buff.append("-1");
                                buff.append("<input type='hidden' name='audioid" + channelCount + "' value='-1'>\n");
                            }
                            if (count == 1) {
                                int[] data = getFirstOfType(chData, Channel.TYPE_AUDIO_AC3);
                                if (data == null) data = getFirstOfType(chData, Channel.TYPE_AUDIO_MPG);
                                buff.append(data[0]);
                                if (data[1] == Channel.TYPE_AUDIO_AC3) buff.append(" AC3"); else buff.append(" MPG");
                                buff.append("<input type='hidden' name='audioid" + channelCount + "' value='" + data[0] + ":" + data[1] + "'>\n");
                            } else if (count > 1) {
                                buff.append("<SELECT NAME='audioid" + channelCount + "'>\n");
                                for (int st = 0; st < chData.getStreams().size(); st++) {
                                    int[] streamData = (int[]) chData.getStreams().get(st);
                                    if (streamData[1] == Channel.TYPE_AUDIO_MPG || streamData[1] == Channel.TYPE_AUDIO_AC3) {
                                        buff.append("<OPTION value=\"" + streamData[0] + ":" + streamData[1] + "\">");
                                        buff.append(streamData[0]);
                                        if (streamData[1] == Channel.TYPE_AUDIO_AC3) buff.append(" AC3"); else buff.append(" MPG");
                                        buff.append("</OPTION>\n");
                                    }
                                }
                                buff.append("</SELECT>");
                            }
                            buff.append("</td>\n");
                            buff.append("<td align='center'><input type='checkbox' name='add" + channelCount + "' value='add'></td>\n");
                            buff.append("</tr>\n\n");
                            channelCount++;
                            channelsFound++;
                        } else {
                            break;
                        }
                    }
                    if (channelsFound == 0) {
                        buff.append("<tr class='scanChannelResult'>");
                        buff.append("<td>No Programs Found</td>\n");
                        buff.append("<td align='center'>N/A</td>\n");
                        buff.append("<td align='center'>N/A</td>\n");
                        buff.append("<td align='center'>N/A</td>\n");
                        buff.append("<td align='center'>N/A</td>\n");
                        buff.append("</tr>\n\n");
                    }
                    buff.append("</table><br>\n");
                    outStream.write(buff.toString().getBytes());
                    outStream.flush();
                    outStream.write("\n\n\n\n\n           \n\n\n\n\n\n".getBytes());
                    outStream.flush();
                }
            }
            if (channelCount > 0) out = "<input type=\"submit\" value=\"Add Selected\"></form></body></html><br><br>\n";
            outStream.write(out.getBytes());
            outStream.flush();
        } catch (Exception e) {
            throw e;
        }
    }
----------------------------------------
    private void scanAll(HTTPurl urlData, OutputStream outStream) throws Exception {
        int country = 0;
        int region = 0;
        try {
            country = Integer.parseInt(urlData.getParameter("country"));
            region = Integer.parseInt(urlData.getParameter("region"));
        } catch (Exception e) {
            throw new Exception("country or region code not valid: " + e.toString());
        }
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "channelscan.html");
        outStream.write(template.getPageBytes());
        CaptureDeviceList devList = CaptureDeviceList.getInstance();
        if (devList.getActiveDeviceCount() > 0) {
            outStream.write("Can not scan channels, Captures Running!".getBytes());
            return;
        }
        if (devList.getDeviceCount() == 0) {
            outStream.write("No Devices Available!".getBytes());
            return;
        }
        String out = "<form action=\"/servlet/" + urlData.getServletClass() + "\" method=\"POST\" accept-charset=\"UTF-8\">\n" + "<input type=\"hidden\" name=\"action\" value='05'>\n";
        outStream.write(out.getBytes());
        outStream.flush();
        ChannelList list = new ChannelList(store.getProperty("path.data") + File.separator + "stationdata.list");
        Channel[] channelList = list.getStations(country, region);
        list.close();
        try {
            int channelCount = 0;
            Channel ch = null;
            for (int x = 0; x < channelList.length; x++) {
                int channelsFound = 0;
                ch = channelList[x];
                if (ch != null) {
                    StringBuffer buff = new StringBuffer(2048);
                    buff.append("<table class='channelScanResult'>\n");
                    buff.append("<tr class=\"scanChannelHeading\">\n");
                    buff.append("<td class=\"scanChannelHeadingDataName\">" + ch.getName() + "</td>\n");
                    buff.append("<td class=\"scanChannelHeadingData\">Program</td>\n");
                    buff.append("<td class=\"scanChannelHeadingData\">Video</td>\n");
                    buff.append("<td class=\"scanChannelHeadingData\">Audio</td>\n");
                    buff.append("<td class=\"scanChannelHeadingData\">Add</td>\n");
                    buff.append("</tr>\n");
                    if (x > 0) Thread.sleep(5000);
                    CaptureDevice cap = (CaptureDevice) devList.getDevice(0);
                    String scanCommand = "scan.exe " + ch.getFrequency() + " " + ch.getBandWidth() + " \"" + cap.getID() + "\"";
                    System.out.println("Running channel scan command: " + scanCommand);
                    Runtime runner = Runtime.getRuntime();
                    String[] com = new String[4];
                    com[0] = "scan.exe";
                    com[1] = new Integer(ch.getFrequency()).toString();
                    com[2] = new Integer(ch.getBandWidth()).toString();
                    com[3] = "\"" + cap.getID() + "\"";
                    Process scan = runner.exec(com);
                    ScanResult result = new ScanResult(ch.getFrequency(), ch.getBandWidth());
                    result.readInput(scan.getInputStream());
                    result.parseXML();
                    Vector scanResult = result.getResult();
                    Channel chData = null;
                    for (int y = 0; y < scanResult.size(); y++) {
                        chData = (Channel) scanResult.get(y);
                        if (chData != null) {
                            buff.append("<tr class='scanChannelResult'>");
                            buff.append("<td>\n<input type='text' name='name" + channelCount + "' value='" + checkName(chData.getName()) + "'>\n");
                            buff.append("<input type='hidden' name='freq" + channelCount + "' value='" + chData.getFrequency() + "'>\n");
                            buff.append("<input type='hidden' name='band" + channelCount + "' value='" + chData.getBandWidth() + "'>\n");
                            buff.append("</td>\n\n");
                            buff.append("<td align='center'>" + chData.getProgramID());
                            buff.append("<input type='hidden' name='programid" + channelCount + "' value='" + chData.getProgramID() + "'>\n");
                            buff.append("</td>\n");
                            buff.append("<td align='center'>");
                            int count = getStreamTypeCount(chData, Channel.TYPE_VIDEO);
                            if (count == 0) {
                                buff.append("-1");
                                buff.append("<input type='hidden' name='videoid" + channelCount + "' value='-1'>\n");
                            }
                            if (count == 1) {
                                int[] data = getFirstOfType(chData, Channel.TYPE_VIDEO);
                                buff.append(data[0]);
                                buff.append("<input type='hidden' name='videoid" + channelCount + "' value='" + data[0] + "'>\n");
                            } else if (count > 1) {
                                buff.append("<SELECT NAME='videoid" + channelCount + "'>\n");
                                for (int st = 0; st < chData.getStreams().size(); st++) {
                                    int[] streamData = (int[]) chData.getStreams().get(st);
                                    if (streamData[1] == Channel.TYPE_VIDEO) {
                                        buff.append("<OPTION value=\"" + streamData[0] + "\">");
                                        buff.append(streamData[0]);
                                        buff.append("</OPTION>\n");
                                    }
                                }
                                buff.append("</SELECT>");
                            }
                            buff.append("</td>\n");
                            buff.append("<td align='center'>");
                            count = getStreamTypeCount(chData, Channel.TYPE_AUDIO_AC3);
                            count += getStreamTypeCount(chData, Channel.TYPE_AUDIO_MPG);
                            if (count == 0) {
                                buff.append("-1");
                                buff.append("<input type='hidden' name='audioid" + channelCount + "' value='-1'>\n");
                            }
                            if (count == 1) {
                                int[] data = getFirstOfType(chData, Channel.TYPE_AUDIO_AC3);
                                if (data == null) data = getFirstOfType(chData, Channel.TYPE_AUDIO_MPG);
                                buff.append(data[0]);
                                if (data[1] == Channel.TYPE_AUDIO_AC3) buff.append(" AC3"); else buff.append(" MPG");
                                buff.append("<input type='hidden' name='audioid" + channelCount + "' value='" + data[0] + ":" + data[1] + "'>\n");
                            } else if (count > 1) {
                                buff.append("<SELECT NAME='audioid" + channelCount + "'>\n");
                                for (int st = 0; st < chData.getStreams().size(); st++) {
                                    int[] streamData = (int[]) chData.getStreams().get(st);
                                    if (streamData[1] == Channel.TYPE_AUDIO_MPG || streamData[1] == Channel.TYPE_AUDIO_AC3) {
                                        buff.append("<OPTION value=\"" + streamData[0] + ":" + streamData[1] + "\">");
                                        buff.append(streamData[0]);
                                        if (streamData[1] == Channel.TYPE_AUDIO_AC3) buff.append(" AC3"); else buff.append(" MPG");
                                        buff.append("</OPTION>\n");
                                    }
                                }
                                buff.append("</SELECT>");
                            }
                            buff.append("</td>\n");
                            buff.append("<td align='center'><input type='checkbox' name='add" + channelCount + "' value='add'></td>\n");
                            buff.append("</tr>\n\n");
                            channelCount++;
                            channelsFound++;
                        } else {
                            break;
                        }
                    }
                    if (channelsFound == 0) {
                        buff.append("<tr class='scanChannelResult'>");
                        buff.append("<td>No Programs Found</td>\n");
                        buff.append("<td align='center'>N/A</td>\n");
                        buff.append("<td align='center'>N/A</td>\n");
                        buff.append("<td align='center'>N/A</td>\n");
                        buff.append("<td align='center'>N/A</td>\n");
                        buff.append("</tr>\n\n");
                    }
                    buff.append("</table><br>\n");
                    outStream.write(buff.toString().getBytes());
                    outStream.flush();
                    outStream.write("\n\n\n\n\n           \n\n\n\n\n\n".getBytes());
                    outStream.flush();
                }
            }
            if (channelCount > 0) out = "<input type=\"submit\" value=\"Add Selected\"></form></body></html><br><br>\n";
            outStream.write(out.getBytes());
            outStream.flush();
        } catch (Exception e) {
            throw e;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1044179.java,73,199
selected,2210714.java,73,199
----------------------------------------
    public void sort(String pColumn, String pSortDirection) {
        boolean up = true;
        if (!"u".equals(pSortDirection)) {
            up = false;
        }
        if ("id".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getId();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("type".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getType();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("principalID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getPrincipalID();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("currencyBookID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            short[] temp = new short[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getCurrencyBookID();
            }
            fSortOrder = sorter.sortShort(temp, fSortOrder, up);
        }
        if ("amount".equals(pColumn)) {
            fComparator = new BigDecimalComparator();
            java.math.BigDecimal[] temp = new java.math.BigDecimal[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getAmount();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("currencyPayID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            short[] temp = new short[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getCurrencyPayID();
            }
            fSortOrder = sorter.sortShort(temp, fSortOrder, up);
        }
        if ("countryID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getCountryID();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("creationDate".equals(pColumn)) {
            fComparator = new DateComparator();
            java.sql.Date[] temp = new java.sql.Date[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getCreationDate();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("dueDate".equals(pColumn)) {
            fComparator = new DateComparator();
            java.sql.Date[] temp = new java.sql.Date[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getDueDate();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("postAccountID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getPostAccountID();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("bankAccountID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getBankAccountID();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("recipientID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getRecipientID();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("beneficiaryID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getBeneficiaryID();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("message4x35".equals(pColumn)) {
            fComparator = new StringComparator();
            String[] temp = new String[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getMessage4x35();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("ordererID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getOrdererID();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        fSortedColumn = pColumn;
    }
----------------------------------------
    public void sort(String pColumn, String pSortDirection) {
        boolean up = true;
        if (!"u".equals(pSortDirection)) {
            up = false;
        }
        if ("id".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getId();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("orderID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getOrderID();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("journalID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getJournalID();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("bookDate".equals(pColumn)) {
            fComparator = new DateComparator();
            java.sql.Date[] temp = new java.sql.Date[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getBookDate();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("valueDate".equals(pColumn)) {
            fComparator = new DateComparator();
            java.sql.Date[] temp = new java.sql.Date[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getValueDate();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("ledgerDebit".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getLedgerDebit();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("amountDebit".equals(pColumn)) {
            fComparator = new BigDecimalComparator();
            java.math.BigDecimal[] temp = new java.math.BigDecimal[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getAmountDebit();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("currencyDebitID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            short[] temp = new short[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getCurrencyDebitID();
            }
            fSortOrder = sorter.sortShort(temp, fSortOrder, up);
        }
        if ("exchangeRateDebit".equals(pColumn)) {
            Sorter sorter = new Sorter();
            double[] temp = new double[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getExchangeRateDebit();
            }
            fSortOrder = sorter.sortDouble(temp, fSortOrder, up);
        }
        if ("amountDebitReal".equals(pColumn)) {
            fComparator = new BigDecimalComparator();
            java.math.BigDecimal[] temp = new java.math.BigDecimal[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getAmountDebitReal();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("ledgerCredit".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getLedgerCredit();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("amountCredit".equals(pColumn)) {
            fComparator = new BigDecimalComparator();
            java.math.BigDecimal[] temp = new java.math.BigDecimal[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getAmountCredit();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("currencyCreditID".equals(pColumn)) {
            Sorter sorter = new Sorter();
            short[] temp = new short[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getCurrencyCreditID();
            }
            fSortOrder = sorter.sortShort(temp, fSortOrder, up);
        }
        if ("exchangeRateCredit".equals(pColumn)) {
            Sorter sorter = new Sorter();
            double[] temp = new double[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getExchangeRateCredit();
            }
            fSortOrder = sorter.sortDouble(temp, fSortOrder, up);
        }
        if ("amountCreditReal".equals(pColumn)) {
            fComparator = new BigDecimalComparator();
            java.math.BigDecimal[] temp = new java.math.BigDecimal[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getAmountCreditReal();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        fSortedColumn = pColumn;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98851.java,114,246
default,98851.java,114,246
----------------------------------------
    public void exec() {
        try {
            sink = new Sink();
            sink.OpenRBNBConnection(address, sinkName);
            plugin = new PlugIn();
            plugin.OpenRBNBConnection(address, pluginName);
        } catch (Exception e) {
            System.err.println("Exception opening RBNB connections, aborting.");
            e.printStackTrace();
            RBNBProcess.exit(0);
        }
        if (!plugin.GetClientName().equals(pluginName)) {
            pluginName = plugin.GetClientName();
            System.err.println("WARNING: The actual PlugIn name is " + pluginName);
        }
        System.err.println("connections open; awaiting requests");
        while (true) {
            PlugInChannelMap picm = null;
            try {
                picm = plugin.Fetch(3000);
                if ((picm.GetIfFetchTimedOut()) || (picm.NumberOfChannels() == 0)) continue;
                System.err.println("\npicm " + picm);
                System.err.println("start " + picm.GetRequestStart() + ", dur " + picm.GetRequestDuration() + ", ref " + picm.GetRequestReference());
                String[] message = null;
                if (picm.GetType(0) == ChannelMap.TYPE_STRING) {
                    message = picm.GetDataAsString(0);
                } else if (picm.GetType(0) == ChannelMap.TYPE_INT8) {
                    message = new String[1];
                    message[0] = new String(picm.GetDataAsInt8(0));
                }
                System.err.println("picm(0) contained message " + message[0]);
                int count = basecount;
                double interval = baseinterval;
                if (message != null && message[0].trim().length() > 0) {
                    message[0] = message[0].trim();
                    char[] term = { '&' };
                    KeyValueHash kvh = new KeyValueHash(message[0], term);
                    String countS = kvh.get("kmlit_count");
                    String intervalS = kvh.get("kmlit_interval");
                    if (countS != null) try {
                        count = Integer.parseInt(countS);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    if (intervalS != null) try {
                        interval = Double.parseDouble(intervalS);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.err.println("message contained count=" + countS + ", interval=" + intervalS);
                    System.err.println("  new count=" + count + ", interval=" + interval);
                }
                ChannelMap cm = new ChannelMap();
                for (int i = 0; i < picm.NumberOfChannels(); i++) cm.Add(picm.GetName(i));
                System.err.println("created cm " + cm);
                if (message != null && message[0].length() > 0) for (int i = 0; i < cm.NumberOfChannels(); i++) cm.PutDataAsString(i, message[0]);
                sink.RequestRegistration(cm);
                cm = sink.Fetch(60000);
                System.err.println("return ChannelMap from fetch:\n" + cm);
                if (cm.GetIfFetchTimedOut()) {
                    System.err.println("timed out making request, returning no data");
                    plugin.Flush(picm);
                    continue;
                }
                if (cm.NumberOfChannels() < 1) {
                    System.err.println("no data on requested channel, returning no data");
                    plugin.Flush(picm);
                    continue;
                }
                System.err.println("cm(0) range " + cm.GetTimeStart(0) + " plus " + cm.GetTimeDuration(0));
                double begin = 0;
                double end = 0;
                double duration = cm.GetTimeDuration(0);
                if (duration > picm.GetRequestDuration()) duration = picm.GetRequestDuration();
                if (picm.GetRequestReference().equals("registration")) {
                    picm.PutTime(cm.GetTimeStart(0), cm.GetTimeDuration(0));
                    picm.PutDataAsInt8(0, new byte[1]);
                    plugin.Flush(picm);
                    continue;
                } else if (picm.GetRequestReference().equals("newest")) {
                    end = cm.GetTimeStart(0) + cm.GetTimeDuration(0);
                    begin = end - duration;
                    System.err.println("newest req, begin=" + begin + ", dur=" + duration + ", end=" + end);
                } else if (picm.GetRequestReference().equals("oldest")) {
                    begin = cm.GetTimeStart(0);
                    end = begin + duration;
                    System.err.println("oldest req, begin=" + begin + ", dur=" + duration + ", end=" + end);
                } else {
                    begin = cm.GetTimeStart(0);
                    if (begin < picm.GetRequestStart()) begin = picm.GetRequestStart();
                    end = begin + duration;
                    double dataend = cm.GetTimeStart(0) + cm.GetTimeDuration(0);
                    double reqend = picm.GetRequestStart() + picm.GetRequestDuration();
                    if (end > dataend) end = dataend;
                    if (end > reqend) end = dataend;
                    duration = end - begin;
                    if (duration < 0) {
                        System.err.println("no data in requested range");
                        plugin.Flush(picm);
                        continue;
                    }
                    System.err.println("absolute req, begin=" + begin + ", dur=" + duration + ", end=" + end);
                }
                System.err.println("count=" + count + ", interval=" + interval);
                if (duration <= 0) count = 1; else if (duration / count < interval) count = (int) Math.round(duration / interval);
                interval = duration / count;
                System.err.println("count=" + count + ", interval=" + interval);
                byte[] zip = buildKMZ(urlBase + picm.GetName(0), begin, end, interval, count, picm.GetName(0));
                if (zip != null) {
                    picm.PutTime(begin, duration);
                    picm.PutDataAsByteArray(0, zip);
                }
                plugin.Flush(picm);
            } catch (Exception e) {
                System.err.println("RBNB exception; returning no data; restarting plugin and sink");
                e.printStackTrace();
                try {
                    if (picm != null) {
                        picm.Clear();
                        plugin.Flush(picm);
                    }
                    sink.CloseRBNBConnection();
                    sink.OpenRBNBConnection(address, sinkName);
                    plugin.CloseRBNBConnection();
                    plugin.OpenRBNBConnection(address, pluginName);
                } catch (Exception e2) {
                    System.err.println("RBNB exception; unable to establish connections; aborting");
                    e2.printStackTrace();
                    break;
                }
            }
        }
    }
----------------------------------------
    public void exec() {
        try {
            sink = new Sink();
            sink.OpenRBNBConnection(address, sinkName);
            plugin = new PlugIn();
            plugin.OpenRBNBConnection(address, pluginName);
        } catch (Exception e) {
            System.err.println("Exception opening RBNB connections, aborting.");
            e.printStackTrace();
            RBNBProcess.exit(0);
        }
        if (!plugin.GetClientName().equals(pluginName)) {
            pluginName = plugin.GetClientName();
            System.err.println("WARNING: The actual PlugIn name is " + pluginName);
        }
        System.err.println("connections open; awaiting requests");
        while (true) {
            PlugInChannelMap picm = null;
            try {
                picm = plugin.Fetch(3000);
                if ((picm.GetIfFetchTimedOut()) || (picm.NumberOfChannels() == 0)) continue;
                System.err.println("\npicm " + picm);
                System.err.println("start " + picm.GetRequestStart() + ", dur " + picm.GetRequestDuration() + ", ref " + picm.GetRequestReference());
                String[] message = null;
                if (picm.GetType(0) == ChannelMap.TYPE_STRING) {
                    message = picm.GetDataAsString(0);
                } else if (picm.GetType(0) == ChannelMap.TYPE_INT8) {
                    message = new String[1];
                    message[0] = new String(picm.GetDataAsInt8(0));
                }
                System.err.println("picm(0) contained message " + message[0]);
                int count = basecount;
                double interval = baseinterval;
                if (message != null && message[0].trim().length() > 0) {
                    message[0] = message[0].trim();
                    char[] term = { '&' };
                    KeyValueHash kvh = new KeyValueHash(message[0], term);
                    String countS = kvh.get("kmlit_count");
                    String intervalS = kvh.get("kmlit_interval");
                    if (countS != null) try {
                        count = Integer.parseInt(countS);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    if (intervalS != null) try {
                        interval = Double.parseDouble(intervalS);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.err.println("message contained count=" + countS + ", interval=" + intervalS);
                    System.err.println("  new count=" + count + ", interval=" + interval);
                }
                ChannelMap cm = new ChannelMap();
                for (int i = 0; i < picm.NumberOfChannels(); i++) cm.Add(picm.GetName(i));
                System.err.println("created cm " + cm);
                if (message != null && message[0].length() > 0) for (int i = 0; i < cm.NumberOfChannels(); i++) cm.PutDataAsString(i, message[0]);
                sink.RequestRegistration(cm);
                cm = sink.Fetch(60000);
                System.err.println("return ChannelMap from fetch:\n" + cm);
                if (cm.GetIfFetchTimedOut()) {
                    System.err.println("timed out making request, returning no data");
                    plugin.Flush(picm);
                    continue;
                }
                if (cm.NumberOfChannels() < 1) {
                    System.err.println("no data on requested channel, returning no data");
                    plugin.Flush(picm);
                    continue;
                }
                System.err.println("cm(0) range " + cm.GetTimeStart(0) + " plus " + cm.GetTimeDuration(0));
                double begin = 0;
                double end = 0;
                double duration = cm.GetTimeDuration(0);
                if (duration > picm.GetRequestDuration()) duration = picm.GetRequestDuration();
                if (picm.GetRequestReference().equals("registration")) {
                    picm.PutTime(cm.GetTimeStart(0), cm.GetTimeDuration(0));
                    picm.PutDataAsInt8(0, new byte[1]);
                    plugin.Flush(picm);
                    continue;
                } else if (picm.GetRequestReference().equals("newest")) {
                    end = cm.GetTimeStart(0) + cm.GetTimeDuration(0);
                    begin = end - duration;
                    System.err.println("newest req, begin=" + begin + ", dur=" + duration + ", end=" + end);
                } else if (picm.GetRequestReference().equals("oldest")) {
                    begin = cm.GetTimeStart(0);
                    end = begin + duration;
                    System.err.println("oldest req, begin=" + begin + ", dur=" + duration + ", end=" + end);
                } else {
                    begin = cm.GetTimeStart(0);
                    if (begin < picm.GetRequestStart()) begin = picm.GetRequestStart();
                    end = begin + duration;
                    double dataend = cm.GetTimeStart(0) + cm.GetTimeDuration(0);
                    double reqend = picm.GetRequestStart() + picm.GetRequestDuration();
                    if (end > dataend) end = dataend;
                    if (end > reqend) end = dataend;
                    duration = end - begin;
                    if (duration < 0) {
                        System.err.println("no data in requested range");
                        plugin.Flush(picm);
                        continue;
                    }
                    System.err.println("absolute req, begin=" + begin + ", dur=" + duration + ", end=" + end);
                }
                System.err.println("count=" + count + ", interval=" + interval);
                if (duration <= 0) count = 1; else if (duration / count < interval) count = (int) Math.round(duration / interval);
                interval = duration / count;
                System.err.println("count=" + count + ", interval=" + interval);
                byte[] zip = buildKMZ(urlBase + picm.GetName(0), begin, end, interval, count, picm.GetName(0));
                if (zip != null) {
                    picm.PutTime(begin, duration);
                    picm.PutDataAsByteArray(0, zip);
                }
                plugin.Flush(picm);
            } catch (Exception e) {
                System.err.println("RBNB exception; returning no data; restarting plugin and sink");
                e.printStackTrace();
                try {
                    if (picm != null) {
                        picm.Clear();
                        plugin.Flush(picm);
                    }
                    sink.CloseRBNBConnection();
                    sink.OpenRBNBConnection(address, sinkName);
                    plugin.CloseRBNBConnection();
                    plugin.OpenRBNBConnection(address, pluginName);
                } catch (Exception e2) {
                    System.err.println("RBNB exception; unable to establish connections; aborting");
                    e2.printStackTrace();
                    break;
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,11981.java,1364,1488
default,60868.java,1364,1488
----------------------------------------
    private byte[] showServerProperties(HTTPurl urlData) throws Exception {
        StringBuffer out = new StringBuffer(1024);
        String value = "";
        HashMap<String, String> options = null;
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>Capture Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("Capture.deftype");
        options = new HashMap<String, String>();
        Vector<CaptureCapability> capabilities = CaptureCapabilities.getInstance().getCapabilities();
        for (int index = 0; index < capabilities.size(); index++) {
            CaptureCapability capability = capabilities.get(index);
            options.put(new Integer(capability.getTypeID()).toString(), capability.getName());
        }
        out.append("<tr><td align='left'>Default Capture Type</td><td>");
        out.append(htmlDropMenu(options, "Capture.deftype", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.deftype');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Capture.path.details");
        out.append("<tr><td align='left'>Capture Details Path</td><td>\n");
        out.append("<input type='text' name='Capture.path.details' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.path.details');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Capture.CaptureFailedTimeout");
        options = new HashMap<String, String>();
        options.put("003", "15 Seconds");
        options.put("006", "30 Seconds");
        options.put("012", "60 Seconds");
        options.put("024", "128 Seconds");
        out.append("<tr><td align='left'>Failed Capture Timeout</td><td>");
        out.append(htmlDropMenu(options, "Capture.CaptureFailedTimeout", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.CaptureFailedTimeout');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>Schedule Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("Schedule.buffer.end");
        out.append("<tr><td align='left'>End Buffer Time</td><td>\n");
        out.append("<input type='text' name='Schedule.buffer.end' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.end');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Schedule.buffer.start");
        out.append("<tr><td align='left'>Start Buffer Time</td><td>\n");
        out.append("<input type='text' name='Schedule.buffer.start' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.start');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Schedule.buffer.end.epg");
        out.append("<tr><td align='left'>End Buffer EPG Addition</td><td>\n");
        out.append("<input type='text' name='Schedule.buffer.end.epg' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.end.epg');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>Email Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("email.server");
        out.append("<tr><td align='left'>Email Server</td><td>\n");
        out.append("<input type='text' name='email.server' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.server');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("email.from");
        out.append("<tr><td align='left'>Email From Address</td><td>\n");
        out.append("<input type='text' name='email.from' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.from');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("email.from.name");
        out.append("<tr><td align='left'>Email From Name</td><td>\n");
        out.append("<input type='text' name='email.from.name' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.from.name');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("email.to");
        out.append("<tr><td align='left'>Email To</td><td>\n");
        out.append("<input type='text' name='email.to' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.to');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>File Browser Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("filebrowser.DirsAtTop");
        options = new HashMap<String, String>();
        options.put("0", "Bottom");
        options.put("1", "Top");
        out.append("<tr><td align='left'>Directories Shown At</td><td>");
        out.append(htmlDropMenu(options, "filebrowser.DirsAtTop", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.DirsAtTop');\" width='24' height='24'></td></tr>\n");
        value = store.getProperty("filebrowser.masks");
        out.append("<tr><td align='left'>Show Extensions</td><td>\n");
        out.append("<input type='text' name='filebrowser.masks' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.masks');\" width='24' height='24'></tr>\n");
        value = store.getProperty("filebrowser.ShowWsPlay");
        options = new HashMap<String, String>();
        options.put("0", "False");
        options.put("1", "True");
        out.append("<tr><td align='left'>Show Play Now Link</td><td>");
        out.append(htmlDropMenu(options, "filebrowser.ShowWsPlay", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.ShowWsPlay');\" width='24' height='24'></td></tr>\n");
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>Server Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("server.kbLED");
        options = new HashMap<String, String>();
        options.put("0", "Disabled");
        options.put("1", "Enabled");
        out.append("<tr><td align='left'>Keyboard LED Control</td><td>");
        out.append(htmlDropMenu(options, "server.kbLED", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('server.kbLED');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Schedule.wake.system");
        out.append("<tr><td align='left'>Seconds for system wake up</td><td>\n");
        out.append("<input type='text' name='Schedule.wake.system' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.wake.system');\" width='24' height='24'></tr>\n");
        value = store.getProperty("AutoDel.KeepFor");
        out.append("<tr><td align='left'>Default keep for</td><td>\n");
        out.append("<input type='text' name='AutoDel.KeepFor' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('AutoDel.KeepFor');\" width='24' height='24'></tr>\n");
        value = store.getProperty("EPG.ShowUnlinked");
        options = new HashMap<String, String>();
        options.put("0", "False");
        options.put("1", "True");
        out.append("<tr><td align='left'>Show Unlinked Schedules</td><td>");
        out.append(htmlDropMenu(options, "EPG.ShowUnlinked", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('EPG.ShowUnlinked');\" width='24' height='24'></tr>\n");
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "serverpropertie.html");
        template.replaceAll("$properties", out.toString());
        return template.getPageBytes();
    }
----------------------------------------
    private byte[] showServerProperties(HTTPurl urlData) throws Exception {
        StringBuffer out = new StringBuffer(1024);
        String value = "";
        HashMap<String, String> options = null;
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>Capture Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("Capture.deftype");
        options = new HashMap<String, String>();
        Vector<CaptureCapability> capabilities = CaptureCapabilities.getInstance().getCapabilities();
        for (int index = 0; index < capabilities.size(); index++) {
            CaptureCapability capability = capabilities.get(index);
            options.put(new Integer(capability.getTypeID()).toString(), capability.getName());
        }
        out.append("<tr><td align='left'>Default Capture Type</td><td>");
        out.append(htmlDropMenu(options, "Capture.deftype", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.deftype');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Capture.path.details");
        out.append("<tr><td align='left'>Capture Details Path</td><td>\n");
        out.append("<input type='text' name='Capture.path.details' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.path.details');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Capture.CaptureFailedTimeout");
        options = new HashMap<String, String>();
        options.put("003", "15 Seconds");
        options.put("006", "30 Seconds");
        options.put("012", "60 Seconds");
        options.put("024", "128 Seconds");
        out.append("<tr><td align='left'>Failed Capture Timeout</td><td>");
        out.append(htmlDropMenu(options, "Capture.CaptureFailedTimeout", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.CaptureFailedTimeout');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>Schedule Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("Schedule.buffer.end");
        out.append("<tr><td align='left'>End Buffer Time</td><td>\n");
        out.append("<input type='text' name='Schedule.buffer.end' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.end');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Schedule.buffer.start");
        out.append("<tr><td align='left'>Start Buffer Time</td><td>\n");
        out.append("<input type='text' name='Schedule.buffer.start' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.start');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Schedule.buffer.end.epg");
        out.append("<tr><td align='left'>End Buffer EPG Addition</td><td>\n");
        out.append("<input type='text' name='Schedule.buffer.end.epg' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.end.epg');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>Email Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("email.server");
        out.append("<tr><td align='left'>Email Server</td><td>\n");
        out.append("<input type='text' name='email.server' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.server');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("email.from");
        out.append("<tr><td align='left'>Email From Address</td><td>\n");
        out.append("<input type='text' name='email.from' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.from');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("email.from.name");
        out.append("<tr><td align='left'>Email From Name</td><td>\n");
        out.append("<input type='text' name='email.from.name' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.from.name');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("email.to");
        out.append("<tr><td align='left'>Email To</td><td>\n");
        out.append("<input type='text' name='email.to' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.to');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>File Browser Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("filebrowser.DirsAtTop");
        options = new HashMap<String, String>();
        options.put("0", "Bottom");
        options.put("1", "Top");
        out.append("<tr><td align='left'>Directories Shown At</td><td>");
        out.append(htmlDropMenu(options, "filebrowser.DirsAtTop", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.DirsAtTop');\" width='24' height='24'></td></tr>\n");
        value = store.getProperty("filebrowser.masks");
        out.append("<tr><td align='left'>Show Extensions</td><td>\n");
        out.append("<input type='text' name='filebrowser.masks' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.masks');\" width='24' height='24'></tr>\n");
        value = store.getProperty("filebrowser.ShowWsPlay");
        options = new HashMap<String, String>();
        options.put("0", "False");
        options.put("1", "True");
        out.append("<tr><td align='left'>Show Play Now Link</td><td>");
        out.append(htmlDropMenu(options, "filebrowser.ShowWsPlay", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.ShowWsPlay');\" width='24' height='24'></td></tr>\n");
        out.append("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
        out.append("<span class='areaTitle'>Server Settings</span>\n");
        out.append("</td></tr>\n");
        value = store.getProperty("server.kbLED");
        options = new HashMap<String, String>();
        options.put("0", "Disabled");
        options.put("1", "Enabled");
        out.append("<tr><td align='left'>Keyboard LED Control</td><td>");
        out.append(htmlDropMenu(options, "server.kbLED", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('server.kbLED');\" width='24' height='24'>");
        out.append("</td></tr>\n");
        value = store.getProperty("Schedule.wake.system");
        out.append("<tr><td align='left'>Seconds for system wake up</td><td>\n");
        out.append("<input type='text' name='Schedule.wake.system' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.wake.system');\" width='24' height='24'></tr>\n");
        value = store.getProperty("AutoDel.KeepFor");
        out.append("<tr><td align='left'>Default keep for</td><td>\n");
        out.append("<input type='text' name='AutoDel.KeepFor' value='" + value + "' size='50'>\n");
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('AutoDel.KeepFor');\" width='24' height='24'></tr>\n");
        value = store.getProperty("EPG.ShowUnlinked");
        options = new HashMap<String, String>();
        options.put("0", "False");
        options.put("1", "True");
        out.append("<tr><td align='left'>Show Unlinked Schedules</td><td>");
        out.append(htmlDropMenu(options, "EPG.ShowUnlinked", value));
        out.append("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('EPG.ShowUnlinked');\" width='24' height='24'></tr>\n");
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "serverpropertie.html");
        template.replaceAll("$properties", out.toString());
        return template.getPageBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115119.java,50,163
default,20292.java,53,166
----------------------------------------
    public static void main(String args[]) throws Exception {
        Class c = Class.forName("tClass");
        System.out.println(c);
        try {
            Class c_not_found = Class.forName("NotAClassSoThrowAnExceptionPlease");
        } catch (ClassNotFoundException e) {
            System.out.println(e);
        }
        if (c.isArray()) System.out.println(c + " is an array????"); else System.out.println(c + " is not an array...good");
        Constructor ctors[] = c.getConstructors();
        Arrays.sort(ctors, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has " + ctors.length + " visible constructors");
        for (int i = 0; i < ctors.length; ++i) System.out.println("   " + i + ": " + ctors[i]);
        Constructor declaredCtors[] = c.getDeclaredConstructors();
        Arrays.sort(declaredCtors, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has " + declaredCtors.length + " declared constructors");
        for (int i = 0; i < declaredCtors.length; ++i) System.out.println("   " + i + ": " + declaredCtors[i]);
        Method methods[] = c.getMethods();
        Method hello = null;
        Method iello = null;
        Method lello = null;
        Method jello = null;
        Method vello = null;
        Method declaredMethods[] = c.getDeclaredMethods();
        Arrays.sort(declaredMethods, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has a total number of methods: " + methods.length);
        for (int i = 0; i < methods.length; i++) {
            if (methods[i].getName().equals("hello")) hello = methods[i];
            if (methods[i].getName().equals("iello")) iello = methods[i];
            if (methods[i].getName().equals("lello")) lello = methods[i];
            if (methods[i].getName().equals("jello")) jello = methods[i];
            if (methods[i].getName().equals("vello")) vello = methods[i];
        }
        System.out.println(" Number of declared methods: " + declaredMethods.length);
        for (int i = 0; i < declaredMethods.length; i++) System.out.println(declaredMethods[i]);
        if (hello == null) {
            System.out.println("tClass.hello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + hello);
        }
        int n_calls = 3;
        while (n_calls-- > 0) {
            String hello_args[] = { "I Say Hello to You!" };
            String result = (String) hello.invoke(null, hello_args);
            System.out.println(result);
        }
        if (iello == null) {
            System.out.println("tClass.iello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + iello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object iello_args[] = { "I Say Iello to You!", new Integer(99) };
            Integer result = (Integer) iello.invoke(null, iello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        if (lello == null) {
            System.out.println("tClass.lello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + lello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object lello_args[] = { "I Say Lello to You!", new Long(99) };
            Long result = (Long) lello.invoke(null, lello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        if (jello == null) {
            System.out.println("tClass.jello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + jello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object jello_args[] = { new Integer(99), "I Say Jello to You!", new Integer(95), new Integer(94) };
            Integer result = (Integer) jello.invoke(null, jello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        tClass tc = new tClass("Hi!");
        String initargs[] = { "I'm dynamic!" };
        tClass tc_dyn = (tClass) ctors[0].newInstance(initargs);
        if (vello == null) {
            System.out.println("tClass.vello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + vello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            String vello_args[] = { "I Say Vello to You!" };
            String result = (String) vello.invoke(tc_dyn, vello_args);
            System.out.println(result);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Class c = Class.forName("tClass");
        System.out.println(c);
        try {
            Class c_not_found = Class.forName("NotAClassSoThrowAnExceptionPlease");
        } catch (ClassNotFoundException e) {
            System.out.println(e);
        }
        if (c.isArray()) System.out.println(c + " is an array????"); else System.out.println(c + " is not an array...good");
        Constructor ctors[] = c.getConstructors();
        Arrays.sort(ctors, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has " + ctors.length + " visible constructors");
        for (int i = 0; i < ctors.length; ++i) System.out.println("   " + i + ": " + ctors[i]);
        Constructor declaredCtors[] = c.getDeclaredConstructors();
        Arrays.sort(declaredCtors, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has " + declaredCtors.length + " declared constructors");
        for (int i = 0; i < declaredCtors.length; ++i) System.out.println("   " + i + ": " + declaredCtors[i]);
        Method methods[] = c.getMethods();
        Method hello = null;
        Method iello = null;
        Method lello = null;
        Method jello = null;
        Method vello = null;
        Method declaredMethods[] = c.getDeclaredMethods();
        Arrays.sort(declaredMethods, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has a total number of methods: " + methods.length);
        for (int i = 0; i < methods.length; i++) {
            if (methods[i].getName().equals("hello")) hello = methods[i];
            if (methods[i].getName().equals("iello")) iello = methods[i];
            if (methods[i].getName().equals("lello")) lello = methods[i];
            if (methods[i].getName().equals("jello")) jello = methods[i];
            if (methods[i].getName().equals("vello")) vello = methods[i];
        }
        System.out.println(" Number of declared methods: " + declaredMethods.length);
        for (int i = 0; i < declaredMethods.length; i++) System.out.println(declaredMethods[i]);
        if (hello == null) {
            System.out.println("tClass.hello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + hello);
        }
        int n_calls = 3;
        while (n_calls-- > 0) {
            String hello_args[] = { "I Say Hello to You!" };
            String result = (String) hello.invoke(null, hello_args);
            System.out.println(result);
        }
        if (iello == null) {
            System.out.println("tClass.iello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + iello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object iello_args[] = { "I Say Iello to You!", new Integer(99) };
            Integer result = (Integer) iello.invoke(null, iello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        if (lello == null) {
            System.out.println("tClass.lello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + lello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object lello_args[] = { "I Say Lello to You!", new Long(99) };
            Long result = (Long) lello.invoke(null, lello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        if (jello == null) {
            System.out.println("tClass.jello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + jello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object jello_args[] = { new Integer(99), "I Say Jello to You!", new Integer(95), new Integer(94) };
            Integer result = (Integer) jello.invoke(null, jello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        tClass tc = new tClass("Hi!");
        String initargs[] = { "I'm dynamic!" };
        tClass tc_dyn = (tClass) ctors[0].newInstance(initargs);
        if (vello == null) {
            System.out.println("tClass.vello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + vello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            String vello_args[] = { "I Say Vello to You!" };
            String result = (String) vello.invoke(tc_dyn, vello_args);
            System.out.println(result);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,136668.java,53,166
default,86699.java,53,166
----------------------------------------
    public static void main(String args[]) throws Exception {
        Class c = Class.forName("tClass");
        System.out.println(c);
        try {
            Class c_not_found = Class.forName("NotAClassSoThrowAnExceptionPlease");
        } catch (ClassNotFoundException e) {
            System.out.println("caught ClassNotFoundException");
        }
        if (c.isArray()) System.out.println(c + " is an array????"); else System.out.println(c + " is not an array...good");
        Constructor ctors[] = c.getConstructors();
        Arrays.sort(ctors, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has " + ctors.length + " visible constructors");
        for (int i = 0; i < ctors.length; ++i) System.out.println("   " + i + ": " + ctors[i]);
        Constructor declaredCtors[] = c.getDeclaredConstructors();
        Arrays.sort(declaredCtors, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has " + declaredCtors.length + " declared constructors");
        for (int i = 0; i < declaredCtors.length; ++i) System.out.println("   " + i + ": " + declaredCtors[i]);
        Method methods[] = c.getMethods();
        Method hello = null;
        Method iello = null;
        Method lello = null;
        Method jello = null;
        Method vello = null;
        Method declaredMethods[] = c.getDeclaredMethods();
        Arrays.sort(declaredMethods, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has a total number of methods: " + methods.length);
        for (int i = 0; i < methods.length; i++) {
            if (methods[i].getName().equals("hello")) hello = methods[i];
            if (methods[i].getName().equals("iello")) iello = methods[i];
            if (methods[i].getName().equals("lello")) lello = methods[i];
            if (methods[i].getName().equals("jello")) jello = methods[i];
            if (methods[i].getName().equals("vello")) vello = methods[i];
        }
        System.out.println(" Number of declared methods: " + declaredMethods.length);
        for (int i = 0; i < declaredMethods.length; i++) System.out.println(declaredMethods[i]);
        if (hello == null) {
            System.out.println("tClass.hello not found!");
            System.exit(1);
        } else {
            System.out.println("================= READY TO CALL: " + hello);
        }
        int n_calls = 3;
        while (n_calls-- > 0) {
            String hello_args[] = { "I Say Hello to You!" };
            String result = (String) hello.invoke(null, hello_args);
            System.out.println(result);
        }
        if (iello == null) {
            System.out.println("tClass.iello not found!");
            System.exit(1);
        } else {
            System.out.println("================= READY TO CALL: " + iello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object iello_args[] = { "I Say Iello to You!", new Integer(99) };
            Integer result = (Integer) iello.invoke(null, iello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        if (lello == null) {
            System.out.println("tClass.lello not found!");
            System.exit(1);
        } else {
            System.out.println("================= READY TO CALL: " + lello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object lello_args[] = { "I Say Lello to You!", new Long(99) };
            Long result = (Long) lello.invoke(null, lello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        if (jello == null) {
            System.out.println("tClass.jello not found!");
            System.exit(1);
        } else {
            System.out.println("================= READY TO CALL: " + jello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object jello_args[] = { new Integer(99), "I Say Jello to You!", new Integer(95), new Integer(94) };
            Integer result = (Integer) jello.invoke(null, jello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        tClass tc = new tClass("Hi!");
        String initargs[] = { "I'm dynamic!" };
        tClass tc_dyn = (tClass) ctors[0].newInstance(initargs);
        if (vello == null) {
            System.out.println("tClass.vello not found!");
            System.exit(1);
        } else {
            System.out.println("================= READY TO CALL: " + vello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            String vello_args[] = { "I Say Vello to You!" };
            String result = (String) vello.invoke(tc_dyn, vello_args);
            System.out.println(result);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Class c = Class.forName("tClass");
        System.out.println(c);
        try {
            Class c_not_found = Class.forName("NotAClassSoThrowAnExceptionPlease");
        } catch (ClassNotFoundException e) {
            System.out.println("caught ClassNotFoundException");
        }
        if (c.isArray()) System.out.println(c + " is an array????"); else System.out.println(c + " is not an array...good");
        Constructor ctors[] = c.getConstructors();
        Arrays.sort(ctors, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has " + ctors.length + " visible constructors");
        for (int i = 0; i < ctors.length; ++i) System.out.println("   " + i + ": " + ctors[i]);
        Constructor declaredCtors[] = c.getDeclaredConstructors();
        Arrays.sort(declaredCtors, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has " + declaredCtors.length + " declared constructors");
        for (int i = 0; i < declaredCtors.length; ++i) System.out.println("   " + i + ": " + declaredCtors[i]);
        Method methods[] = c.getMethods();
        Method hello = null;
        Method iello = null;
        Method lello = null;
        Method jello = null;
        Method vello = null;
        Method declaredMethods[] = c.getDeclaredMethods();
        Arrays.sort(declaredMethods, new Comparator() {

            public int compare(Object x, Object y) {
                return x.toString().compareTo(y.toString());
            }
        });
        System.out.println(c + " has a total number of methods: " + methods.length);
        for (int i = 0; i < methods.length; i++) {
            if (methods[i].getName().equals("hello")) hello = methods[i];
            if (methods[i].getName().equals("iello")) iello = methods[i];
            if (methods[i].getName().equals("lello")) lello = methods[i];
            if (methods[i].getName().equals("jello")) jello = methods[i];
            if (methods[i].getName().equals("vello")) vello = methods[i];
        }
        System.out.println(" Number of declared methods: " + declaredMethods.length);
        for (int i = 0; i < declaredMethods.length; i++) System.out.println(declaredMethods[i]);
        if (hello == null) {
            System.out.println("tClass.hello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + hello);
        }
        int n_calls = 3;
        while (n_calls-- > 0) {
            String hello_args[] = { "I Say Hello to You!" };
            String result = (String) hello.invoke(null, hello_args);
            System.out.println(result);
        }
        if (iello == null) {
            System.out.println("tClass.iello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + iello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object iello_args[] = { "I Say Iello to You!", new Integer(99) };
            Integer result = (Integer) iello.invoke(null, iello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        if (lello == null) {
            System.out.println("tClass.lello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + lello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object lello_args[] = { "I Say Lello to You!", new Long(99) };
            Long result = (Long) lello.invoke(null, lello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        if (jello == null) {
            System.out.println("tClass.jello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + jello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            Object jello_args[] = { new Integer(99), "I Say Jello to You!", new Integer(95), new Integer(94) };
            Integer result = (Integer) jello.invoke(null, jello_args);
            System.out.println("Does this>" + result + "< look like 99?");
        }
        tClass tc = new tClass("Hi!");
        String initargs[] = { "I'm dynamic!" };
        tClass tc_dyn = (tClass) ctors[0].newInstance(initargs);
        if (vello == null) {
            System.out.println("tClass.vello not found!");
            System.exit(-1);
        } else {
            System.out.println("================= READY TO CALL: " + vello);
        }
        n_calls = 3;
        while (n_calls-- > 0) {
            String vello_args[] = { "I Say Vello to You!" };
            String result = (String) vello.invoke(tc_dyn, vello_args);
            System.out.println(result);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,552391.java,28,154
selected,2351844.java,28,154
----------------------------------------
    public org.omg.CORBA.portable.OutputStream _invoke(String $method, org.omg.CORBA.portable.InputStream in, org.omg.CORBA.portable.ResponseHandler $rh) {
        org.omg.CORBA.portable.OutputStream out = null;
        java.lang.Integer __method = (java.lang.Integer) _methods.get($method);
        if (__method == null) throw new org.omg.CORBA.BAD_OPERATION(0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
        switch(__method.intValue()) {
            case 0:
                {
                    try {
                        com.sun.corba.se.PortableActivationIDL.RepositoryPackage.ServerDef serverDef = com.sun.corba.se.PortableActivationIDL.RepositoryPackage.ServerDefHelper.read(in);
                        String $result = null;
                        $result = this.registerServer(serverDef);
                        out = $rh.createReply();
                        out.write_string($result);
                    } catch (com.sun.corba.se.PortableActivationIDL.ServerAlreadyRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.ServerAlreadyRegisteredHelper.write(out, $ex);
                    } catch (com.sun.corba.se.PortableActivationIDL.BadServerDefinition $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.BadServerDefinitionHelper.write(out, $ex);
                    }
                    break;
                }
            case 1:
                {
                    try {
                        String serverId = org.omg.PortableInterceptor.ServerIdHelper.read(in);
                        this.unregisterServer(serverId);
                        out = $rh.createReply();
                    } catch (com.sun.corba.se.PortableActivationIDL.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.ServerNotRegisteredHelper.write(out, $ex);
                    }
                    break;
                }
            case 2:
                {
                    try {
                        String serverId = org.omg.PortableInterceptor.ServerIdHelper.read(in);
                        com.sun.corba.se.PortableActivationIDL.RepositoryPackage.ServerDef $result = null;
                        $result = this.getServer(serverId);
                        out = $rh.createReply();
                        com.sun.corba.se.PortableActivationIDL.RepositoryPackage.ServerDefHelper.write(out, $result);
                    } catch (com.sun.corba.se.PortableActivationIDL.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.ServerNotRegisteredHelper.write(out, $ex);
                    }
                    break;
                }
            case 3:
                {
                    try {
                        String serverId = org.omg.PortableInterceptor.ServerIdHelper.read(in);
                        boolean $result = false;
                        $result = this.isInstalled(serverId);
                        out = $rh.createReply();
                        out.write_boolean($result);
                    } catch (com.sun.corba.se.PortableActivationIDL.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.ServerNotRegisteredHelper.write(out, $ex);
                    }
                    break;
                }
            case 4:
                {
                    try {
                        String serverId = org.omg.PortableInterceptor.ServerIdHelper.read(in);
                        this.install(serverId);
                        out = $rh.createReply();
                    } catch (com.sun.corba.se.PortableActivationIDL.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.ServerNotRegisteredHelper.write(out, $ex);
                    } catch (com.sun.corba.se.PortableActivationIDL.ServerAlreadyInstalled $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.ServerAlreadyInstalledHelper.write(out, $ex);
                    }
                    break;
                }
            case 5:
                {
                    try {
                        String serverId = org.omg.PortableInterceptor.ServerIdHelper.read(in);
                        this.uninstall(serverId);
                        out = $rh.createReply();
                    } catch (com.sun.corba.se.PortableActivationIDL.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.ServerNotRegisteredHelper.write(out, $ex);
                    } catch (com.sun.corba.se.PortableActivationIDL.ServerAlreadyUninstalled $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.ServerAlreadyUninstalledHelper.write(out, $ex);
                    }
                    break;
                }
            case 6:
                {
                    String $result[] = null;
                    $result = this.listRegisteredServers();
                    out = $rh.createReply();
                    com.sun.corba.se.PortableActivationIDL.ServerIdsHelper.write(out, $result);
                    break;
                }
            case 7:
                {
                    String $result[] = null;
                    $result = this.getApplicationNames();
                    out = $rh.createReply();
                    com.sun.corba.se.PortableActivationIDL.RepositoryPackage.AppNamesHelper.write(out, $result);
                    break;
                }
            case 8:
                {
                    try {
                        String applicationName = in.read_string();
                        String $result = null;
                        $result = this.getServerID(applicationName);
                        out = $rh.createReply();
                        out.write_string($result);
                    } catch (com.sun.corba.se.PortableActivationIDL.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.PortableActivationIDL.ServerNotRegisteredHelper.write(out, $ex);
                    }
                    break;
                }
            default:
                throw new org.omg.CORBA.BAD_OPERATION(0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
        }
        return out;
    }
----------------------------------------
    public org.omg.CORBA.portable.OutputStream _invoke(String $method, org.omg.CORBA.portable.InputStream in, org.omg.CORBA.portable.ResponseHandler $rh) {
        org.omg.CORBA.portable.OutputStream out = null;
        java.lang.Integer __method = (java.lang.Integer) _methods.get($method);
        if (__method == null) throw new org.omg.CORBA.BAD_OPERATION(0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
        switch(__method.intValue()) {
            case 0:
                {
                    try {
                        com.sun.corba.se.spi.activation.RepositoryPackage.ServerDef serverDef = com.sun.corba.se.spi.activation.RepositoryPackage.ServerDefHelper.read(in);
                        int $result = (int) 0;
                        $result = this.registerServer(serverDef);
                        out = $rh.createReply();
                        out.write_long($result);
                    } catch (com.sun.corba.se.spi.activation.ServerAlreadyRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.ServerAlreadyRegisteredHelper.write(out, $ex);
                    } catch (com.sun.corba.se.spi.activation.BadServerDefinition $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.BadServerDefinitionHelper.write(out, $ex);
                    }
                    break;
                }
            case 1:
                {
                    try {
                        int serverId = com.sun.corba.se.spi.activation.ServerIdHelper.read(in);
                        this.unregisterServer(serverId);
                        out = $rh.createReply();
                    } catch (com.sun.corba.se.spi.activation.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.ServerNotRegisteredHelper.write(out, $ex);
                    }
                    break;
                }
            case 2:
                {
                    try {
                        int serverId = com.sun.corba.se.spi.activation.ServerIdHelper.read(in);
                        com.sun.corba.se.spi.activation.RepositoryPackage.ServerDef $result = null;
                        $result = this.getServer(serverId);
                        out = $rh.createReply();
                        com.sun.corba.se.spi.activation.RepositoryPackage.ServerDefHelper.write(out, $result);
                    } catch (com.sun.corba.se.spi.activation.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.ServerNotRegisteredHelper.write(out, $ex);
                    }
                    break;
                }
            case 3:
                {
                    try {
                        int serverId = com.sun.corba.se.spi.activation.ServerIdHelper.read(in);
                        boolean $result = false;
                        $result = this.isInstalled(serverId);
                        out = $rh.createReply();
                        out.write_boolean($result);
                    } catch (com.sun.corba.se.spi.activation.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.ServerNotRegisteredHelper.write(out, $ex);
                    }
                    break;
                }
            case 4:
                {
                    try {
                        int serverId = com.sun.corba.se.spi.activation.ServerIdHelper.read(in);
                        this.install(serverId);
                        out = $rh.createReply();
                    } catch (com.sun.corba.se.spi.activation.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.ServerNotRegisteredHelper.write(out, $ex);
                    } catch (com.sun.corba.se.spi.activation.ServerAlreadyInstalled $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.ServerAlreadyInstalledHelper.write(out, $ex);
                    }
                    break;
                }
            case 5:
                {
                    try {
                        int serverId = com.sun.corba.se.spi.activation.ServerIdHelper.read(in);
                        this.uninstall(serverId);
                        out = $rh.createReply();
                    } catch (com.sun.corba.se.spi.activation.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.ServerNotRegisteredHelper.write(out, $ex);
                    } catch (com.sun.corba.se.spi.activation.ServerAlreadyUninstalled $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.ServerAlreadyUninstalledHelper.write(out, $ex);
                    }
                    break;
                }
            case 6:
                {
                    int $result[] = null;
                    $result = this.listRegisteredServers();
                    out = $rh.createReply();
                    com.sun.corba.se.spi.activation.ServerIdsHelper.write(out, $result);
                    break;
                }
            case 7:
                {
                    String $result[] = null;
                    $result = this.getApplicationNames();
                    out = $rh.createReply();
                    com.sun.corba.se.spi.activation.RepositoryPackage.StringSeqHelper.write(out, $result);
                    break;
                }
            case 8:
                {
                    try {
                        String applicationName = in.read_string();
                        int $result = (int) 0;
                        $result = this.getServerID(applicationName);
                        out = $rh.createReply();
                        out.write_long($result);
                    } catch (com.sun.corba.se.spi.activation.ServerNotRegistered $ex) {
                        out = $rh.createExceptionReply();
                        com.sun.corba.se.spi.activation.ServerNotRegisteredHelper.write(out, $ex);
                    }
                    break;
                }
            default:
                throw new org.omg.CORBA.BAD_OPERATION(0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
        }
        return out;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2552304.java,1003,1114
selected,1059992.java,982,1093
----------------------------------------
    protected Pool loadHMMPool(boolean useCDUnits, InputStream inputStream, String path) throws FileNotFoundException, IOException {
        int token_type;
        int numBase;
        int numTri;
        int numStateMap;
        int numTiedState;
        int numStatePerHMM;
        int numContextIndependentTiedState;
        int numTiedTransitionMatrices;
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading HMM file from: " + path);
        est.expectString(MODEL_VERSION);
        numBase = est.getInt("numBase");
        est.expectString("n_base");
        numTri = est.getInt("numTri");
        est.expectString("n_tri");
        numStateMap = est.getInt("numStateMap");
        est.expectString("n_state_map");
        numTiedState = est.getInt("numTiedState");
        est.expectString("n_tied_state");
        numContextIndependentTiedState = est.getInt("numContextIndependentTiedState");
        est.expectString("n_tied_ci_state");
        numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
        est.expectString("n_tied_tmat");
        numStatePerHMM = numStateMap / (numTri + numBase);
        assert numTiedState == mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        assert numTiedTransitionMatrices == matrixPool.size();
        for (int i = 0; i < numBase; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= 0 && stid[j] < numContextIndependentTiedState;
            }
            est.expectString("N");
            assert left.equals("-");
            assert right.equals("-");
            assert position.equals("-");
            assert tmat < numTiedTransitionMatrices;
            Unit unit = unitManager.getUnit(name, attribute.equals(FILLER));
            contextIndependentUnits.put(unit.getName(), unit);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine("Loaded " + unit);
            }
            if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
                unit = UnitManager.SILENCE;
            }
            float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
            SenoneSequence ss = getSenoneSequence(stid);
            HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
            hmmManager.put(hmm);
        }
        String lastUnitName = "";
        Unit lastUnit = null;
        int[] lastStid = null;
        SenoneSequence lastSenoneSequence = null;
        for (int i = 0; i < numTri; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= numContextIndependentTiedState && stid[j] < numTiedState;
            }
            est.expectString("N");
            assert !left.equals("-");
            assert !right.equals("-");
            assert !position.equals("-");
            assert attribute.equals("n/a");
            assert tmat < numTiedTransitionMatrices;
            if (useCDUnits) {
                Unit unit = null;
                String unitName = (name + " " + left + " " + right);
                if (unitName.equals(lastUnitName)) {
                    unit = lastUnit;
                } else {
                    Unit[] leftContext = new Unit[1];
                    leftContext[0] = (Unit) contextIndependentUnits.get(left);
                    Unit[] rightContext = new Unit[1];
                    rightContext[0] = (Unit) contextIndependentUnits.get(right);
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    unit = unitManager.getUnit(name, false, context);
                }
                lastUnitName = unitName;
                lastUnit = unit;
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine("Loaded " + unit);
                }
                float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
                SenoneSequence ss = lastSenoneSequence;
                if (ss == null || !sameSenoneSequence(stid, lastStid)) {
                    ss = getSenoneSequence(stid);
                }
                lastSenoneSequence = ss;
                lastStid = stid;
                HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
                hmmManager.put(hmm);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
    protected Pool loadHMMPool(boolean useCDUnits, InputStream inputStream, String path) throws FileNotFoundException, IOException {
        int token_type;
        int numBase;
        int numTri;
        int numStateMap;
        int numTiedState;
        int numStatePerHMM;
        int numContextIndependentTiedState;
        int numTiedTransitionMatrices;
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading HMM file from: " + path);
        est.expectString(MODEL_VERSION);
        numBase = est.getInt("numBase");
        est.expectString("n_base");
        numTri = est.getInt("numTri");
        est.expectString("n_tri");
        numStateMap = est.getInt("numStateMap");
        est.expectString("n_state_map");
        numTiedState = est.getInt("numTiedState");
        est.expectString("n_tied_state");
        numContextIndependentTiedState = est.getInt("numContextIndependentTiedState");
        est.expectString("n_tied_ci_state");
        numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
        est.expectString("n_tied_tmat");
        numStatePerHMM = numStateMap / (numTri + numBase);
        assert numTiedState == mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        assert numTiedTransitionMatrices == matrixPool.size();
        for (int i = 0; i < numBase; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= 0 && stid[j] < numContextIndependentTiedState;
            }
            est.expectString("N");
            assert left.equals("-");
            assert right.equals("-");
            assert position.equals("-");
            assert tmat < numTiedTransitionMatrices;
            Unit unit = unitManager.getUnit(name, attribute.equals(FILLER));
            contextIndependentUnits.put(unit.getName(), unit);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine("Loaded " + unit);
            }
            if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
                unit = UnitManager.SILENCE;
            }
            float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
            SenoneSequence ss = getSenoneSequence(stid);
            HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
            hmmManager.put(hmm);
        }
        String lastUnitName = "";
        Unit lastUnit = null;
        int[] lastStid = null;
        SenoneSequence lastSenoneSequence = null;
        for (int i = 0; i < numTri; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= numContextIndependentTiedState && stid[j] < numTiedState;
            }
            est.expectString("N");
            assert !left.equals("-");
            assert !right.equals("-");
            assert !position.equals("-");
            assert attribute.equals("n/a");
            assert tmat < numTiedTransitionMatrices;
            if (useCDUnits) {
                Unit unit = null;
                String unitName = (name + " " + left + " " + right);
                if (unitName.equals(lastUnitName)) {
                    unit = lastUnit;
                } else {
                    Unit[] leftContext = new Unit[1];
                    leftContext[0] = (Unit) contextIndependentUnits.get(left);
                    Unit[] rightContext = new Unit[1];
                    rightContext[0] = (Unit) contextIndependentUnits.get(right);
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    unit = unitManager.getUnit(name, false, context);
                }
                lastUnitName = unitName;
                lastUnit = unit;
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine("Loaded " + unit);
                }
                float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
                SenoneSequence ss = lastSenoneSequence;
                if (ss == null || !sameSenoneSequence(stid, lastStid)) {
                    ss = getSenoneSequence(stid);
                }
                lastSenoneSequence = ss;
                lastStid = stid;
                HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
                hmmManager.put(hmm);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1664613.java,982,1093
selected,2275689.java,1003,1114
----------------------------------------
    protected Pool loadHMMPool(boolean useCDUnits, InputStream inputStream, String path) throws FileNotFoundException, IOException {
        int token_type;
        int numBase;
        int numTri;
        int numStateMap;
        int numTiedState;
        int numStatePerHMM;
        int numContextIndependentTiedState;
        int numTiedTransitionMatrices;
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading HMM file from: " + path);
        est.expectString(MODEL_VERSION);
        numBase = est.getInt("numBase");
        est.expectString("n_base");
        numTri = est.getInt("numTri");
        est.expectString("n_tri");
        numStateMap = est.getInt("numStateMap");
        est.expectString("n_state_map");
        numTiedState = est.getInt("numTiedState");
        est.expectString("n_tied_state");
        numContextIndependentTiedState = est.getInt("numContextIndependentTiedState");
        est.expectString("n_tied_ci_state");
        numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
        est.expectString("n_tied_tmat");
        numStatePerHMM = numStateMap / (numTri + numBase);
        assert numTiedState == mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        assert numTiedTransitionMatrices == matrixPool.size();
        for (int i = 0; i < numBase; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= 0 && stid[j] < numContextIndependentTiedState;
            }
            est.expectString("N");
            assert left.equals("-");
            assert right.equals("-");
            assert position.equals("-");
            assert tmat < numTiedTransitionMatrices;
            Unit unit = unitManager.getUnit(name, attribute.equals(FILLER));
            contextIndependentUnits.put(unit.getName(), unit);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine("Loaded " + unit);
            }
            if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
                unit = UnitManager.SILENCE;
            }
            float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
            SenoneSequence ss = getSenoneSequence(stid);
            HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
            hmmManager.put(hmm);
        }
        String lastUnitName = "";
        Unit lastUnit = null;
        int[] lastStid = null;
        SenoneSequence lastSenoneSequence = null;
        for (int i = 0; i < numTri; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= numContextIndependentTiedState && stid[j] < numTiedState;
            }
            est.expectString("N");
            assert !left.equals("-");
            assert !right.equals("-");
            assert !position.equals("-");
            assert attribute.equals("n/a");
            assert tmat < numTiedTransitionMatrices;
            if (useCDUnits) {
                Unit unit = null;
                String unitName = (name + " " + left + " " + right);
                if (unitName.equals(lastUnitName)) {
                    unit = lastUnit;
                } else {
                    Unit[] leftContext = new Unit[1];
                    leftContext[0] = (Unit) contextIndependentUnits.get(left);
                    Unit[] rightContext = new Unit[1];
                    rightContext[0] = (Unit) contextIndependentUnits.get(right);
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    unit = unitManager.getUnit(name, false, context);
                }
                lastUnitName = unitName;
                lastUnit = unit;
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine("Loaded " + unit);
                }
                float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
                SenoneSequence ss = lastSenoneSequence;
                if (ss == null || !sameSenoneSequence(stid, lastStid)) {
                    ss = getSenoneSequence(stid);
                }
                lastSenoneSequence = ss;
                lastStid = stid;
                HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
                hmmManager.put(hmm);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
    protected Pool loadHMMPool(boolean useCDUnits, InputStream inputStream, String path) throws FileNotFoundException, IOException {
        int token_type;
        int numBase;
        int numTri;
        int numStateMap;
        int numTiedState;
        int numStatePerHMM;
        int numContextIndependentTiedState;
        int numTiedTransitionMatrices;
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading HMM file from: " + path);
        est.expectString(MODEL_VERSION);
        numBase = est.getInt("numBase");
        est.expectString("n_base");
        numTri = est.getInt("numTri");
        est.expectString("n_tri");
        numStateMap = est.getInt("numStateMap");
        est.expectString("n_state_map");
        numTiedState = est.getInt("numTiedState");
        est.expectString("n_tied_state");
        numContextIndependentTiedState = est.getInt("numContextIndependentTiedState");
        est.expectString("n_tied_ci_state");
        numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
        est.expectString("n_tied_tmat");
        numStatePerHMM = numStateMap / (numTri + numBase);
        assert numTiedState == mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        assert numTiedTransitionMatrices == matrixPool.size();
        for (int i = 0; i < numBase; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= 0 && stid[j] < numContextIndependentTiedState;
            }
            est.expectString("N");
            assert left.equals("-");
            assert right.equals("-");
            assert position.equals("-");
            assert tmat < numTiedTransitionMatrices;
            Unit unit = unitManager.getUnit(name, attribute.equals(FILLER));
            contextIndependentUnits.put(unit.getName(), unit);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine("Loaded " + unit);
            }
            if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
                unit = UnitManager.SILENCE;
            }
            float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
            SenoneSequence ss = getSenoneSequence(stid);
            HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
            hmmManager.put(hmm);
        }
        String lastUnitName = "";
        Unit lastUnit = null;
        int[] lastStid = null;
        SenoneSequence lastSenoneSequence = null;
        for (int i = 0; i < numTri; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= numContextIndependentTiedState && stid[j] < numTiedState;
            }
            est.expectString("N");
            assert !left.equals("-");
            assert !right.equals("-");
            assert !position.equals("-");
            assert attribute.equals("n/a");
            assert tmat < numTiedTransitionMatrices;
            if (useCDUnits) {
                Unit unit = null;
                String unitName = (name + " " + left + " " + right);
                if (unitName.equals(lastUnitName)) {
                    unit = lastUnit;
                } else {
                    Unit[] leftContext = new Unit[1];
                    leftContext[0] = (Unit) contextIndependentUnits.get(left);
                    Unit[] rightContext = new Unit[1];
                    rightContext[0] = (Unit) contextIndependentUnits.get(right);
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    unit = unitManager.getUnit(name, false, context);
                }
                lastUnitName = unitName;
                lastUnit = unit;
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine("Loaded " + unit);
                }
                float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
                SenoneSequence ss = lastSenoneSequence;
                if (ss == null || !sameSenoneSequence(stid, lastStid)) {
                    ss = getSenoneSequence(stid);
                }
                lastSenoneSequence = ss;
                lastStid = stid;
                HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
                hmmManager.put(hmm);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,186786.java,982,1093
selected,2720826.java,982,1093
----------------------------------------
    protected Pool loadHMMPool(boolean useCDUnits, InputStream inputStream, String path) throws FileNotFoundException, IOException {
        int token_type;
        int numBase;
        int numTri;
        int numStateMap;
        int numTiedState;
        int numStatePerHMM;
        int numContextIndependentTiedState;
        int numTiedTransitionMatrices;
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading HMM file from: " + path);
        est.expectString(MODEL_VERSION);
        numBase = est.getInt("numBase");
        est.expectString("n_base");
        numTri = est.getInt("numTri");
        est.expectString("n_tri");
        numStateMap = est.getInt("numStateMap");
        est.expectString("n_state_map");
        numTiedState = est.getInt("numTiedState");
        est.expectString("n_tied_state");
        numContextIndependentTiedState = est.getInt("numContextIndependentTiedState");
        est.expectString("n_tied_ci_state");
        numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
        est.expectString("n_tied_tmat");
        numStatePerHMM = numStateMap / (numTri + numBase);
        assert numTiedState == mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        assert numTiedTransitionMatrices == matrixPool.size();
        for (int i = 0; i < numBase; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= 0 && stid[j] < numContextIndependentTiedState;
            }
            est.expectString("N");
            assert left.equals("-");
            assert right.equals("-");
            assert position.equals("-");
            assert tmat < numTiedTransitionMatrices;
            Unit unit = unitManager.getUnit(name, attribute.equals(FILLER));
            contextIndependentUnits.put(unit.getName(), unit);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine("Loaded " + unit);
            }
            if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
                unit = UnitManager.SILENCE;
            }
            float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
            SenoneSequence ss = getSenoneSequence(stid);
            HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
            hmmManager.put(hmm);
        }
        String lastUnitName = "";
        Unit lastUnit = null;
        int[] lastStid = null;
        SenoneSequence lastSenoneSequence = null;
        for (int i = 0; i < numTri; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= numContextIndependentTiedState && stid[j] < numTiedState;
            }
            est.expectString("N");
            assert !left.equals("-");
            assert !right.equals("-");
            assert !position.equals("-");
            assert attribute.equals("n/a");
            assert tmat < numTiedTransitionMatrices;
            if (useCDUnits) {
                Unit unit = null;
                String unitName = (name + " " + left + " " + right);
                if (unitName.equals(lastUnitName)) {
                    unit = lastUnit;
                } else {
                    Unit[] leftContext = new Unit[1];
                    leftContext[0] = (Unit) contextIndependentUnits.get(left);
                    Unit[] rightContext = new Unit[1];
                    rightContext[0] = (Unit) contextIndependentUnits.get(right);
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    unit = unitManager.getUnit(name, false, context);
                }
                lastUnitName = unitName;
                lastUnit = unit;
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine("Loaded " + unit);
                }
                float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
                SenoneSequence ss = lastSenoneSequence;
                if (ss == null || !sameSenoneSequence(stid, lastStid)) {
                    ss = getSenoneSequence(stid);
                }
                lastSenoneSequence = ss;
                lastStid = stid;
                HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
                hmmManager.put(hmm);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
    protected Pool loadHMMPool(boolean useCDUnits, InputStream inputStream, String path) throws FileNotFoundException, IOException {
        int token_type;
        int numBase;
        int numTri;
        int numStateMap;
        int numTiedState;
        int numStatePerHMM;
        int numContextIndependentTiedState;
        int numTiedTransitionMatrices;
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading HMM file from: " + path);
        est.expectString(MODEL_VERSION);
        numBase = est.getInt("numBase");
        est.expectString("n_base");
        numTri = est.getInt("numTri");
        est.expectString("n_tri");
        numStateMap = est.getInt("numStateMap");
        est.expectString("n_state_map");
        numTiedState = est.getInt("numTiedState");
        est.expectString("n_tied_state");
        numContextIndependentTiedState = est.getInt("numContextIndependentTiedState");
        est.expectString("n_tied_ci_state");
        numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
        est.expectString("n_tied_tmat");
        numStatePerHMM = numStateMap / (numTri + numBase);
        assert numTiedState == mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        assert numTiedTransitionMatrices == matrixPool.size();
        for (int i = 0; i < numBase; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= 0 && stid[j] < numContextIndependentTiedState;
            }
            est.expectString("N");
            assert left.equals("-");
            assert right.equals("-");
            assert position.equals("-");
            assert tmat < numTiedTransitionMatrices;
            Unit unit = unitManager.getUnit(name, attribute.equals(FILLER));
            contextIndependentUnits.put(unit.getName(), unit);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine("Loaded " + unit);
            }
            if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
                unit = UnitManager.SILENCE;
            }
            float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
            SenoneSequence ss = getSenoneSequence(stid);
            HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
            hmmManager.put(hmm);
        }
        String lastUnitName = "";
        Unit lastUnit = null;
        int[] lastStid = null;
        SenoneSequence lastSenoneSequence = null;
        for (int i = 0; i < numTri; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= numContextIndependentTiedState && stid[j] < numTiedState;
            }
            est.expectString("N");
            assert !left.equals("-");
            assert !right.equals("-");
            assert !position.equals("-");
            assert attribute.equals("n/a");
            assert tmat < numTiedTransitionMatrices;
            if (useCDUnits) {
                Unit unit = null;
                String unitName = (name + " " + left + " " + right);
                if (unitName.equals(lastUnitName)) {
                    unit = lastUnit;
                } else {
                    Unit[] leftContext = new Unit[1];
                    leftContext[0] = (Unit) contextIndependentUnits.get(left);
                    Unit[] rightContext = new Unit[1];
                    rightContext[0] = (Unit) contextIndependentUnits.get(right);
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    unit = unitManager.getUnit(name, false, context);
                }
                lastUnitName = unitName;
                lastUnit = unit;
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine("Loaded " + unit);
                }
                float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
                SenoneSequence ss = lastSenoneSequence;
                if (ss == null || !sameSenoneSequence(stid, lastStid)) {
                    ss = getSenoneSequence(stid);
                }
                lastSenoneSequence = ss;
                lastStid = stid;
                HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
                hmmManager.put(hmm);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,356074.java,982,1093
selected,1473439.java,1003,1114
----------------------------------------
    protected Pool loadHMMPool(boolean useCDUnits, InputStream inputStream, String path) throws FileNotFoundException, IOException {
        int token_type;
        int numBase;
        int numTri;
        int numStateMap;
        int numTiedState;
        int numStatePerHMM;
        int numContextIndependentTiedState;
        int numTiedTransitionMatrices;
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading HMM file from: " + path);
        est.expectString(MODEL_VERSION);
        numBase = est.getInt("numBase");
        est.expectString("n_base");
        numTri = est.getInt("numTri");
        est.expectString("n_tri");
        numStateMap = est.getInt("numStateMap");
        est.expectString("n_state_map");
        numTiedState = est.getInt("numTiedState");
        est.expectString("n_tied_state");
        numContextIndependentTiedState = est.getInt("numContextIndependentTiedState");
        est.expectString("n_tied_ci_state");
        numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
        est.expectString("n_tied_tmat");
        numStatePerHMM = numStateMap / (numTri + numBase);
        assert numTiedState == mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        assert numTiedTransitionMatrices == matrixPool.size();
        for (int i = 0; i < numBase; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= 0 && stid[j] < numContextIndependentTiedState;
            }
            est.expectString("N");
            assert left.equals("-");
            assert right.equals("-");
            assert position.equals("-");
            assert tmat < numTiedTransitionMatrices;
            Unit unit = unitManager.getUnit(name, attribute.equals(FILLER));
            contextIndependentUnits.put(unit.getName(), unit);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine("Loaded " + unit);
            }
            if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
                unit = UnitManager.SILENCE;
            }
            float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
            SenoneSequence ss = getSenoneSequence(stid);
            HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
            hmmManager.put(hmm);
        }
        String lastUnitName = "";
        Unit lastUnit = null;
        int[] lastStid = null;
        SenoneSequence lastSenoneSequence = null;
        for (int i = 0; i < numTri; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= numContextIndependentTiedState && stid[j] < numTiedState;
            }
            est.expectString("N");
            assert !left.equals("-");
            assert !right.equals("-");
            assert !position.equals("-");
            assert attribute.equals("n/a");
            assert tmat < numTiedTransitionMatrices;
            if (useCDUnits) {
                Unit unit = null;
                String unitName = (name + " " + left + " " + right);
                if (unitName.equals(lastUnitName)) {
                    unit = lastUnit;
                } else {
                    Unit[] leftContext = new Unit[1];
                    leftContext[0] = (Unit) contextIndependentUnits.get(left);
                    Unit[] rightContext = new Unit[1];
                    rightContext[0] = (Unit) contextIndependentUnits.get(right);
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    unit = unitManager.getUnit(name, false, context);
                }
                lastUnitName = unitName;
                lastUnit = unit;
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine("Loaded " + unit);
                }
                float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
                SenoneSequence ss = lastSenoneSequence;
                if (ss == null || !sameSenoneSequence(stid, lastStid)) {
                    ss = getSenoneSequence(stid);
                }
                lastSenoneSequence = ss;
                lastStid = stid;
                HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
                hmmManager.put(hmm);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
    protected Pool loadHMMPool(boolean useCDUnits, InputStream inputStream, String path) throws FileNotFoundException, IOException {
        int token_type;
        int numBase;
        int numTri;
        int numStateMap;
        int numTiedState;
        int numStatePerHMM;
        int numContextIndependentTiedState;
        int numTiedTransitionMatrices;
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading HMM file from: " + path);
        est.expectString(MODEL_VERSION);
        numBase = est.getInt("numBase");
        est.expectString("n_base");
        numTri = est.getInt("numTri");
        est.expectString("n_tri");
        numStateMap = est.getInt("numStateMap");
        est.expectString("n_state_map");
        numTiedState = est.getInt("numTiedState");
        est.expectString("n_tied_state");
        numContextIndependentTiedState = est.getInt("numContextIndependentTiedState");
        est.expectString("n_tied_ci_state");
        numTiedTransitionMatrices = est.getInt("numTiedTransitionMatrices");
        est.expectString("n_tied_tmat");
        numStatePerHMM = numStateMap / (numTri + numBase);
        assert numTiedState == mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        assert numTiedTransitionMatrices == matrixPool.size();
        for (int i = 0; i < numBase; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= 0 && stid[j] < numContextIndependentTiedState;
            }
            est.expectString("N");
            assert left.equals("-");
            assert right.equals("-");
            assert position.equals("-");
            assert tmat < numTiedTransitionMatrices;
            Unit unit = unitManager.getUnit(name, attribute.equals(FILLER));
            contextIndependentUnits.put(unit.getName(), unit);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine("Loaded " + unit);
            }
            if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
                unit = UnitManager.SILENCE;
            }
            float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
            SenoneSequence ss = getSenoneSequence(stid);
            HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
            hmmManager.put(hmm);
        }
        String lastUnitName = "";
        Unit lastUnit = null;
        int[] lastStid = null;
        SenoneSequence lastSenoneSequence = null;
        for (int i = 0; i < numTri; i++) {
            String name = est.getString();
            String left = est.getString();
            String right = est.getString();
            String position = est.getString();
            String attribute = est.getString();
            int tmat = est.getInt("tmat");
            int[] stid = new int[numStatePerHMM - 1];
            for (int j = 0; j < numStatePerHMM - 1; j++) {
                stid[j] = est.getInt("j");
                assert stid[j] >= numContextIndependentTiedState && stid[j] < numTiedState;
            }
            est.expectString("N");
            assert !left.equals("-");
            assert !right.equals("-");
            assert !position.equals("-");
            assert attribute.equals("n/a");
            assert tmat < numTiedTransitionMatrices;
            if (useCDUnits) {
                Unit unit = null;
                String unitName = (name + " " + left + " " + right);
                if (unitName.equals(lastUnitName)) {
                    unit = lastUnit;
                } else {
                    Unit[] leftContext = new Unit[1];
                    leftContext[0] = (Unit) contextIndependentUnits.get(left);
                    Unit[] rightContext = new Unit[1];
                    rightContext[0] = (Unit) contextIndependentUnits.get(right);
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    unit = unitManager.getUnit(name, false, context);
                }
                lastUnitName = unitName;
                lastUnit = unit;
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine("Loaded " + unit);
                }
                float[][] transitionMatrix = (float[][]) matrixPool.get(tmat);
                SenoneSequence ss = lastSenoneSequence;
                if (ss == null || !sameSenoneSequence(stid, lastStid)) {
                    ss = getSenoneSequence(stid);
                }
                lastSenoneSequence = ss;
                lastStid = stid;
                HMM hmm = new SenoneHMM(unit, ss, transitionMatrix, HMMPosition.lookup(position));
                hmmManager.put(hmm);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65145.java,48,157
default,75351.java,48,157
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(-1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14511.java,48,157
default,9441.java,48,157
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,29270.java,48,157
default,72432.java,48,157
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(-1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12753.java,48,157
default,26742.java,48,157
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(-1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,66437.java,48,157
default,129185.java,46,155
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,30064.java,48,157
default,110670.java,48,157
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,29270.java,48,157
default,129185.java,46,155
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(-1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,174.java,48,157
default,2026.java,48,157
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,30064.java,48,157
default,2026.java,48,157
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,29270.java,48,157
default,99928.java,48,157
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(-1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,30064.java,48,157
default,65897.java,48,157
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
    public void run() {
        try {
            charsExpected = 10000 * (testData[0].length() + testData[1].length());
            String fileName = "/tmp/out" + myNumber;
            final Process tac = Runtime.getRuntime().exec(new String[] { PROGRAM, fileName }, null, new File("/tmp"));
            Thread writer = new Thread() {

                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            Thread reader = new Thread() {

                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
            };
            writer.start();
            reader.start();
            final Thread waiter = new Thread() {

                public void run() {
                    try {
                        int exitCode = tac.waitFor();
                        System.out.println("waitFor(): Process exited with code " + exitCode);
                    } catch (InterruptedException e) {
                        if (!interruptWait) {
                            System.out.println("Waiting thread uninterrupted unexpectedly!!!");
                            System.out.println("TestRuntimeExec FAILED");
                            System.exit(1);
                        }
                        System.out.println("Waiting thread interrupted! (THIS IS GOOD)");
                        e.printStackTrace();
                    }
                }
            };
            waiter.start();
            if (interruptWait) {
                new Thread() {

                    public void run() {
                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }
                        waiter.interrupt();
                    }
                }.start();
            }
            Thread poller = new Thread() {

                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
            };
            poller.start();
            try {
                reader.join();
                writer.join();
                waiter.join();
                poller.join();
            } catch (InterruptedException eee) {
                eee.printStackTrace();
            }
        } catch (Throwable e) {
            System.err.println("TestRuntimeExec FAILED with");
            e.printStackTrace();
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,427313.java,128,246
selected,427313.java,128,246
----------------------------------------
    public TrayIconStarter() {
        if (SystemTray.isSupported()) {
            new RESTClient(this);
            debugPanel = new DebugPanel();
            this.logMessage(Logger.INFO, "Application", "Started", "");
            MouseListener mouseListener = new MouseListener() {

                public void mouseClicked(MouseEvent e) {
                    mouseX = e.getX();
                    mouseY = e.getY();
                    switch(e.getButton()) {
                        case 1:
                            {
                                launchHoursPanel();
                            }
                    }
                }

                public void mouseEntered(MouseEvent e) {
                }

                public void mouseExited(MouseEvent e) {
                }

                public void mousePressed(MouseEvent e) {
                }

                public void mouseReleased(MouseEvent e) {
                }
            };
            ActionListener exitListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    System.out.println("Exiting...");
                    System.exit(0);
                }
            };
            ActionListener configListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    launchConfigPanel(true);
                }
            };
            ActionListener browserListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    launchBrowserPanel(true);
                }
            };
            ActionListener debugListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    launchDebugPanel(true);
                }
            };
            ActionListener hoursListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    launchHoursPanel();
                }
            };
            ActionListener loginListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    RESTClient.defaultInstance().restBrowserLogin();
                }
            };
            PopupMenu popup = new PopupMenu();
            MenuItem hoursMenuItem = new MenuItem("Log Hours");
            hoursMenuItem.addActionListener(hoursListener);
            popup.add(hoursMenuItem);
            if (java.awt.Desktop.isDesktopSupported()) {
                MenuItem loginItem = new MenuItem("Login");
                loginItem.addActionListener(loginListener);
                popup.add(loginItem);
            }
            MenuItem browserItem = new MenuItem("Object Browser");
            browserItem.addActionListener(browserListener);
            popup.add(browserItem);
            MenuItem configItem = new MenuItem("Configuration");
            configItem.addActionListener(configListener);
            popup.add(configItem);
            MenuItem debugItem = new MenuItem("Debug");
            debugItem.addActionListener(debugListener);
            popup.add(debugItem);
            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(exitListener);
            popup.add(exitItem);
            ActionListener actionListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    trayIcon.displayMessage("Action Event", "An Action Event Has Been Peformed!", TrayIcon.MessageType.INFO);
                    Image updatedImage = Toolkit.getDefaultToolkit().getImage("images/tray.gif");
                    trayIcon.setImage(updatedImage);
                    trayIcon.setImageAutoSize(true);
                }
            };
            String imagePath = "/org/projectopen/timesheet/po-icon.gif";
            URL fileLocation = getClass().getResource(imagePath);
            Image image = Toolkit.getDefaultToolkit().getImage(fileLocation);
            String imageStr = "null";
            if (image != null) {
                imageStr = image.getSource().toString();
            }
            this.logMessage(Logger.INFO, "Application", "Loading image from " + imagePath, imageStr);
            trayIcon = new TrayIcon(image, "Tray Demo", popup);
            trayIcon.setImageAutoSize(true);
            trayIcon.addActionListener(actionListener);
            trayIcon.addMouseListener(mouseListener);
            SystemTray tray = SystemTray.getSystemTray();
            try {
                tray.add(trayIcon);
            } catch (AWTException e) {
                System.err.println("TrayIcon could not be added.");
            }
        } else {
            System.err.println("System tray is currently not supported.");
        }
    }
----------------------------------------
    public TrayIconStarter() {
        if (SystemTray.isSupported()) {
            new RESTClient(this);
            debugPanel = new DebugPanel();
            this.logMessage(Logger.INFO, "Application", "Started", "");
            MouseListener mouseListener = new MouseListener() {

                public void mouseClicked(MouseEvent e) {
                    mouseX = e.getX();
                    mouseY = e.getY();
                    switch(e.getButton()) {
                        case 1:
                            {
                                launchHoursPanel();
                            }
                    }
                }

                public void mouseEntered(MouseEvent e) {
                }

                public void mouseExited(MouseEvent e) {
                }

                public void mousePressed(MouseEvent e) {
                }

                public void mouseReleased(MouseEvent e) {
                }
            };
            ActionListener exitListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    System.out.println("Exiting...");
                    System.exit(0);
                }
            };
            ActionListener configListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    launchConfigPanel(true);
                }
            };
            ActionListener browserListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    launchBrowserPanel(true);
                }
            };
            ActionListener debugListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    launchDebugPanel(true);
                }
            };
            ActionListener hoursListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    launchHoursPanel();
                }
            };
            ActionListener loginListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    RESTClient.defaultInstance().restBrowserLogin();
                }
            };
            PopupMenu popup = new PopupMenu();
            MenuItem hoursMenuItem = new MenuItem("Log Hours");
            hoursMenuItem.addActionListener(hoursListener);
            popup.add(hoursMenuItem);
            if (java.awt.Desktop.isDesktopSupported()) {
                MenuItem loginItem = new MenuItem("Login");
                loginItem.addActionListener(loginListener);
                popup.add(loginItem);
            }
            MenuItem browserItem = new MenuItem("Object Browser");
            browserItem.addActionListener(browserListener);
            popup.add(browserItem);
            MenuItem configItem = new MenuItem("Configuration");
            configItem.addActionListener(configListener);
            popup.add(configItem);
            MenuItem debugItem = new MenuItem("Debug");
            debugItem.addActionListener(debugListener);
            popup.add(debugItem);
            MenuItem exitItem = new MenuItem("Exit");
            exitItem.addActionListener(exitListener);
            popup.add(exitItem);
            ActionListener actionListener = new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    trayIcon.displayMessage("Action Event", "An Action Event Has Been Peformed!", TrayIcon.MessageType.INFO);
                    Image updatedImage = Toolkit.getDefaultToolkit().getImage("images/tray.gif");
                    trayIcon.setImage(updatedImage);
                    trayIcon.setImageAutoSize(true);
                }
            };
            String imagePath = "/org/projectopen/timesheet/po-icon.gif";
            URL fileLocation = getClass().getResource(imagePath);
            Image image = Toolkit.getDefaultToolkit().getImage(fileLocation);
            String imageStr = "null";
            if (image != null) {
                imageStr = image.getSource().toString();
            }
            this.logMessage(Logger.INFO, "Application", "Loading image from " + imagePath, imageStr);
            trayIcon = new TrayIcon(image, "Tray Demo", popup);
            trayIcon.setImageAutoSize(true);
            trayIcon.addActionListener(actionListener);
            trayIcon.addMouseListener(mouseListener);
            SystemTray tray = SystemTray.getSystemTray();
            try {
                tray.add(trayIcon);
            } catch (AWTException e) {
                System.err.println("TrayIcon could not be added.");
            }
        } else {
            System.err.println("System tray is currently not supported.");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1393862.java,79,165
selected,929053.java,85,188
----------------------------------------
    public File write(File saveDirectory, boolean attemptToSaveAsShort) {
        boolean useShortBeginning = false;
        boolean useShortLength = false;
        if (attemptToSaveAsShort) {
            int bp = sortedRegions[0].start;
            useShortBeginning = true;
            for (int i = 1; i < sortedRegions.length; i++) {
                int currentStart = sortedRegions[i].start;
                int diff = currentStart - bp;
                if (diff > 65536) {
                    useShortBeginning = false;
                    break;
                }
                bp = currentStart;
            }
            useShortLength = true;
            for (int i = 0; i < sortedRegions.length; i++) {
                int diff = sortedRegions[i].stop - sortedRegions[i].start;
                if (diff > 65536) {
                    useShortLength = false;
                    break;
                }
            }
        }
        String fileType;
        if (useShortBeginning) fileType = USeqUtilities.SHORT; else fileType = USeqUtilities.INT;
        if (useShortLength) fileType = fileType + USeqUtilities.SHORT; else fileType = fileType + USeqUtilities.INT;
        sliceInfo.setBinaryType(fileType);
        binaryFile = new File(saveDirectory, sliceInfo.getSliceName());
        FileOutputStream workingFOS = null;
        DataOutputStream workingDOS = null;
        try {
            workingFOS = new FileOutputStream(binaryFile);
            workingDOS = new DataOutputStream(new BufferedOutputStream(workingFOS));
            workingDOS.writeUTF(header);
            workingDOS.writeInt(sortedRegions[0].start);
            int bp = sortedRegions[0].start;
            if (useShortBeginning) {
                if (useShortLength == false) {
                    workingDOS.writeInt(sortedRegions[0].stop - sortedRegions[0].start);
                    for (int i = 1; i < sortedRegions.length; i++) {
                        int currentStart = sortedRegions[i].start;
                        int diff = currentStart - bp - 32768;
                        workingDOS.writeShort((short) (diff));
                        workingDOS.writeInt(sortedRegions[i].stop - sortedRegions[i].start);
                        bp = currentStart;
                    }
                } else {
                    workingDOS.writeShort((short) (sortedRegions[0].stop - sortedRegions[0].start - 32768));
                    for (int i = 1; i < sortedRegions.length; i++) {
                        int currentStart = sortedRegions[i].start;
                        int diff = currentStart - bp - 32768;
                        workingDOS.writeShort((short) (diff));
                        workingDOS.writeShort((short) (sortedRegions[i].stop - sortedRegions[i].start - 32768));
                        bp = currentStart;
                    }
                }
            } else {
                if (useShortLength == false) {
                    workingDOS.writeInt(sortedRegions[0].stop - sortedRegions[0].start);
                    for (int i = 1; i < sortedRegions.length; i++) {
                        int currentStart = sortedRegions[i].start;
                        int diff = currentStart - bp;
                        workingDOS.writeInt(diff);
                        workingDOS.writeInt(sortedRegions[i].stop - sortedRegions[i].start);
                        bp = currentStart;
                    }
                } else {
                    workingDOS.writeShort((short) (sortedRegions[0].stop - sortedRegions[0].start - 32768));
                    for (int i = 1; i < sortedRegions.length; i++) {
                        int currentStart = sortedRegions[i].start;
                        int diff = currentStart - bp;
                        workingDOS.writeInt(diff);
                        workingDOS.writeShort((short) (sortedRegions[i].stop - sortedRegions[i].start - 32768));
                        bp = currentStart;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            binaryFile = null;
        } finally {
            USeqUtilities.safeClose(workingDOS);
            USeqUtilities.safeClose(workingFOS);
        }
        return binaryFile;
    }
----------------------------------------
    public File write(File saveDirectory, boolean attemptToSaveAsShort) {
        boolean useShortBeginning = false;
        boolean useShortLength = false;
        if (attemptToSaveAsShort) {
            int bp = sortedRegionScoreTexts[0].start;
            useShortBeginning = true;
            for (int i = 1; i < sortedRegionScoreTexts.length; i++) {
                int currentStart = sortedRegionScoreTexts[i].start;
                int diff = currentStart - bp;
                if (diff > 65536) {
                    useShortBeginning = false;
                    break;
                }
                bp = currentStart;
            }
            useShortLength = true;
            for (int i = 0; i < sortedRegionScoreTexts.length; i++) {
                int diff = sortedRegionScoreTexts[i].stop - sortedRegionScoreTexts[i].start;
                if (diff > 65536) {
                    useShortLength = false;
                    break;
                }
            }
        }
        String fileType;
        if (useShortBeginning) fileType = USeqUtilities.SHORT; else fileType = USeqUtilities.INT;
        if (useShortLength) fileType = fileType + USeqUtilities.SHORT; else fileType = fileType + USeqUtilities.INT;
        fileType = fileType + USeqUtilities.FLOAT + USeqUtilities.TEXT;
        sliceInfo.setBinaryType(fileType);
        binaryFile = new File(saveDirectory, sliceInfo.getSliceName());
        FileOutputStream workingFOS = null;
        DataOutputStream workingDOS = null;
        try {
            workingFOS = new FileOutputStream(binaryFile);
            workingDOS = new DataOutputStream(new BufferedOutputStream(workingFOS));
            workingDOS.writeUTF(header);
            workingDOS.writeInt(sortedRegionScoreTexts[0].start);
            int bp = sortedRegionScoreTexts[0].start;
            if (useShortBeginning) {
                if (useShortLength == false) {
                    workingDOS.writeInt(sortedRegionScoreTexts[0].stop - sortedRegionScoreTexts[0].start);
                    workingDOS.writeFloat(sortedRegionScoreTexts[0].score);
                    workingDOS.writeUTF(sortedRegionScoreTexts[0].text);
                    for (int i = 1; i < sortedRegionScoreTexts.length; i++) {
                        int currentStart = sortedRegionScoreTexts[i].start;
                        int diff = currentStart - bp - 32768;
                        workingDOS.writeShort((short) (diff));
                        workingDOS.writeInt(sortedRegionScoreTexts[i].stop - sortedRegionScoreTexts[i].start);
                        workingDOS.writeFloat(sortedRegionScoreTexts[i].score);
                        workingDOS.writeUTF(sortedRegionScoreTexts[i].text);
                        bp = currentStart;
                    }
                } else {
                    workingDOS.writeShort((short) (sortedRegionScoreTexts[0].stop - sortedRegionScoreTexts[0].start - 32768));
                    workingDOS.writeFloat(sortedRegionScoreTexts[0].score);
                    workingDOS.writeUTF(sortedRegionScoreTexts[0].text);
                    for (int i = 1; i < sortedRegionScoreTexts.length; i++) {
                        int currentStart = sortedRegionScoreTexts[i].start;
                        int diff = currentStart - bp - 32768;
                        workingDOS.writeShort((short) (diff));
                        workingDOS.writeShort((short) (sortedRegionScoreTexts[i].stop - sortedRegionScoreTexts[i].start - 32768));
                        workingDOS.writeFloat(sortedRegionScoreTexts[i].score);
                        workingDOS.writeUTF(sortedRegionScoreTexts[i].text);
                        bp = currentStart;
                    }
                }
            } else {
                if (useShortLength == false) {
                    workingDOS.writeInt(sortedRegionScoreTexts[0].stop - sortedRegionScoreTexts[0].start);
                    workingDOS.writeFloat(sortedRegionScoreTexts[0].score);
                    workingDOS.writeUTF(sortedRegionScoreTexts[0].text);
                    for (int i = 1; i < sortedRegionScoreTexts.length; i++) {
                        int currentStart = sortedRegionScoreTexts[i].start;
                        int diff = currentStart - bp;
                        workingDOS.writeInt(diff);
                        workingDOS.writeInt(sortedRegionScoreTexts[i].stop - sortedRegionScoreTexts[i].start);
                        workingDOS.writeFloat(sortedRegionScoreTexts[i].score);
                        workingDOS.writeUTF(sortedRegionScoreTexts[i].text);
                        bp = currentStart;
                    }
                } else {
                    workingDOS.writeShort((short) (sortedRegionScoreTexts[0].stop - sortedRegionScoreTexts[0].start - 32768));
                    workingDOS.writeFloat(sortedRegionScoreTexts[0].score);
                    workingDOS.writeUTF(sortedRegionScoreTexts[0].text);
                    for (int i = 1; i < sortedRegionScoreTexts.length; i++) {
                        int currentStart = sortedRegionScoreTexts[i].start;
                        int diff = currentStart - bp;
                        workingDOS.writeInt(diff);
                        workingDOS.writeShort((short) (sortedRegionScoreTexts[i].stop - sortedRegionScoreTexts[i].start - 32768));
                        workingDOS.writeFloat(sortedRegionScoreTexts[i].score);
                        workingDOS.writeUTF(sortedRegionScoreTexts[i].text);
                        bp = currentStart;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            binaryFile = null;
        } finally {
            USeqUtilities.safeClose(workingDOS);
            USeqUtilities.safeClose(workingFOS);
        }
        return binaryFile;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,13801.java,383,482
default,8528.java,369,463
----------------------------------------
    void processForeachRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing variable in FOREACH");
        String var_name = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing filename in FOREACH");
        String file_name = pst.nextToken();
        String select = null;
        String start = null;
        String end = null;
        boolean inRange = false;
        if (pst.hasMoreTokens()) {
            select = pst.nextToken();
            if (!pst.hasMoreTokens()) throw new IOException("Missing field value in FOREACH");
            String fval = pst.nextToken();
            int dotdot = fval.indexOf("..");
            if (dotdot != -1 && dotdot == fval.lastIndexOf("..")) {
                start = fval.substring(0, dotdot);
                end = fval.substring(dotdot + 2);
            } else {
                start = fval;
            }
        }
        if (DEBUG) System.out.println("doing foreach with varname " + var_name + " on data file :" + file_name);
        if (DEBUG && select != null) {
            System.out.print("   selecting records with " + select);
            if (end == null) System.out.println(" equal to \"" + start + "\""); else System.out.println(" between \"" + start + "\" and \"" + end + "\"");
        }
        BufferedReader data;
        try {
            data = new BufferedReader(new FileReader(file_name));
        } catch (java.io.FileNotFoundException e) {
            data = new BufferedReader(new FileReader(inDir + file_name));
        }
        Vector fields_v = new Vector();
        Vector fpl_v = new Vector();
        for (String inLine = getNextLine(data); (inLine != null && inLine.length() != 0); inLine = getNextLine(data)) {
            StringTokenizer st = new StringTokenizer(inLine);
            fpl_v.addElement(new Integer(st.countTokens()));
            while (st.hasMoreTokens()) {
                String tok = st.nextToken();
                if (DEBUG) System.out.println("read field " + fields_v.size() + " :" + tok);
                fields_v.addElement(tok);
            }
        }
        fields_v.addElement(indexField);
        int[] fieldsPerLine = new int[fpl_v.size()];
        for (int i = 0; i < fieldsPerLine.length; i++) fieldsPerLine[i] = ((Integer) fpl_v.elementAt(i)).intValue();
        String[] fields = new String[fields_v.size()];
        for (int i = 0; i < fields.length; i++) fields[i] = (String) fields_v.elementAt(i);
        dataFileLoop: for (int curField = 0; ; curField++) {
            int i = 0;
            String[] fieldData = new String[fields.length];
            for (int j = 0; j < fieldsPerLine.length; j++) {
                String line = getNextLine(data);
                if (line == null) break dataFileLoop;
                if (fieldsPerLine[j] == 1) {
                    if (DEBUG) System.out.println("read field " + fields[i] + " :" + line);
                    fieldData[i++] = line;
                } else {
                    if (DEBUG) System.out.println("reading " + fieldsPerLine[j] + " fields");
                    StringTokenizer st = new StringTokenizer(line);
                    try {
                        for (int k = 0; k < fieldsPerLine[j]; k++) {
                            String tok = st.nextToken();
                            if (DEBUG) System.out.println("read field " + fields[i] + ": " + tok);
                            fieldData[i++] = tok;
                        }
                    } catch (NoSuchElementException x) {
                        throw new IOException("Missing field " + fields[i]);
                    }
                }
            }
            if (fieldsPerLine.length != 1) getNextLine(data);
            fieldData[i++] = Integer.toString(curField);
            if (select != null) {
                for (int j = 0; j < fields.length; j++) {
                    if (DEBUG) System.out.println("checking if select is field " + fields[j]);
                    if (select.equals(fields[j])) {
                        String value = fieldData[j];
                        if (value.equals(start)) inRange = true; else if (end == null) inRange = false; else if (value.equals(end)) end = null;
                        if (DEBUG) System.out.println("record in range; including");
                        break;
                    }
                }
                if (!inRange) break dataFileLoop;
            }
            for (int j = 1; j < region.size(); j++) {
                try {
                    String currentLine = (String) region.elementAt(j);
                    String result = substitute(currentLine, var_name, fields, fieldData);
                    out.print(result + "\n");
                } catch (ClassCastException e) {
                    Vector oldRegion = (Vector) region.elementAt(j);
                    Vector newRegion = substituteInRegion(oldRegion, var_name, fields, fieldData);
                    processTemplateRegion(newRegion);
                }
            }
        }
        data.close();
    }
----------------------------------------
    void processForeachRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing variable in FOREACH");
        String var_name = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing filename in FOREACH");
        String file_name = pst.nextToken();
        String select = null;
        String start = null;
        String end = null;
        boolean inRange = false;
        if (pst.hasMoreTokens()) {
            select = pst.nextToken();
            if (!pst.hasMoreTokens()) throw new IOException("Missing field value in FOREACH");
            String fval = pst.nextToken();
            int dotdot = fval.indexOf("..");
            if (dotdot != -1 && dotdot == fval.lastIndexOf("..")) {
                start = fval.substring(0, dotdot);
                end = fval.substring(dotdot + 2);
            } else {
                start = fval;
            }
        }
        if (DEBUG) System.out.println("doing foreach with varname " + var_name + " on data file :" + file_name);
        if (DEBUG && select != null) {
            System.out.print("   selecting records with " + select);
            if (end == null) System.out.println(" equal to \"" + start + "\""); else System.out.println(" between \"" + start + "\" and \"" + end + "\"");
        }
        BufferedReader data = new BufferedReader(new FileReader(file_name));
        Vector fields_v = new Vector();
        Vector fpl_v = new Vector();
        for (String inLine = getNextLine(data); (inLine != null && inLine.length() != 0); inLine = getNextLine(data)) {
            StringTokenizer st = new StringTokenizer(inLine);
            fpl_v.addElement(new Integer(st.countTokens()));
            while (st.hasMoreTokens()) {
                String tok = st.nextToken();
                if (DEBUG) System.out.println("read field " + fields_v.size() + " :" + tok);
                fields_v.addElement(tok);
            }
        }
        fields_v.addElement(indexField);
        int[] fieldsPerLine = new int[fpl_v.size()];
        for (int i = 0; i < fieldsPerLine.length; i++) fieldsPerLine[i] = ((Integer) fpl_v.elementAt(i)).intValue();
        String[] fields = new String[fields_v.size()];
        for (int i = 0; i < fields.length; i++) fields[i] = (String) fields_v.elementAt(i);
        dataFileLoop: for (int curField = 0; ; curField++) {
            int i = 0;
            String[] fieldData = new String[fields.length];
            for (int j = 0; j < fieldsPerLine.length; j++) {
                String line = getNextLine(data);
                if (line == null) break dataFileLoop;
                if (fieldsPerLine[j] == 1) {
                    if (DEBUG) System.out.println("read field " + fields[i] + " :" + line);
                    fieldData[i++] = line;
                } else {
                    if (DEBUG) System.out.println("reading " + fieldsPerLine[j] + " fields");
                    StringTokenizer st = new StringTokenizer(line);
                    try {
                        for (int k = 0; k < fieldsPerLine[j]; k++) {
                            String tok = st.nextToken();
                            if (DEBUG) System.out.println("read field " + fields[i] + ": " + tok);
                            fieldData[i++] = tok;
                        }
                    } catch (NoSuchElementException x) {
                        throw new IOException("Missing field " + fields[i]);
                    }
                }
            }
            if (fieldsPerLine.length != 1) getNextLine(data);
            fieldData[i++] = Integer.toString(curField);
            if (select != null) {
                for (int j = 0; j < fields.length; j++) {
                    if (DEBUG) System.out.println("checking if select is field " + fields[j]);
                    if (select.equals(fields[j])) {
                        String value = fieldData[j];
                        if (value.equals(start)) inRange = true; else if (end == null) inRange = false; else if (value.equals(end)) end = null;
                        if (DEBUG) System.out.println("record in range; including");
                        break;
                    }
                }
                if (!inRange) break dataFileLoop;
            }
            for (int j = 1; j < region.size(); j++) {
                try {
                    String currentLine = (String) region.elementAt(j);
                    String result = substitute(currentLine, var_name, fields, fieldData);
                    out.print(result + "\n");
                } catch (ClassCastException e) {
                    Vector oldRegion = (Vector) region.elementAt(j);
                    Vector newRegion = substituteInRegion(oldRegion, var_name, fields, fieldData);
                    processTemplateRegion(newRegion);
                }
            }
        }
        data.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,111036.java,133,239
selected,347593.java,75,173
----------------------------------------
    public void decodeNextScanline() {
        int bits = 0, code = 0, isT = 0;
        int current, entry, twoBits;
        boolean isWhite = true;
        int bitOffset = 0;
        changingElemSize = 0;
        while (bitOffset < w) {
            int runOffset = bitOffset;
            while (isWhite && bitOffset < w) {
                current = nextNBits(10);
                entry = white[current];
                isT = entry & 0x0001;
                bits = (entry >>> 1) & 0x0f;
                if (bits == 12) {
                    twoBits = nextLesserThan8Bits(2);
                    current = ((current << 2) & 0x000c) | twoBits;
                    entry = additionalMakeup[current];
                    bits = (entry >>> 1) & 0x07;
                    code = (entry >>> 4) & 0x0fff;
                    bitOffset += code;
                    updatePointer(4 - bits);
                } else if (bits == 0) {
                    ++fails;
                } else if (bits == 15) {
                    ++fails;
                    return;
                } else {
                    code = (entry >>> 5) & 0x07ff;
                    bitOffset += code;
                    updatePointer(10 - bits);
                    if (isT == 0) {
                        isWhite = false;
                        currChangingElems[changingElemSize++] = bitOffset;
                    }
                }
            }
            if (bitOffset == w) {
                int runLength = bitOffset - runOffset;
                if (isWhite && runLength != 0 && runLength % 64 == 0 && nextNBits(8) != 0x35) {
                    ++fails;
                    updatePointer(8);
                }
                break;
            }
            runOffset = bitOffset;
            while (isWhite == false && bitOffset < w) {
                current = nextLesserThan8Bits(4);
                entry = initBlack[current];
                isT = entry & 0x0001;
                bits = (entry >>> 1) & 0x000f;
                code = (entry >>> 5) & 0x07ff;
                if (code == 100) {
                    current = nextNBits(9);
                    entry = black[current];
                    isT = entry & 0x0001;
                    bits = (entry >>> 1) & 0x000f;
                    code = (entry >>> 5) & 0x07ff;
                    if (bits == 12) {
                        updatePointer(5);
                        current = nextLesserThan8Bits(4);
                        entry = additionalMakeup[current];
                        bits = (entry >>> 1) & 0x07;
                        code = (entry >>> 4) & 0x0fff;
                        setToBlack(bitOffset, code);
                        bitOffset += code;
                        updatePointer(4 - bits);
                    } else if (bits == 15) {
                        ++fails;
                        return;
                    } else {
                        setToBlack(bitOffset, code);
                        bitOffset += code;
                        updatePointer(9 - bits);
                        if (isT == 0) {
                            isWhite = true;
                            currChangingElems[changingElemSize++] = bitOffset;
                        }
                    }
                } else if (code == 200) {
                    current = nextLesserThan8Bits(2);
                    entry = twoBitBlack[current];
                    code = (entry >>> 5) & 0x07ff;
                    bits = (entry >>> 1) & 0x0f;
                    setToBlack(bitOffset, code);
                    bitOffset += code;
                    updatePointer(2 - bits);
                    isWhite = true;
                    currChangingElems[changingElemSize++] = bitOffset;
                } else {
                    setToBlack(bitOffset, code);
                    bitOffset += code;
                    updatePointer(4 - bits);
                    isWhite = true;
                    currChangingElems[changingElemSize++] = bitOffset;
                }
            }
            if (bitOffset == w) {
                int runLength = bitOffset - runOffset;
                if (!isWhite && runLength != 0 && runLength % 64 == 0 && nextNBits(10) != 0x37) {
                    ++fails;
                    updatePointer(10);
                }
                break;
            }
        }
        currChangingElems[changingElemSize++] = bitOffset;
    }
----------------------------------------
    public void decodeNextScanline(byte[] buffer, int lineOffset, int bitOffset) {
        int bits = 0, code = 0, isT = 0;
        int current, entry, twoBits;
        boolean isWhite = true;
        int dstEnd = 0;
        changingElemSize = 0;
        while (bitOffset < w) {
            while (isWhite) {
                current = nextNBits(10);
                entry = white[current];
                isT = entry & 0x0001;
                bits = (entry >>> 1) & 0x0f;
                if (bits == 12) {
                    twoBits = nextLesserThan8Bits(2);
                    current = ((current << 2) & 0x000c) | twoBits;
                    entry = additionalMakeup[current];
                    bits = (entry >>> 1) & 0x07;
                    code = (entry >>> 4) & 0x0fff;
                    bitOffset += code;
                    updatePointer(4 - bits);
                } else if (bits == 0) {
                    throw new Error(JaiI18N.getString("TIFFFaxDecoder0"));
                } else if (bits == 15) {
                    throw new Error(JaiI18N.getString("TIFFFaxDecoder1"));
                } else {
                    code = (entry >>> 5) & 0x07ff;
                    bitOffset += code;
                    updatePointer(10 - bits);
                    if (isT == 0) {
                        isWhite = false;
                        currChangingElems[changingElemSize++] = bitOffset;
                    }
                }
            }
            if (bitOffset == w) {
                if (compression == 2) {
                    advancePointer();
                }
                break;
            }
            while (isWhite == false) {
                current = nextLesserThan8Bits(4);
                entry = initBlack[current];
                isT = entry & 0x0001;
                bits = (entry >>> 1) & 0x000f;
                code = (entry >>> 5) & 0x07ff;
                if (code == 100) {
                    current = nextNBits(9);
                    entry = black[current];
                    isT = entry & 0x0001;
                    bits = (entry >>> 1) & 0x000f;
                    code = (entry >>> 5) & 0x07ff;
                    if (bits == 12) {
                        updatePointer(5);
                        current = nextLesserThan8Bits(4);
                        entry = additionalMakeup[current];
                        bits = (entry >>> 1) & 0x07;
                        code = (entry >>> 4) & 0x0fff;
                        setToBlack(buffer, lineOffset, bitOffset, code);
                        bitOffset += code;
                        updatePointer(4 - bits);
                    } else if (bits == 15) {
                        throw new Error(JaiI18N.getString("TIFFFaxDecoder2"));
                    } else {
                        setToBlack(buffer, lineOffset, bitOffset, code);
                        bitOffset += code;
                        updatePointer(9 - bits);
                        if (isT == 0) {
                            isWhite = true;
                            currChangingElems[changingElemSize++] = bitOffset;
                        }
                    }
                } else if (code == 200) {
                    current = nextLesserThan8Bits(2);
                    entry = twoBitBlack[current];
                    code = (entry >>> 5) & 0x07ff;
                    bits = (entry >>> 1) & 0x0f;
                    setToBlack(buffer, lineOffset, bitOffset, code);
                    bitOffset += code;
                    updatePointer(2 - bits);
                    isWhite = true;
                    currChangingElems[changingElemSize++] = bitOffset;
                } else {
                    setToBlack(buffer, lineOffset, bitOffset, code);
                    bitOffset += code;
                    updatePointer(4 - bits);
                    isWhite = true;
                    currChangingElems[changingElemSize++] = bitOffset;
                }
            }
            if (bitOffset == w) {
                if (compression == 2) {
                    advancePointer();
                }
                break;
            }
        }
        currChangingElems[changingElemSize++] = bitOffset;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1465010.java,49,138
selected,2587776.java,57,159
----------------------------------------
    public void _jspService(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException, ServletException {
        PageContext pageContext = null;
        HttpSession session = null;
        ServletContext application = null;
        ServletConfig config = null;
        JspWriter out = null;
        Object page = this;
        JspWriter _jspx_out = null;
        PageContext _jspx_page_context = null;
        try {
            response.setContentType("text/html; charset=ISO-8859-1");
            pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);
            _jspx_page_context = pageContext;
            application = pageContext.getServletContext();
            config = pageContext.getServletConfig();
            session = pageContext.getSession();
            out = pageContext.getOut();
            _jspx_out = out;
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("<script src=\"./js/jQuery.js\" type=\"text/javascript\"></script>\r\n");
            out.write("<script src=\"./js/jquery.maskedinput.js\" type=\"text/javascript\"></script>\r\n");
            out.write("<script src=\"./js/jquery.tablesorter.js\" type=\"text/javascript\"></script>\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("<!--  para o auto complete -->\r\n");
            out.write("\r\n");
            out.write("\r\n");
            org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, "/header.jsp", out, true);
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("<script>\r\n");
            out.write("\tfunction submeter(){\r\n");
            out.write("\t\tvar form = document.forms[0];\r\n");
            out.write("\t\tform.metodo.value = 'gerar';\r\n");
            out.write("\t\tform.submit();\r\n");
            out.write("\t}\r\n");
            out.write("\t\r\n");
            out.write("\tfunction submeter2(){\r\n");
            out.write("\t\tif(confirm('Aplicar um script é uma operação arriscada, deseja continuar?')) {\r\n");
            out.write("\t\t\tvar form = document.forms[0];\r\n");
            out.write("\t\t\tform.metodo.value = 'aplicar';\r\n");
            out.write("\t\t\tform.submit();\r\n");
            out.write("\t\t} else {\r\n");
            out.write("\t\t\treturn false;\r\n");
            out.write("\t\t}\r\n");
            out.write("\t}\r\n");
            out.write("</script>\r\n");
            out.write("\t\r\n");
            out.write("\r\n");
            out.write("<div id=\"corpo\">\r\n");
            out.write("\r\n");
            out.write("<div class=\"breadcrumb\">\r\n");
            out.write("\t");
            if (_jspx_meth_html_005flink_005f0(_jspx_page_context)) return;
            out.write("\r\n");
            out.write("\t\t&raquo;<a class=\"ativo\" href=\"#\">Backup OrthoSystem</a> </div>\r\n");
            if (_jspx_meth_html_005fform_005f0(_jspx_page_context)) return;
            out.write("\r\n");
            out.write("\r\n");
            out.write("\t<script>\r\n");
            out.write("\t\tif(document.getElementById('endereco').value == '') {\r\n");
            out.write("\t\t\tdocument.getElementById('endereco').value = 'e:\\\\backupOrthoSystem\\\\';\r\n");
            out.write("\t\t}\r\n");
            out.write("\t\tfunction setarValor(id) {\r\n");
            out.write("\t\t \tif(id == 1) {\r\n");
            out.write("\t\t \t\tdocument.getElementById('endereco').value = 'c:\\\\backupOrthoSystem\\\\';\r\n");
            out.write("\t\t \t} else {\r\n");
            out.write("\t\t \t\tdocument.getElementById('endereco').value = 'e:\\\\backupOrthoSystem\\\\';\r\n");
            out.write("\t\t \t}\r\n");
            out.write("\t\t}\r\n");
            out.write("\t</script>\r\n");
            out.write("</div>");
        } catch (Throwable t) {
            if (!(t instanceof SkipPageException)) {
                out = _jspx_out;
                if (out != null && out.getBufferSize() != 0) try {
                    out.clearBuffer();
                } catch (java.io.IOException e) {
                }
                if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
            }
        } finally {
            _jspxFactory.releasePageContext(_jspx_page_context);
        }
    }
----------------------------------------
    public void _jspService(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException, ServletException {
        PageContext pageContext = null;
        HttpSession session = null;
        ServletContext application = null;
        ServletConfig config = null;
        JspWriter out = null;
        Object page = this;
        JspWriter _jspx_out = null;
        PageContext _jspx_page_context = null;
        try {
            response.setContentType("text/html");
            pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);
            _jspx_page_context = pageContext;
            application = pageContext.getServletContext();
            config = pageContext.getServletConfig();
            session = pageContext.getSession();
            out = pageContext.getOut();
            _jspx_out = out;
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("<script src=\"./js/jQuery.js\" type=\"text/javascript\"></script>\r\n");
            out.write("<script src=\"./js/jquery.tablesorter.js\" type=\"text/javascript\"></script>\r\n");
            out.write("<script src=\"./js/geral.js\" type=\"text/javascript\"></script>\r\n");
            out.write("<script src=\"./js/calendar.js\" type=\"text/javascript\"></script>\r\n");
            out.write("<script src=\"./js/jquery.alphanumeric.pack.js\" type=\"text/javascript\"></script>\r\n");
            out.write("<script src=\"./js/jquery.maskedinput.js\" type=\"text/javascript\"></script>\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("<script>\r\n");
            out.write("\r\n");
            out.write("   $().ready(function(){\r\n");
            out.write("     \t$(\"#dataInicio\").mask(\"99/99/9999\");\r\n");
            out.write("\t\t$(\"#dataFinal\").mask(\"99/99/9999\");\r\n");
            out.write("  \t });  \r\n");
            out.write("\t\r\n");
            out.write("\tfunction carregarMascaras() {\r\n");
            out.write("\r\n");
            out.write("\t\tmesMask = new Mask(\"##\", \"number\");\r\n");
            out.write("\t\tmesMask.attach(document.getElementById('mesInicial'));\r\n");
            out.write("\t\tmesMask.attach(document.getElementById('mesFinal'));\r\n");
            out.write("\t\t\r\n");
            out.write("\t\tanoMask = new Mask(\"####\", \"number\");\r\n");
            out.write("\t\tanoMask.attach(document.getElementById('anoInicial'));\r\n");
            out.write("\t\tanoMask.attach(document.getElementById('anoFinal'));\r\n");
            out.write("\t\t\r\n");
            out.write("\t\t\r\n");
            out.write("\t}\r\n");
            out.write("\t\r\n");
            out.write("\r\n");
            out.write("\tfunction imprimir(id){\r\n");
            out.write("\t\tdocument.getElementById('metodo').value = \"imprimir\";\r\n");
            out.write("\t\tdocument.getElementById('reciboId').value = id;\r\n");
            out.write("\t\tdocument.forms[0].submit(); \r\n");
            out.write("\t}\r\n");
            out.write("\t\r\n");
            out.write("\tfunction vizualizar(){\r\n");
            out.write("\t\tdocument.getElementById('metodo').value = \"vizualizar\";\r\n");
            out.write("\t\tdocument.forms[0].submit()\r\n");
            out.write("\t}\r\n");
            out.write("\t\r\n");
            out.write("\tfunction inicializaCombo(){\r\n");
            out.write("\t\tvar a = document.getElementById('tipo').value;\r\n");
            out.write("\t\tdocument.forms[0].radioServico[a-1].checked = 1; \r\n");
            out.write("\t}\r\n");
            out.write("</script>\r\n");
            out.write("\r\n");
            out.write("\r\n");
            out.write("<div id=\"corpo\">\r\n");
            out.write("\r\n");
            out.write("<div class=\"breadcrumb\">\r\n");
            out.write("\t");
            if (_jspx_meth_html_005flink_005f0(_jspx_page_context)) return;
            out.write("\r\n");
            out.write("\t\t&raquo;<a class=\"ativo\" href=\"#\">Relatório de Pagamentos Efetuados</a> </div>\r\n");
            out.write("\r\n");
            if (_jspx_meth_html_005fform_005f0(_jspx_page_context)) return;
            out.write("\r\n");
            out.write("\r\n");
            out.write("<script>\r\n");
            out.write("\tcarregarMascaras();\r\n");
            out.write("</script>\r\n");
            out.write("</div>");
        } catch (Throwable t) {
            if (!(t instanceof SkipPageException)) {
                out = _jspx_out;
                if (out != null && out.getBufferSize() != 0) try {
                    out.clearBuffer();
                } catch (java.io.IOException e) {
                }
                if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
            }
        } finally {
            _jspxFactory.releasePageContext(_jspx_page_context);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,46669.java,1439,1525
default,11981.java,1181,1261
----------------------------------------
    private byte[] getTunerList(HTTPurl urlData) throws Exception {
        boolean showID = "true".equalsIgnoreCase(urlData.getParameter("showid"));
        showID = showID | "true".equalsIgnoreCase(urlData.getCookie("showDeviceID"));
        if ("false".equalsIgnoreCase(urlData.getParameter("showid"))) showID = false;
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "CardSetup.html");
        if (showID == true) template.addCookie("showDeviceID", "true"); else template.addCookie("showDeviceID", "false");
        CaptureDeviceList devList = CaptureDeviceList.getInstance();
        int activeDevices = devList.getActiveDeviceCount();
        boolean testMode = "1".equals(store.getProperty("tools.testmode"));
        String scanCommand = "";
        if (testMode == true) {
            scanCommand = "win32/device.exe -test";
        } else {
            scanCommand = "win32/device.exe";
        }
        System.out.println("Running device scan command: " + scanCommand);
        Runtime runner = Runtime.getRuntime();
        Process scan = runner.exec(scanCommand);
        TunerScanResult tuners = new TunerScanResult();
        tuners.readInput(scan.getInputStream());
        tuners.parseXML();
        StringBuffer out = new StringBuffer();
        Vector<CaptureDevice> tunersList = tuners.getResult();
        out.append("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'>");
        out.append("<table width='100%' border='0' cellpadding='0' cellspacing='0'><tr><td><strong>Currently Selected Devices</strong></td><td align='right'>");
        if (showID) out.append("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=false'>Hide IDs</a>"); else out.append("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=true'>Show IDs</a>");
        out.append("</td></tr></table></td></tr>\n");
        for (int x = 0; x < devList.getDeviceCount(); x++) {
            CaptureDevice cd = (CaptureDevice) devList.getDevice(x);
            out.append("<tr>");
            out.append("<td nowrap>" + x + "</td>");
            out.append("<td nowrap>: ");
            out.append(cd.getName());
            if (cd.isInUse() == true) out.append(" (Active)");
            boolean isAvailable = false;
            for (int y = 0; y < tunersList.size(); y++) {
                CaptureDevice cd2 = (CaptureDevice) tunersList.get(y);
                if (cd.getID().equals(cd2.getID())) {
                    isAvailable = true;
                    break;
                }
            }
            if (isAvailable == false) out.append(" <img border='0' alt='Not Available' title='Device Not Available' src='/images/exclaim24.png' align='absmiddle' width='22' height='24'> ");
            if (showID) out.append("(" + cd.getID() + ")");
            out.append("</td>\n");
            out.append("<td nowrap width='50px'> ");
            out.append(" <a href='/servlet/SystemDataRes?action=14&tunerID=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
            out.append("<a href='/servlet/SystemDataRes?action=15&tunerID=" + x + "'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
            out.append("<a href='/servlet/SystemDataRes?action=16&tunerID=" + x + "'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
            out.append("</td>\n");
            out.append("</tr>\n");
        }
        if (devList.getDeviceCount() == 0) {
            out.append("<tr><td colspan ='3'>No devices selected</td></tr>");
        }
        int numCards = 0;
        out.append("<tr><td colspan='3'><strong>&nbsp;</strong></td></tr>");
        out.append("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'><strong>Devices Available But Not Selected</strong></td></tr>");
        for (int x = 0; x < tunersList.size(); x++) {
            CaptureDevice dev = (CaptureDevice) tunersList.get(x);
            boolean found = false;
            for (int y = 0; y < devList.getDeviceCount(); y++) {
                CaptureDevice cd = (CaptureDevice) devList.getDevice(y);
                if (cd.getID().equals(dev.getID())) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                out.append("<tr>");
                out.append("<td>&nbsp;</td>");
                out.append("<td nowrap>" + dev.getName() + "</td>");
                out.append("<td width='50px'><a href='/servlet/SystemDataRes?action=13&tunerID=" + URLEncoder.encode(dev.getID(), "UTF-8"));
                out.append("&tunerName=" + URLEncoder.encode(dev.getName(), "UTF-8") + "'>");
                out.append("<img border='0' alt='ADD' src='/images/add.png' align='absmiddle' width='24' height='24'></a></td>\n");
                out.append("</tr>\n");
                numCards++;
            }
        }
        if (numCards == 0) {
            out.append("<tr><td colspan ='3'>No devices available</td></tr>");
        }
        numCards = 0;
        template.replaceAll("$cardList", out.toString());
        template.replaceAll("$cardCount", new Integer(activeDevices).toString());
        return template.getPageBytes();
    }
----------------------------------------
    private byte[] getTunerList(HTTPurl urlData) throws Exception {
        boolean showID = "true".equalsIgnoreCase(urlData.getParameter("showid"));
        showID = showID | "true".equalsIgnoreCase(urlData.getCookie("showDeviceID"));
        if ("false".equalsIgnoreCase(urlData.getParameter("showid"))) showID = false;
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "CardSetup.html");
        if (showID == true) template.addCookie("showDeviceID", "true"); else template.addCookie("showDeviceID", "false");
        CaptureDeviceList devList = CaptureDeviceList.getInstance();
        int activeDevices = devList.getActiveDeviceCount();
        String scanCommand = "device.exe";
        System.out.println("Running device scan command: " + scanCommand);
        Runtime runner = Runtime.getRuntime();
        Process scan = runner.exec(scanCommand);
        TunerScanResult tuners = new TunerScanResult();
        tuners.readInput(scan.getInputStream());
        tuners.parseXML();
        StringBuffer out = new StringBuffer();
        Vector<CaptureDevice> tunersList = tuners.getResult();
        out.append("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'>");
        out.append("<table width='100%' border='0' cellpadding='0' cellspacing='0'><tr><td><strong>Currently Selected Devices</strong></td><td align='right'>");
        if (showID) out.append("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=false'>Hide IDs</a>"); else out.append("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=true'>Show IDs</a>");
        out.append("</td></tr></table></td></tr>\n");
        for (int x = 0; x < devList.getDeviceCount(); x++) {
            CaptureDevice cd = (CaptureDevice) devList.getDevice(x);
            out.append("<tr>");
            out.append("<td nowrap>" + x + "</td>");
            out.append("<td nowrap>: ");
            out.append(cd.getName());
            if (cd.isInUse() == true) out.append(" (Active)");
            boolean isAvailable = false;
            for (int y = 0; y < tunersList.size(); y++) {
                CaptureDevice cd2 = (CaptureDevice) tunersList.get(y);
                if (cd.getID().equals(cd2.getID())) {
                    isAvailable = true;
                    break;
                }
            }
            if (isAvailable == false) out.append(" <img border='0' alt='Not Available' title='Device Not Available' src='/images/exclaim24.png' align='absmiddle' width='22' height='24'> ");
            if (showID) out.append("(" + cd.getID() + ")");
            out.append("</td>\n");
            out.append("<td nowrap width='50px'> ");
            out.append(" <a href='/servlet/SystemDataRes?action=14&tunerID=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
            out.append("<a href='/servlet/SystemDataRes?action=15&tunerID=" + x + "'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
            out.append("<a href='/servlet/SystemDataRes?action=16&tunerID=" + x + "'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
            out.append("</td>\n");
            out.append("</tr>\n");
        }
        if (devList.getDeviceCount() == 0) {
            out.append("<tr><td colspan ='3'>No devices selected</td></tr>");
        }
        int numCards = 0;
        out.append("<tr><td colspan='3'><strong>&nbsp;</strong></td></tr>");
        out.append("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'><strong>Devices Available But Not Selected</strong></td></tr>");
        for (int x = 0; x < tunersList.size(); x++) {
            CaptureDevice dev = (CaptureDevice) tunersList.get(x);
            boolean found = false;
            for (int y = 0; y < devList.getDeviceCount(); y++) {
                CaptureDevice cd = (CaptureDevice) devList.getDevice(y);
                if (cd.getID().equals(dev.getID())) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                out.append("<tr>");
                out.append("<td>&nbsp;</td>");
                out.append("<td nowrap>" + dev.getName() + "</td>");
                out.append("<td width='50px'><a href='/servlet/SystemDataRes?action=13&tunerID=" + URLEncoder.encode(dev.getID(), "UTF-8"));
                out.append("&tunerName=" + URLEncoder.encode(dev.getName(), "UTF-8") + "'>");
                out.append("<img border='0' alt='ADD' src='/images/add.png' align='absmiddle' width='24' height='24'></a></td>\n");
                out.append("</tr>\n");
                numCards++;
            }
        }
        if (numCards == 0) {
            out.append("<tr><td colspan ='3'>No devices available</td></tr>");
        }
        numCards = 0;
        template.replaceAll("$cardList", out.toString());
        template.replaceAll("$cardCount", new Integer(activeDevices).toString());
        return template.getPageBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,3389.java,110,197
default,96339.java,110,197
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,93531.java,110,197
default,103762.java,110,197
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24621.java,110,197
default,103146.java,110,197
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42993.java,107,194
default,15343.java,110,197
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,21681.java,110,197
default,70088.java,110,197
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,10598.java,204,283
default,10598.java,204,283
----------------------------------------
    Message generateReply(Message query, byte[] in, Socket s) {
        boolean badversion;
        int maxLength;
        boolean sigonly;
        if (query.getHeader().getOpcode() != Opcode.QUERY) return errorMessage(query, Rcode.NOTIMPL);
        Record queryRecord = query.getQuestion();
        TSIGRecord queryTSIG = query.getTSIG();
        TSIG tsig = null;
        if (queryTSIG != null) {
            tsig = findTSIG(queryTSIG.getName());
            if (!tsig.verify(query, in, null)) return formerrMessage(in);
        }
        OPTRecord queryOPT = query.getOPT();
        if (queryOPT != null && queryOPT.getVersion() > 0) badversion = true;
        if (s != null) maxLength = 65535; else if (queryOPT != null) maxLength = queryOPT.getPayloadSize(); else maxLength = 512;
        Message response = new Message();
        response.getHeader().setID(query.getHeader().getID());
        response.getHeader().setFlag(Flags.QR);
        response.addRecord(queryRecord, Section.QUESTION);
        Name name = queryRecord.getName();
        short type = queryRecord.getType();
        short dclass = queryRecord.getDClass();
        if (type == Type.AXFR && s != null) return doAXFR(name, query, s);
        if (!Type.isRR(type) && type != Type.ANY) return errorMessage(query, Rcode.NOTIMPL);
        if (type == Type.SIG) {
            type = Type.ANY;
            sigonly = true;
        } else sigonly = false;
        Zone zone = findBestZone(name);
        if (zone != null) {
            response.getHeader().setFlag(Flags.AA);
            SetResponse zr = zone.findRecords(name, type);
            if (zr.isNXDOMAIN()) response.getHeader().setRcode(Rcode.NXDOMAIN);
            Vector backtrace = zr.backtrace();
            if (backtrace != null) {
                Enumeration e = backtrace.elements();
                while (e.hasMoreElements()) {
                    Record cname = (Record) e.nextElement();
                    response.addRecord(cname, Section.ANSWER);
                }
            }
            if (zr.isSuccessful()) {
                RRset[] rrsets = zr.answers();
                for (int i = 0; i < rrsets.length; i++) addRRset(name, response, rrsets[i], sigonly);
            }
        } else {
            SetResponse cr;
            cr = cache.lookupRecords(name, type, dclass, Credibility.NONAUTH_ANSWER);
            Vector backtrace = cr.backtrace();
            if (backtrace != null) {
                Enumeration e = backtrace.elements();
                while (e.hasMoreElements()) {
                    Record cname = (Record) e.nextElement();
                    response.addRecord(cname, Section.ANSWER);
                }
                if (!cr.isSuccessful()) response.getHeader().setRcode(Rcode.NXDOMAIN);
            }
            if (cr.isSuccessful()) {
                RRset[] rrsets = cr.answers();
                for (int i = 0; i < rrsets.length; i++) addRRset(name, response, rrsets[i], sigonly);
            }
        }
        addAuthority(response, name, zone);
        addAdditional(response);
        if (queryTSIG != null) {
            try {
                if (tsig != null) tsig.apply(response, queryTSIG);
            } catch (IOException e) {
            }
        }
        try {
            byte[] out = response.toWire();
            if (out.length > maxLength) {
                truncate(response, out.length, maxLength);
                if (tsig != null) tsig.apply(response, queryTSIG);
            }
        } catch (IOException e) {
        }
        return response;
    }
----------------------------------------
    Message generateReply(Message query, byte[] in, Socket s) {
        boolean badversion;
        int maxLength;
        boolean sigonly;
        if (query.getHeader().getOpcode() != Opcode.QUERY) return errorMessage(query, Rcode.NOTIMPL);
        Record queryRecord = query.getQuestion();
        TSIGRecord queryTSIG = query.getTSIG();
        TSIG tsig = null;
        if (queryTSIG != null) {
            tsig = findTSIG(queryTSIG.getName());
            if (!tsig.verify(query, in, null)) return formerrMessage(in);
        }
        OPTRecord queryOPT = query.getOPT();
        if (queryOPT != null && queryOPT.getVersion() > 0) badversion = true;
        if (s != null) maxLength = 65535; else if (queryOPT != null) maxLength = queryOPT.getPayloadSize(); else maxLength = 512;
        Message response = new Message();
        response.getHeader().setID(query.getHeader().getID());
        response.getHeader().setFlag(Flags.QR);
        response.addRecord(queryRecord, Section.QUESTION);
        Name name = queryRecord.getName();
        short type = queryRecord.getType();
        short dclass = queryRecord.getDClass();
        if (type == Type.AXFR && s != null) return doAXFR(name, query, s);
        if (!Type.isRR(type) && type != Type.ANY) return errorMessage(query, Rcode.NOTIMPL);
        if (type == Type.SIG) {
            type = Type.ANY;
            sigonly = true;
        } else sigonly = false;
        Zone zone = findBestZone(name);
        if (zone != null) {
            response.getHeader().setFlag(Flags.AA);
            SetResponse zr = zone.findRecords(name, type);
            if (zr.isNXDOMAIN()) response.getHeader().setRcode(Rcode.NXDOMAIN);
            Vector backtrace = zr.backtrace();
            if (backtrace != null) {
                Enumeration e = backtrace.elements();
                while (e.hasMoreElements()) {
                    Record cname = (Record) e.nextElement();
                    response.addRecord(cname, Section.ANSWER);
                }
            }
            if (zr.isSuccessful()) {
                RRset[] rrsets = zr.answers();
                for (int i = 0; i < rrsets.length; i++) addRRset(name, response, rrsets[i], sigonly);
            }
        } else {
            SetResponse cr;
            cr = cache.lookupRecords(name, type, dclass, Credibility.NONAUTH_ANSWER);
            Vector backtrace = cr.backtrace();
            if (backtrace != null) {
                Enumeration e = backtrace.elements();
                while (e.hasMoreElements()) {
                    Record cname = (Record) e.nextElement();
                    response.addRecord(cname, Section.ANSWER);
                }
                if (!cr.isSuccessful()) response.getHeader().setRcode(Rcode.NXDOMAIN);
            }
            if (cr.isSuccessful()) {
                RRset[] rrsets = cr.answers();
                for (int i = 0; i < rrsets.length; i++) addRRset(name, response, rrsets[i], sigonly);
            }
        }
        addAuthority(response, name, zone);
        addAdditional(response);
        if (queryTSIG != null) {
            try {
                if (tsig != null) tsig.apply(response, queryTSIG);
            } catch (IOException e) {
            }
        }
        try {
            byte[] out = response.toWire();
            if (out.length > maxLength) {
                truncate(response, out.length, maxLength);
                if (tsig != null) tsig.apply(response, queryTSIG);
            }
        } catch (IOException e) {
        }
        return response;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1760314.java,37,120
selected,2289946.java,84,159
----------------------------------------
    public int compareRowsByColumn(int row1, int row2, int column) {
        Class type = model.getColumnClass(column);
        TableModel data = model;
        Object o1 = data.getValueAt(row1, column);
        Object o2 = data.getValueAt(row2, column);
        if (o1 == null && o2 == null) {
            return 0;
        } else if (o1 == null) {
            return -1;
        } else if (o2 == null) {
            return 1;
        }
        if (type.getSuperclass() == java.lang.Number.class) {
            Number n1 = (Number) data.getValueAt(row1, column);
            double d1 = n1.doubleValue();
            Number n2 = (Number) data.getValueAt(row2, column);
            double d2 = n2.doubleValue();
            if (d1 < d2) {
                return -1;
            } else if (d1 > d2) {
                return 1;
            } else {
                return 0;
            }
        } else if (type == java.lang.Integer.class) {
            int d1 = ((Integer) data.getValueAt(row1, column)).intValue();
            int d2 = ((Integer) data.getValueAt(row2, column)).intValue();
            if (d1 < d2) {
                return -1;
            } else if (d1 > d2) {
                return 1;
            } else {
                return 0;
            }
        } else if (type == java.util.Date.class) {
            Date d1 = (Date) data.getValueAt(row1, column);
            long n1 = d1.getTime();
            Date d2 = (Date) data.getValueAt(row2, column);
            long n2 = d2.getTime();
            if (n1 < n2) {
                return -1;
            } else if (n1 > n2) {
                return 1;
            } else {
                return 0;
            }
        } else if (type == String.class) {
            String s1 = (String) data.getValueAt(row1, column);
            String s2 = (String) data.getValueAt(row2, column);
            int result = s1.compareTo(s2);
            if (result < 0) {
                return -1;
            } else if (result > 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (type == Boolean.class) {
            Boolean bool1 = (Boolean) data.getValueAt(row1, column);
            boolean b1 = bool1.booleanValue();
            Boolean bool2 = (Boolean) data.getValueAt(row2, column);
            boolean b2 = bool2.booleanValue();
            if (b1 == b2) {
                return 0;
            } else if (b1) {
                return 1;
            } else {
                return -1;
            }
        } else {
            Object v1 = data.getValueAt(row1, column);
            String s1 = v1.toString();
            Object v2 = data.getValueAt(row2, column);
            String s2 = v2.toString();
            int result = s1.compareTo(s2);
            if (result < 0) {
                return -1;
            } else if (result > 0) {
                return 1;
            } else {
                return 0;
            }
        }
    }
----------------------------------------
    public int compareRowsByColumn(int row1, int row2, int column) {
        Class type = model.getColumnClass(column);
        TableModel data = model;
        Object o1 = data.getValueAt(row1, column);
        Object o2 = data.getValueAt(row2, column);
        if (o1 == null && o2 == null) {
            return 0;
        } else if (o1 == null) {
            return -1;
        } else if (o2 == null) {
            return 1;
        }
        if (type.getSuperclass() == java.lang.Number.class) {
            Number n1 = (Number) data.getValueAt(row1, column);
            double d1 = n1.doubleValue();
            Number n2 = (Number) data.getValueAt(row2, column);
            double d2 = n2.doubleValue();
            if (d1 < d2) {
                return -1;
            } else if (d1 > d2) {
                return 1;
            } else {
                return 0;
            }
        } else if (type == java.util.Date.class) {
            Date d1 = (Date) data.getValueAt(row1, column);
            long n1 = d1.getTime();
            Date d2 = (Date) data.getValueAt(row2, column);
            long n2 = d2.getTime();
            if (n1 < n2) {
                return -1;
            } else if (n1 > n2) {
                return 1;
            } else {
                return 0;
            }
        } else if (type == String.class) {
            String s1 = (String) data.getValueAt(row1, column);
            s1 = s1.toLowerCase();
            String s2 = (String) data.getValueAt(row2, column);
            s2 = s2.toLowerCase();
            int result = s1.compareTo(s2);
            if (result < 0) {
                return -1;
            } else if (result > 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (type == Boolean.class) {
            Boolean bool1 = (Boolean) data.getValueAt(row1, column);
            boolean b1 = bool1.booleanValue();
            Boolean bool2 = (Boolean) data.getValueAt(row2, column);
            boolean b2 = bool2.booleanValue();
            if (b1 == b2) {
                return 0;
            } else if (b1) {
                return 1;
            } else {
                return -1;
            }
        } else {
            Object v1 = data.getValueAt(row1, column);
            String s1 = v1.toString();
            Object v2 = data.getValueAt(row2, column);
            String s2 = v2.toString();
            int result = s1.compareTo(s2);
            if (result < 0) {
                return -1;
            } else if (result > 0) {
                return 1;
            } else {
                return 0;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,50141.java,90,172
default,104991.java,90,172
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,15109.java,90,172
default,37180.java,90,172
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,54008.java,90,172
default,116283.java,90,172
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56686.java,90,172
default,33993.java,90,172
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,18888.java,90,172
default,2039.java,90,172
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,2039.java,90,172
default,107629.java,91,173
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6658.java,90,172
default,50141.java,90,172
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,74316.java,90,172
default,121896.java,90,172
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115041.java,90,172
default,115561.java,90,172
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,22134.java,90,172
default,83354.java,90,172
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1835476.java,59,129
selected,2435715.java,57,119
----------------------------------------
    public void sort(String pColumn, String pSortDirection) {
        boolean up = true;
        if (!"u".equals(pSortDirection)) {
            up = false;
        }
        if ("usename".equals(pColumn)) {
            fComparator = new StringComparator();
            String[] temp = new String[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getUsename();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("usesysid".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getUsesysid();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("usecreatedb".equals(pColumn)) {
            Sorter sorter = new Sorter();
            boolean[] temp = new boolean[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getUsecreatedb();
            }
            fSortOrder = sorter.sortBoolean(temp, fSortOrder, up);
        }
        if ("usesuper".equals(pColumn)) {
            Sorter sorter = new Sorter();
            boolean[] temp = new boolean[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getUsesuper();
            }
            fSortOrder = sorter.sortBoolean(temp, fSortOrder, up);
        }
        if ("usecatupd".equals(pColumn)) {
            Sorter sorter = new Sorter();
            boolean[] temp = new boolean[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getUsecatupd();
            }
            fSortOrder = sorter.sortBoolean(temp, fSortOrder, up);
        }
        if ("passwd".equals(pColumn)) {
            fComparator = new StringComparator();
            String[] temp = new String[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getPasswd();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("valuntil".equals(pColumn)) {
            fComparator = new TimestampComparator();
            java.sql.Timestamp[] temp = new java.sql.Timestamp[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getValuntil();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("useconfig".equals(pColumn)) {
            fComparator = new ObjectComparator();
            Object[] temp = new Object[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getUseconfig();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        fSortedColumn = pColumn;
    }
----------------------------------------
    public void sort(String pColumn, String pSortDirection) {
        boolean up = true;
        if (!"u".equals(pSortDirection)) {
            up = false;
        }
        if ("id".equals(pColumn)) {
            Sorter sorter = new Sorter();
            long[] temp = new long[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getId();
            }
            fSortOrder = sorter.sortLong(temp, fSortOrder, up);
        }
        if ("shortName".equals(pColumn)) {
            fComparator = new StringComparator();
            String[] temp = new String[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getShortName();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("name".equals(pColumn)) {
            fComparator = new StringComparator();
            String[] temp = new String[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getName();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("password".equals(pColumn)) {
            fComparator = new StringComparator();
            String[] temp = new String[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getPassword();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("token".equals(pColumn)) {
            fComparator = new StringComparator();
            String[] temp = new String[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getToken();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("validFrom".equals(pColumn)) {
            fComparator = new DateComparator();
            java.sql.Date[] temp = new java.sql.Date[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getValidFrom();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        if ("validTo".equals(pColumn)) {
            fComparator = new DateComparator();
            java.sql.Date[] temp = new java.sql.Date[fTableData.length];
            for (int i = 0; i < temp.length; i++) {
                temp[i] = fTableData[i].getValidTo();
            }
            sort(temp, 0, temp.length - 1, up);
        }
        fSortedColumn = pColumn;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,50362.java,132,205
default,42775.java,139,215
----------------------------------------
    protected void writeContents() throws IOException {
        parseFormData();
        String filename = getParameter(FILE_PARAM);
        if (filename == null) ;
        Element file = findFile(filename);
        if (file == null) {
            sendNoSuchFileMessage(filename);
            return;
        }
        File result = computePath(file, false);
        if (!metaPathVariables.isEmpty()) {
            pathVariables = metaPathVariables;
            pathVariableNames = metaPathVariableNames;
            displayNeedInfoForm(filename, null, false, MISSING_META, file);
            return;
        }
        if (result == null && !needPathInfo()) {
            sendNoSuchFileMessage(filename);
            return;
        }
        if (result == null) {
            displayNeedInfoForm(filename, result, false, MISSING_INFO, file);
            return;
        }
        if (!result.exists()) {
            if (getParameter(CONFIRM_PARAM) == null) {
                displayNeedInfoForm(filename, result, false, CREATE_CONFIRM, file);
                return;
            }
            if (isDirectory) {
                if (!result.mkdirs()) {
                    sendCopyTemplateError("Could not create the directory '" + result.getPath() + "'.");
                    return;
                }
            }
        }
        if (result.exists()) {
            redirectTo(filename, result);
            return;
        }
        savePathInfo();
        File template = computePath(file, true);
        if (!metaPathVariables.isEmpty()) {
            pathVariables = metaPathVariables;
            pathVariableNames = metaPathVariableNames;
            displayNeedInfoForm(filename, null, true, MISSING_META, file);
            return;
        }
        if (!foundTemplate) {
            restorePathInfo();
            displayNeedInfoForm(filename, result, false, CANNOT_LOCATE, file);
            return;
        }
        String templateURL = null;
        if (isTemplateURL(template)) try {
            templateURL = template.toURL().toString();
            templateURL = templateURL.substring(templateURL.indexOf(TEMPLATE_ROOT_UNIX) + TEMPLATE_ROOT_UNIX.length() - 1);
        } catch (MalformedURLException mue) {
        }
        if (template == null || (templateURL == null && !template.exists())) {
            displayNeedInfoForm(filename, template, true, MISSING_INFO, file);
            return;
        }
        File resultDir = result.getParentFile();
        if (!resultDir.exists()) if (!resultDir.mkdirs()) {
            sendCopyTemplateError("Could not create the directory '" + resultDir.getPath() + "'.");
            return;
        }
        if (copyFile(template, templateURL, result) == false) {
            sendCopyTemplateError("Could not copy '" + template.getPath() + "' to '" + result.getPath() + "'.");
            return;
        }
        redirectTo(filename, result);
    }
----------------------------------------
    protected void writeContents() throws IOException {
        parseFormData();
        String filename = getParameter(FILE_PARAM);
        if (filename == null) ;
        Element file = findFile(filename);
        if (file == null) {
            sendNoSuchFileMessage(filename);
            return;
        }
        File result = computePath(file, false);
        if (!metaPathVariables.isEmpty()) {
            pathVariables = metaPathVariables;
            pathVariableNames = metaPathVariableNames;
            displayNeedInfoForm(filename, null, false, MISSING_META, file);
            return;
        }
        if (result == null && !needPathInfo()) {
            sendNoSuchFileMessage(filename);
            return;
        }
        if (result == null) {
            displayNeedInfoForm(filename, result, false, MISSING_INFO, file);
            return;
        }
        if (!result.exists()) {
            if (getParameter(CONFIRM_PARAM) == null) {
                displayNeedInfoForm(filename, result, false, CREATE_CONFIRM, file);
                return;
            }
            if (isDirectory) {
                if (!result.mkdirs()) {
                    String message = resources.format("Create_Directory_Error_FMT", HTMLUtils.escapeEntities(result.getPath()));
                    sendCopyTemplateError(message);
                    return;
                }
            }
        }
        if (result.exists()) {
            redirectTo(filename, result);
            return;
        }
        savePathInfo();
        File template = computePath(file, true);
        if (!metaPathVariables.isEmpty()) {
            pathVariables = metaPathVariables;
            pathVariableNames = metaPathVariableNames;
            displayNeedInfoForm(filename, null, true, MISSING_META, file);
            return;
        }
        if (!foundTemplate) {
            restorePathInfo();
            displayNeedInfoForm(filename, result, false, CANNOT_LOCATE, file);
            return;
        }
        String templateURL = null;
        if (isTemplateURL(template)) try {
            templateURL = template.toURL().toString();
            templateURL = templateURL.substring(templateURL.indexOf(TEMPLATE_ROOT_UNIX) + TEMPLATE_ROOT_UNIX.length() - 1);
        } catch (MalformedURLException mue) {
        }
        if (template == null || (templateURL == null && !template.exists())) {
            displayNeedInfoForm(filename, template, true, MISSING_INFO, file);
            return;
        }
        File resultDir = result.getParentFile();
        if (!resultDir.exists()) if (!resultDir.mkdirs()) {
            String message = resources.format("Create_Directory_Error_FMT", HTMLUtils.escapeEntities(resultDir.getPath()));
            sendCopyTemplateError(message);
            return;
        }
        if (copyFile(template, templateURL, result) == false) {
            String message = resources.format("Copy_File_Error_FMT", HTMLUtils.escapeEntities(template.getPath()), HTMLUtils.escapeEntities(result.getPath()));
            sendCopyTemplateError(message);
            return;
        }
        redirectTo(filename, result);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1438761.java,792,868
selected,1438761.java,792,868
----------------------------------------
    public void play(SocketObject objectToPlay) {
        try {
            new Timer().schedule(new GetArt(), 100);
            new Timer().schedule(new GetWiki(), 200);
            MusicBoxView.playing = true;
            MusicBoxView.timeSkipped = 0;
            MusicBoxView.jLabel2.setText(currentTrack.getTrackLength());
            String time = currentTrack.getTrackLength();
            SimpleDateFormat format = new SimpleDateFormat("mm:ss");
            Date d = format.parse(time);
            Calendar cal = Calendar.getInstance();
            cal.setTime(d);
            int t = ((cal.get(Calendar.MINUTE) * 60) + cal.get(Calendar.SECOND));
            MusicBoxView.trackLength = (((double) t));
        } catch (ParseException ex) {
            mbv.stop();
            MusicBoxView.showErrorDialog(ex);
        }
        if (currentTrack.getFile().toLowerCase().endsWith(".flac")) {
            FlacAudioFileReader fafr = new FlacAudioFileReader();
            try {
                AudioInputStream flacAudioInputStream = fafr.getAudioInputStream(new ByteArrayInputStream(objectToPlay.getAudioBytes()));
                AudioFormat format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, 44100.0F, 16, 2, 4, 44100.0F, false);
                Flac2PcmAudioInputStream f2pcmStream = new Flac2PcmAudioInputStream(flacAudioInputStream, format, 100);
                din = AudioSystem.getAudioInputStream(format, f2pcmStream);
                rawplay(format, din);
            } catch (UnsupportedAudioFileException ex) {
                MusicBoxView.showErrorDialog(ex);
            } catch (IOException ex) {
                MusicBoxView.showErrorDialog(ex);
            } catch (LineUnavailableException ex) {
                MusicBoxView.showErrorDialog(ex);
            }
        } else {
            byte[] buf = objectToPlay.getAudioBytes();
            fileLength = buf.length;
            ByteArrayInputStream bais = new ByteArrayInputStream(buf);
            try {
                in = AudioSystem.getAudioInputStream(bais);
            } catch (Exception ex1) {
                MusicBoxView.showErrorDialog(ex1);
                Bitstream m = new Bitstream(bais);
                long start = m.header_pos();
                fileLength = fileLength - start;
                try {
                    m.close();
                } catch (Exception ex) {
                    MusicBoxView.showErrorDialog(ex);
                }
                bais = new ByteArrayInputStream(buf);
                bais.skip(start);
                try {
                    in = AudioSystem.getAudioInputStream(bais);
                } catch (UnsupportedAudioFileException ex) {
                    MusicBoxView.showErrorDialog(ex);
                } catch (IOException ex) {
                    MusicBoxView.showErrorDialog(ex);
                }
            }
            din = null;
            if (in != null) {
                try {
                    AudioFormat baseFormat = in.getFormat();
                    decodedFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, baseFormat.getSampleRate(), 16, baseFormat.getChannels(), baseFormat.getChannels() * 2, baseFormat.getSampleRate(), false);
                    din = AudioSystem.getAudioInputStream(decodedFormat, in);
                    rawplay(decodedFormat, din);
                    in.close();
                } catch (IOException ex) {
                    MusicBoxView.showErrorDialog(ex);
                } catch (LineUnavailableException ex) {
                    MusicBoxView.showErrorDialog(ex);
                }
            }
        }
        MusicBoxView.changed = 0;
        MusicBoxView.timeSkipped = 0;
    }
----------------------------------------
    public void play(SocketObject objectToPlay) {
        try {
            new Timer().schedule(new GetArt(), 100);
            new Timer().schedule(new GetWiki(), 200);
            MusicBoxView.playing = true;
            MusicBoxView.timeSkipped = 0;
            MusicBoxView.jLabel2.setText(currentTrack.getTrackLength());
            String time = currentTrack.getTrackLength();
            SimpleDateFormat format = new SimpleDateFormat("mm:ss");
            Date d = format.parse(time);
            Calendar cal = Calendar.getInstance();
            cal.setTime(d);
            int t = ((cal.get(Calendar.MINUTE) * 60) + cal.get(Calendar.SECOND));
            MusicBoxView.trackLength = (((double) t));
        } catch (ParseException ex) {
            mbv.stop();
            MusicBoxView.showErrorDialog(ex);
        }
        if (currentTrack.getFile().toLowerCase().endsWith(".flac")) {
            FlacAudioFileReader fafr = new FlacAudioFileReader();
            try {
                AudioInputStream flacAudioInputStream = fafr.getAudioInputStream(new ByteArrayInputStream(objectToPlay.getAudioBytes()));
                AudioFormat format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, 44100.0F, 16, 2, 4, 44100.0F, false);
                Flac2PcmAudioInputStream f2pcmStream = new Flac2PcmAudioInputStream(flacAudioInputStream, format, 100);
                din = AudioSystem.getAudioInputStream(format, f2pcmStream);
                rawplay(format, din);
            } catch (UnsupportedAudioFileException ex) {
                MusicBoxView.showErrorDialog(ex);
            } catch (IOException ex) {
                MusicBoxView.showErrorDialog(ex);
            } catch (LineUnavailableException ex) {
                MusicBoxView.showErrorDialog(ex);
            }
        } else {
            byte[] buf = objectToPlay.getAudioBytes();
            fileLength = buf.length;
            ByteArrayInputStream bais = new ByteArrayInputStream(buf);
            try {
                in = AudioSystem.getAudioInputStream(bais);
            } catch (Exception ex1) {
                MusicBoxView.showErrorDialog(ex1);
                Bitstream m = new Bitstream(bais);
                long start = m.header_pos();
                fileLength = fileLength - start;
                try {
                    m.close();
                } catch (Exception ex) {
                    MusicBoxView.showErrorDialog(ex);
                }
                bais = new ByteArrayInputStream(buf);
                bais.skip(start);
                try {
                    in = AudioSystem.getAudioInputStream(bais);
                } catch (UnsupportedAudioFileException ex) {
                    MusicBoxView.showErrorDialog(ex);
                } catch (IOException ex) {
                    MusicBoxView.showErrorDialog(ex);
                }
            }
            din = null;
            if (in != null) {
                try {
                    AudioFormat baseFormat = in.getFormat();
                    decodedFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, baseFormat.getSampleRate(), 16, baseFormat.getChannels(), baseFormat.getChannels() * 2, baseFormat.getSampleRate(), false);
                    din = AudioSystem.getAudioInputStream(decodedFormat, in);
                    rawplay(decodedFormat, din);
                    in.close();
                } catch (IOException ex) {
                    MusicBoxView.showErrorDialog(ex);
                } catch (LineUnavailableException ex) {
                    MusicBoxView.showErrorDialog(ex);
                }
            }
        }
        MusicBoxView.changed = 0;
        MusicBoxView.timeSkipped = 0;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2242014.java,388,459
selected,2095100.java,456,527
----------------------------------------
    public Response serveFile(String uri, Properties header, File homeDir, boolean allowDirectoryListing) {
        if (!homeDir.isDirectory()) return new Response(HTTP_INTERNALERROR, MIME_PLAINTEXT, "INTERNAL ERRROR: serveFile(): given homeDir is not a directory.");
        uri = uri.trim().replace(File.separatorChar, '/');
        if (uri.indexOf('?') >= 0) uri = uri.substring(0, uri.indexOf('?'));
        if (uri.startsWith("..") || uri.endsWith("..") || uri.indexOf("../") >= 0) return new Response(HTTP_FORBIDDEN, MIME_PLAINTEXT, "FORBIDDEN: Won't serve ../ for security reasons.");
        File f = new File(homeDir, uri);
        if (!f.exists()) return new Response(HTTP_NOTFOUND, MIME_PLAINTEXT, "Error 404, file not found.");
        if (f.isDirectory()) {
            if (!uri.endsWith("/")) {
                uri += "/";
                Response r = new Response(HTTP_REDIRECT, MIME_HTML, "<html><body>Redirected: <a href=\"" + uri + "\">" + uri + "</a></body></html>");
                r.addHeader("Location", uri);
                return r;
            }
            if (new File(f, "index.html").exists()) f = new File(homeDir, uri + "/index.html"); else if (new File(f, "index.htm").exists()) f = new File(homeDir, uri + "/index.htm"); else if (allowDirectoryListing) {
                String[] files = f.list();
                String msg = "<html><body><h1>Directory " + uri + "</h1><br/>";
                if (uri.length() > 1) {
                    String u = uri.substring(0, uri.length() - 1);
                    int slash = u.lastIndexOf('/');
                    if (slash >= 0 && slash < u.length()) msg += "<b><a href=\"" + uri.substring(0, slash + 1) + "\">..</a></b><br/>";
                }
                for (int i = 0; i < files.length; ++i) {
                    File curFile = new File(f, files[i]);
                    boolean dir = curFile.isDirectory();
                    if (dir) {
                        msg += "<b>";
                        files[i] += "/";
                    }
                    msg += "<a href=\"" + encodeUri(uri + files[i]) + "\">" + files[i] + "</a>";
                    if (curFile.isFile()) {
                        long len = curFile.length();
                        msg += " &nbsp;<font size=2>(";
                        if (len < 1024) msg += curFile.length() + " bytes"; else if (len < 1024 * 1024) msg += curFile.length() / 1024 + "." + (curFile.length() % 1024 / 10 % 100) + " KB"; else msg += curFile.length() / (1024 * 1024) + "." + curFile.length() % (1024 * 1024) / 10 % 100 + " MB";
                        msg += ")</font>";
                    }
                    msg += "<br/>";
                    if (dir) msg += "</b>";
                }
                return new Response(HTTP_OK, MIME_HTML, msg);
            } else {
                return new Response(HTTP_FORBIDDEN, MIME_PLAINTEXT, "FORBIDDEN: No directory listing.");
            }
        }
        try {
            String mime = null;
            int dot = f.getCanonicalPath().lastIndexOf('.');
            if (dot >= 0) mime = (String) theMimeTypes.get(f.getCanonicalPath().substring(dot + 1).toLowerCase());
            if (mime == null) mime = MIME_DEFAULT_BINARY;
            long startFrom = 0;
            String range = header.getProperty("Range");
            if (range != null) {
                if (range.startsWith("bytes=")) {
                    range = range.substring("bytes=".length());
                    int minus = range.indexOf('-');
                    if (minus > 0) range = range.substring(0, minus);
                    try {
                        startFrom = Long.parseLong(range);
                    } catch (NumberFormatException nfe) {
                    }
                }
            }
            FileInputStream fis = new FileInputStream(f);
            fis.skip(startFrom);
            Response r = new Response(HTTP_OK, mime, fis);
            r.addHeader("Content-length", "" + (f.length() - startFrom));
            r.addHeader("Content-range", "" + startFrom + "-" + (f.length() - 1) + "/" + f.length());
            return r;
        } catch (IOException ioe) {
            return new Response(HTTP_FORBIDDEN, MIME_PLAINTEXT, "FORBIDDEN: Reading file failed.");
        }
    }
----------------------------------------
    public Response serveFile(String uri, Properties header, File homeDir, boolean allowDirectoryListing) {
        if (!homeDir.isDirectory()) return new Response(HTTP_INTERNALERROR, MIME_PLAINTEXT, "INTERNAL ERRROR: serveFile(): given homeDir is not a directory.");
        uri = uri.trim().replace(File.separatorChar, '/');
        if (uri.indexOf('?') >= 0) uri = uri.substring(0, uri.indexOf('?'));
        if (uri.startsWith("..") || uri.endsWith("..") || uri.indexOf("../") >= 0) return new Response(HTTP_FORBIDDEN, MIME_PLAINTEXT, "FORBIDDEN: Won't serve ../ for security reasons.");
        File f = new File(homeDir, uri);
        if (!f.exists()) return new Response(HTTP_NOTFOUND, MIME_PLAINTEXT, "Error 404, file not found.");
        if (f.isDirectory()) {
            if (!uri.endsWith("/")) {
                uri += "/";
                Response r = new Response(HTTP_REDIRECT, MIME_HTML, "<html><body>Redirected: <a href=\"" + uri + "\">" + uri + "</a></body></html>");
                r.addHeader("Location", uri);
                return r;
            }
            if (new File(f, "index.html").exists()) f = new File(homeDir, uri + "/index.html"); else if (new File(f, "index.htm").exists()) f = new File(homeDir, uri + "/index.htm"); else if (allowDirectoryListing) {
                String[] files = f.list();
                String msg = "<html><body><h1>Directory " + uri + "</h1><br/>";
                if (uri.length() > 1) {
                    String u = uri.substring(0, uri.length() - 1);
                    int slash = u.lastIndexOf('/');
                    if (slash >= 0 && slash < u.length()) msg += "<b><a href=\"" + uri.substring(0, slash + 1) + "\">..</a></b><br/>";
                }
                for (int i = 0; i < files.length; ++i) {
                    File curFile = new File(f, files[i]);
                    boolean dir = curFile.isDirectory();
                    if (dir) {
                        msg += "<b>";
                        files[i] += "/";
                    }
                    msg += "<a href=\"" + encodeUri(uri + files[i]) + "\">" + files[i] + "</a>";
                    if (curFile.isFile()) {
                        long len = curFile.length();
                        msg += " &nbsp;<font size=2>(";
                        if (len < 1024) msg += curFile.length() + " bytes"; else if (len < 1024 * 1024) msg += curFile.length() / 1024 + "." + (curFile.length() % 1024 / 10 % 100) + " KB"; else msg += curFile.length() / (1024 * 1024) + "." + curFile.length() % (1024 * 1024) / 10 % 100 + " MB";
                        msg += ")</font>";
                    }
                    msg += "<br/>";
                    if (dir) msg += "</b>";
                }
                return new Response(HTTP_OK, MIME_HTML, msg);
            } else {
                return new Response(HTTP_FORBIDDEN, MIME_PLAINTEXT, "FORBIDDEN: No directory listing.");
            }
        }
        try {
            String mime = null;
            int dot = f.getCanonicalPath().lastIndexOf('.');
            if (dot >= 0) mime = (String) theMimeTypes.get(f.getCanonicalPath().substring(dot + 1).toLowerCase());
            if (mime == null) mime = MIME_DEFAULT_BINARY;
            long startFrom = 0;
            String range = header.getProperty("Range");
            if (range != null) {
                if (range.startsWith("bytes=")) {
                    range = range.substring("bytes=".length());
                    int minus = range.indexOf('-');
                    if (minus > 0) range = range.substring(0, minus);
                    try {
                        startFrom = Long.parseLong(range);
                    } catch (NumberFormatException nfe) {
                    }
                }
            }
            FileInputStream fis = new FileInputStream(f);
            fis.skip(startFrom);
            Response r = new Response(HTTP_OK, mime, fis);
            r.addHeader("Content-length", "" + (f.length() - startFrom));
            r.addHeader("Content-range", "" + startFrom + "-" + (f.length() - 1) + "/" + f.length());
            return r;
        } catch (IOException ioe) {
            return new Response(HTTP_FORBIDDEN, MIME_PLAINTEXT, "FORBIDDEN: Reading file failed.");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,47767.java,27,99
default,89288.java,27,99
----------------------------------------
    public static void Compare(SeriesFile series) {
        DateFormat dateformat = new SimpleDateFormat("MMM/dd/yyyy");
        Calendar c1 = Calendar.getInstance();
        Date now = new Date();
        for (XMLShowInfo xmldata : series.xmlSeriesInfo) {
            TVRageShowInfo tvrage = new TVRageShowInfo(xmldata.showName);
            System.out.println("Show: " + tvrage.showName);
            System.out.println("Episode on disk: " + xmldata.season + "x" + xmldata.episode);
            if (tvrage.latestEpisodeNum.equals("")) System.out.println("Latest episode: Not posted"); else System.out.println("Latest episode:  " + tvrage.latestSeasonNum + "x" + tvrage.latestEpisodeNum + " \"" + tvrage.latestTitle + "\" airs on " + tvrage.latestAirDate);
            if (tvrage.nextEpisodeNum.equals("")) {
                System.out.println("Next episode: Not posted");
                xmldata.next = "Not posted";
            } else {
                System.out.println("Next episode:    " + tvrage.nextSeasonNum + "x" + tvrage.nextEpisodeNum + " \"" + tvrage.nextTitle + "\" airs on " + tvrage.nextAirDate + " " + tvrage.airTime);
                xmldata.next = tvrage.nextSeasonNum + "x" + tvrage.nextEpisodeNum + " \"" + tvrage.nextTitle + "\" airs on " + tvrage.airTime + " " + tvrage.nextAirDate;
            }
            System.out.println("Status: " + tvrage.status);
            System.out.println();
            if (!tvrage.latestEpisodeNum.equals("")) {
                if ((Integer.parseInt(xmldata.season) == Integer.parseInt(tvrage.latestSeasonNum)) && (Integer.parseInt(xmldata.episode) < Integer.parseInt(tvrage.latestEpisodeNum)) || (Integer.parseInt(xmldata.season) < Integer.parseInt(tvrage.latestSeasonNum))) {
                    try {
                        DateFormat airDateFormat = new SimpleDateFormat("MMM/dd/yyyy h:mm a");
                        Date epdate = airDateFormat.parse(tvrage.latestAirDate + tvrage.airTimeHour);
                        c1.setTime(epdate);
                        Date latestAirTime = c1.getTime();
                        c1.add(Calendar.DAY_OF_YEAR, 14);
                        Date twoWeeks = c1.getTime();
                        if (now.compareTo(latestAirTime) == 1 && now.compareTo(twoWeeks) == -1) {
                            xmldata = NzbSearch(tvrage, xmldata, 0);
                            continue;
                        } else {
                            if (now.compareTo(twoWeeks) == 1) {
                                System.out.println("--The latest episode search hasn't found anything for two weeks--");
                                System.out.println();
                                continue;
                            }
                        }
                    } catch (ParseException e) {
                        continue;
                    }
                }
            }
            if (!tvrage.nextEpisodeNum.equals("")) {
                if ((Integer.parseInt(xmldata.season) == Integer.parseInt(tvrage.nextSeasonNum)) && (Integer.parseInt(xmldata.episode) < Integer.parseInt(tvrage.nextEpisodeNum)) || (Integer.parseInt(xmldata.season) < Integer.parseInt(tvrage.nextSeasonNum))) {
                    try {
                        DateFormat airDateFormat = new SimpleDateFormat("MMM/dd/yyyy h:mm a");
                        Date epdate = airDateFormat.parse(tvrage.nextAirDate + tvrage.airTimeHour);
                        c1.setTime(epdate);
                        c1.add(Calendar.HOUR, -3);
                        Date nextAirTime = c1.getTime();
                        c1.add(Calendar.DAY_OF_YEAR, 14);
                        Date twoWeeks = c1.getTime();
                        if (now.compareTo(nextAirTime) == 1 && now.compareTo(twoWeeks) == -1) {
                            xmldata = NzbSearch(tvrage, xmldata, 1);
                            continue;
                        } else {
                            if (now.compareTo(twoWeeks) == 1) {
                                System.out.println("--The next episode search hasn't found anything for two weeks--");
                                System.out.println();
                                continue;
                            }
                        }
                    } catch (ParseException e) {
                        continue;
                    }
                }
            }
            System.out.println("--Latest episode already downloaded--");
            System.out.println();
        }
        series.UpdateSeriesFile();
        System.out.println("Finished");
    }
----------------------------------------
    public static void Compare(SeriesFile series) {
        DateFormat dateformat = new SimpleDateFormat("MMM/dd/yyyy");
        Calendar c1 = Calendar.getInstance();
        Date now = new Date();
        for (XMLShowInfo xmldata : series.xmlSeriesInfo) {
            TVRageShowInfo tvrage = new TVRageShowInfo(xmldata.showName, xmldata.searchBy);
            System.out.println("Show: " + tvrage.showName);
            System.out.println("Episode on disk: " + xmldata.season + "x" + xmldata.episode);
            if (tvrage.latestEpisodeNum.equals("")) System.out.println("Latest episode: Not posted"); else System.out.println("Latest episode:  " + tvrage.latestSeasonNum + "x" + tvrage.latestEpisodeNum + " \"" + tvrage.latestTitle + "\" airs on " + tvrage.latestAirDate);
            if (tvrage.nextEpisodeNum.equals("")) {
                System.out.println("Next episode: Not posted");
                xmldata.next = "Not posted";
            } else {
                System.out.println("Next episode:    " + tvrage.nextSeasonNum + "x" + tvrage.nextEpisodeNum + " \"" + tvrage.nextTitle + "\" airs on " + tvrage.nextAirDate + " " + tvrage.airTime);
                xmldata.next = tvrage.nextSeasonNum + "x" + tvrage.nextEpisodeNum + " \"" + tvrage.nextTitle + "\" airs on " + tvrage.airTime + " " + tvrage.nextAirDate;
            }
            System.out.println("Status: " + tvrage.status);
            System.out.println();
            if (!tvrage.latestEpisodeNum.equals("")) {
                if ((Integer.parseInt(xmldata.season) == Integer.parseInt(tvrage.latestSeasonNum)) && (Integer.parseInt(xmldata.episode) < Integer.parseInt(tvrage.latestEpisodeNum)) || (Integer.parseInt(xmldata.season) < Integer.parseInt(tvrage.latestSeasonNum))) {
                    try {
                        DateFormat airDateFormat = new SimpleDateFormat("MMM/dd/yyyy h:mm a");
                        Date epdate = airDateFormat.parse(tvrage.latestAirDate + tvrage.airTimeHour);
                        c1.setTime(epdate);
                        Date latestAirTime = c1.getTime();
                        c1.add(Calendar.DAY_OF_YEAR, 14);
                        Date twoWeeks = c1.getTime();
                        if (now.compareTo(latestAirTime) == 1 && now.compareTo(twoWeeks) == -1) {
                            xmldata = NzbSearch(tvrage, xmldata, 0);
                            continue;
                        } else {
                            if (now.compareTo(twoWeeks) == 1) {
                                System.out.println("--The latest episode search hasn't found anything for two weeks--");
                                System.out.println();
                                continue;
                            }
                        }
                    } catch (ParseException e) {
                        continue;
                    }
                }
            }
            if (!tvrage.nextEpisodeNum.equals("")) {
                if ((Integer.parseInt(xmldata.season) == Integer.parseInt(tvrage.nextSeasonNum)) && (Integer.parseInt(xmldata.episode) < Integer.parseInt(tvrage.nextEpisodeNum)) || (Integer.parseInt(xmldata.season) < Integer.parseInt(tvrage.nextSeasonNum))) {
                    try {
                        DateFormat airDateFormat = new SimpleDateFormat("MMM/dd/yyyy h:mm a");
                        Date epdate = airDateFormat.parse(tvrage.nextAirDate + tvrage.airTimeHour);
                        c1.setTime(epdate);
                        c1.add(Calendar.HOUR, -3);
                        Date nextAirTime = c1.getTime();
                        c1.add(Calendar.DAY_OF_YEAR, 14);
                        Date twoWeeks = c1.getTime();
                        if (now.compareTo(nextAirTime) == 1 && now.compareTo(twoWeeks) == -1) {
                            xmldata = NzbSearch(tvrage, xmldata, 1);
                            continue;
                        } else {
                            if (now.compareTo(twoWeeks) == 1) {
                                System.out.println("--The next episode search hasn't found anything for two weeks--");
                                System.out.println();
                                continue;
                            }
                        }
                    } catch (ParseException e) {
                        continue;
                    }
                }
            }
            System.out.println("--Latest episode already downloaded--");
            System.out.println();
        }
        series.UpdateSeriesFile();
        System.out.println("Finished");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2084825.java,346,416
selected,1379664.java,346,416
----------------------------------------
    public static void testCompress() {
        byte[] orig = IOUtils.load("music1.wav");
        byte[] sound = Arrays.copyOfRange(orig, 0x2C, orig.length);
        System.out.printf("Original: %d%n", sound.length);
        byte[] comp;
        byte[] rest;
        long time;
        time = System.nanoTime();
        comp = CompUtils.compress8(sound);
        System.out.printf("Compress8: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.decompress8(comp);
        System.out.printf("Decompress8: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compress16(sound);
        System.out.printf("Compress16: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.decompress16(comp);
        System.out.printf("Decompress16: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compressGZIP(sound);
        System.out.printf("CompressGZIP: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.decompressGZIP(comp);
        System.out.printf("DecompressGZIP: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compressGZIP(CompUtils.interleave16(CompUtils.difference16(sound.clone())));
        System.out.printf("Compress16+IL: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.undifference16(CompUtils.uninterleave16(CompUtils.decompressGZIP(comp)));
        System.out.printf("Decompress16+IL: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compressGZIP(CompUtils.difference8(CompUtils.interleave16(CompUtils.difference16(sound.clone()))));
        System.out.printf("Compress16+IL+D8: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.undifference16(CompUtils.uninterleave16(CompUtils.undifference8(CompUtils.decompressGZIP(comp))));
        System.out.printf("Decompress16+IL+D8: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.rle(CompUtils.interleave16(sound));
        System.out.printf("RLE: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.uninterleave16(CompUtils.unRle(comp));
        System.out.printf("UNRLE: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compressGZIP(CompUtils.rle(CompUtils.interleave16(sound)));
        System.out.printf("RLE+Gzip: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.uninterleave16(CompUtils.unRle(CompUtils.decompressGZIP(comp)));
        System.out.printf("UNRLE+Gzip: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
    }
----------------------------------------
    public static void testCompress() {
        byte[] orig = IOUtils.load("music1.wav");
        byte[] sound = Arrays.copyOfRange(orig, 0x2C, orig.length);
        System.out.printf("Original: %d%n", sound.length);
        byte[] comp;
        byte[] rest;
        long time;
        time = System.nanoTime();
        comp = CompUtils.compress8(sound);
        System.out.printf("Compress8: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.decompress8(comp);
        System.out.printf("Decompress8: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compress16(sound);
        System.out.printf("Compress16: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.decompress16(comp);
        System.out.printf("Decompress16: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compressGZIP(sound);
        System.out.printf("CompressGZIP: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.decompressGZIP(comp);
        System.out.printf("DecompressGZIP: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compressGZIP(CompUtils.interleave16(CompUtils.difference16(sound.clone())));
        System.out.printf("Compress16+IL: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.undifference16(CompUtils.uninterleave16(CompUtils.decompressGZIP(comp)));
        System.out.printf("Decompress16+IL: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compressGZIP(CompUtils.difference8(CompUtils.interleave16(CompUtils.difference16(sound.clone()))));
        System.out.printf("Compress16+IL+D8: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.undifference16(CompUtils.uninterleave16(CompUtils.undifference8(CompUtils.decompressGZIP(comp))));
        System.out.printf("Decompress16+IL+D8: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.rle(CompUtils.interleave16(sound));
        System.out.printf("RLE: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.uninterleave16(CompUtils.unRle(comp));
        System.out.printf("UNRLE: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
        time = System.nanoTime();
        comp = CompUtils.compressGZIP(CompUtils.rle(CompUtils.interleave16(sound)));
        System.out.printf("RLE+Gzip: %d in %d ms, %.2f%%%n", comp.length, (System.nanoTime() - time) / 1000000, comp.length * 100.0 / sound.length);
        time = System.nanoTime();
        rest = CompUtils.uninterleave16(CompUtils.unRle(CompUtils.decompressGZIP(comp)));
        System.out.printf("UNRLE+Gzip: %d in %d ms%n", rest.length, (System.nanoTime() - time) / 1000000);
        if (!Arrays.equals(sound, rest)) {
            System.err.println("Differs!");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,2905.java,265,321
default,43916.java,350,411
----------------------------------------
    private File computePath(Node n, boolean lookForTemplate) {
        if (n == null) {
            pathVariables = new HashMap();
            pathVariableNames = new ArrayList();
            metaPathVariables = new HashMap();
            metaPathVariableNames = new ArrayList();
            foundTemplate = false;
            return null;
        }
        File parentPath = computePath(n.getParentNode(), lookForTemplate);
        String pathVal = null;
        boolean isTemplate = false;
        if (n instanceof Element) {
            if (lookForTemplate) {
                pathVal = ((Element) n).getAttribute(TEMPLATE_PATH_ATTR);
                setTemplatePathVariables((Element) n);
            }
            if (XMLUtils.hasValue(pathVal)) isTemplate = true; else pathVal = ((Element) n).getAttribute(PATH_ATTR);
        }
        if (!XMLUtils.hasValue(pathVal)) return parentPath;
        isDirectory = DIRECTORY_TAG_NAME.equals(((Element) n).getTagName());
        String defaultPath = ((Element) n).getAttribute(DEFAULT_PATH_ATTR);
        StringTokenizer tok = new StringTokenizer(pathVal, "[]", true);
        StringBuffer path = new StringBuffer();
        String token;
        PathVariable pathVar = null;
        boolean unknownsPresent = false, firstItem = true;
        while (tok.hasMoreTokens()) {
            token = tok.nextToken();
            if ("[".equals(token)) {
                token = tok.nextToken();
                tok.nextToken();
                String impliedPath = null;
                if (firstItem && parentPath != null) impliedPath = parentPath.getPath();
                String defaultValue = null;
                if (firstItem && !tok.hasMoreTokens() && !isTemplate && XMLUtils.hasValue(defaultPath)) defaultValue = defaultPath;
                pathVar = getPathVariable(token, impliedPath, defaultValue);
                if (pathVar.isUnknown()) unknownsPresent = true; else path.append(pathVar.getValue());
            } else {
                path.append(token);
            }
            firstItem = false;
        }
        String selfPath = path.toString();
        if (unknownsPresent) {
            if (!isTemplate && XMLUtils.hasValue(defaultPath)) selfPath = defaultPath; else {
                foundTemplate = (foundTemplate || isTemplate);
                return null;
            }
        }
        File f = new File(selfPath);
        if (f.isAbsolute() || isTemplateURL(f)) foundTemplate = isTemplate; else {
            foundTemplate = (foundTemplate || isTemplate);
            if (parentPath == null) f = null; else f = new File(parentPath, selfPath);
        }
        return f;
    }
----------------------------------------
    private File computePath(Node n, boolean lookForTemplate) {
        if (n == null) {
            pathVariables = new HashMap();
            pathVariableNames = new ArrayList();
            metaPathVariables = new HashMap();
            metaPathVariableNames = new ArrayList();
            foundTemplate = false;
            return null;
        }
        File parentPath = computePath(n.getParentNode(), lookForTemplate);
        String pathVal = null;
        boolean isTemplate = false;
        if (n instanceof Element) {
            if (lookForTemplate) {
                pathVal = ((Element) n).getAttribute(TEMPLATE_PATH_ATTR);
                setTemplatePathVariables((Element) n);
            }
            if (XMLUtils.hasValue(pathVal)) {
                if ("none".equals(pathVal)) {
                    foundTemplate = isTemplate = false;
                    return null;
                } else isTemplate = true;
            } else pathVal = ((Element) n).getAttribute(PATH_ATTR);
        }
        if (!XMLUtils.hasValue(pathVal)) return parentPath;
        isDirectory = DIRECTORY_TAG_NAME.equals(((Element) n).getTagName());
        String defaultPath = ((Element) n).getAttribute(DEFAULT_PATH_ATTR);
        StringTokenizer tok = new StringTokenizer(pathVal, "[]", true);
        StringBuffer path = new StringBuffer();
        String token;
        PathVariable pathVar = null;
        boolean unknownsPresent = false, firstItem = true;
        while (tok.hasMoreTokens()) {
            token = tok.nextToken();
            if ("[".equals(token)) {
                token = tok.nextToken();
                tok.nextToken();
                String impliedPath = null;
                if (firstItem && parentPath != null) impliedPath = parentPath.getPath();
                String defaultValue = null;
                if (firstItem && !tok.hasMoreTokens() && !isTemplate && XMLUtils.hasValue(defaultPath)) defaultValue = defaultPath;
                pathVar = getPathVariable(token, impliedPath, defaultValue);
                if (pathVar.isUnknown()) unknownsPresent = true; else path.append(pathVar.getValue());
            } else {
                path.append(token);
            }
            firstItem = false;
        }
        String selfPath = path.toString();
        if (unknownsPresent) {
            if (!isTemplate && XMLUtils.hasValue(defaultPath)) selfPath = defaultPath; else {
                foundTemplate = (foundTemplate || isTemplate);
                return null;
            }
        }
        File f = new File(selfPath);
        if (f.isAbsolute() || isTemplateURL(f)) foundTemplate = isTemplate; else {
            foundTemplate = (foundTemplate || isTemplate);
            if (parentPath == null) f = null; else f = new File(parentPath, selfPath);
        }
        return f;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,10497.java,350,411
default,37733.java,301,362
----------------------------------------
    private File computePath(Node n, boolean lookForTemplate) {
        if (n == null) {
            pathVariables = new HashMap();
            pathVariableNames = new ArrayList();
            metaPathVariables = new HashMap();
            metaPathVariableNames = new ArrayList();
            foundTemplate = false;
            return null;
        }
        File parentPath = computePath(n.getParentNode(), lookForTemplate);
        String pathVal = null;
        boolean isTemplate = false;
        if (n instanceof Element) {
            if (lookForTemplate) {
                pathVal = ((Element) n).getAttribute(TEMPLATE_PATH_ATTR);
                setTemplatePathVariables((Element) n);
            }
            if (XMLUtils.hasValue(pathVal)) {
                if ("none".equals(pathVal)) {
                    foundTemplate = isTemplate = false;
                    return null;
                } else isTemplate = true;
            } else pathVal = ((Element) n).getAttribute(PATH_ATTR);
        }
        if (!XMLUtils.hasValue(pathVal)) return parentPath;
        isDirectory = DIRECTORY_TAG_NAME.equals(((Element) n).getTagName());
        String defaultPath = ((Element) n).getAttribute(DEFAULT_PATH_ATTR);
        StringTokenizer tok = new StringTokenizer(pathVal, "[]", true);
        StringBuffer path = new StringBuffer();
        String token;
        PathVariable pathVar = null;
        boolean unknownsPresent = false, firstItem = true;
        while (tok.hasMoreTokens()) {
            token = tok.nextToken();
            if ("[".equals(token)) {
                token = tok.nextToken();
                tok.nextToken();
                String impliedPath = null;
                if (firstItem && parentPath != null) impliedPath = parentPath.getPath();
                String defaultValue = null;
                if (firstItem && !tok.hasMoreTokens() && !isTemplate && XMLUtils.hasValue(defaultPath)) defaultValue = defaultPath;
                pathVar = getPathVariable(token, impliedPath, defaultValue);
                if (pathVar.isUnknown()) unknownsPresent = true; else path.append(pathVar.getValue());
            } else {
                path.append(token);
            }
            firstItem = false;
        }
        String selfPath = path.toString();
        if (unknownsPresent) {
            if (!isTemplate && XMLUtils.hasValue(defaultPath)) selfPath = defaultPath; else {
                foundTemplate = (foundTemplate || isTemplate);
                return null;
            }
        }
        File f = new File(selfPath);
        if (f.isAbsolute() || isTemplateURL(f)) foundTemplate = isTemplate; else {
            foundTemplate = (foundTemplate || isTemplate);
            if (parentPath == null) f = null; else f = new File(parentPath, selfPath);
        }
        return f;
    }
----------------------------------------
    private File computePath(Node n, boolean lookForTemplate) {
        if (n == null) {
            pathVariables = new HashMap();
            pathVariableNames = new ArrayList();
            metaPathVariables = new HashMap();
            metaPathVariableNames = new ArrayList();
            foundTemplate = false;
            return null;
        }
        File parentPath = computePath(n.getParentNode(), lookForTemplate);
        String pathVal = null;
        boolean isTemplate = false;
        if (n instanceof Element) {
            if (lookForTemplate) {
                pathVal = ((Element) n).getAttribute(TEMPLATE_PATH_ATTR);
                setTemplatePathVariables((Element) n);
            }
            if (XMLUtils.hasValue(pathVal)) {
                if ("none".equals(pathVal)) {
                    foundTemplate = isTemplate = false;
                    return null;
                } else isTemplate = true;
            } else pathVal = ((Element) n).getAttribute(PATH_ATTR);
        }
        if (!XMLUtils.hasValue(pathVal)) return parentPath;
        isDirectory = DIRECTORY_TAG_NAME.equals(((Element) n).getTagName());
        String defaultPath = ((Element) n).getAttribute(DEFAULT_PATH_ATTR);
        StringTokenizer tok = new StringTokenizer(pathVal, "[]", true);
        StringBuffer path = new StringBuffer();
        String token;
        PathVariable pathVar = null;
        boolean unknownsPresent = false, firstItem = true;
        while (tok.hasMoreTokens()) {
            token = tok.nextToken();
            if ("[".equals(token)) {
                token = tok.nextToken();
                tok.nextToken();
                String impliedPath = null;
                if (firstItem && parentPath != null) impliedPath = parentPath.getPath();
                String defaultValue = null;
                if (firstItem && !tok.hasMoreTokens() && !isTemplate && XMLUtils.hasValue(defaultPath)) defaultValue = defaultPath;
                pathVar = getPathVariable(token, impliedPath, defaultValue);
                if (pathVar.isUnknown()) unknownsPresent = true; else path.append(pathVar.getValue());
            } else {
                path.append(token);
            }
            firstItem = false;
        }
        String selfPath = path.toString();
        if (unknownsPresent) {
            if (!isTemplate && XMLUtils.hasValue(defaultPath)) selfPath = defaultPath; else {
                foundTemplate = (foundTemplate || isTemplate);
                return null;
            }
        }
        File f = new File(selfPath);
        if (f.isAbsolute() || isTemplateURL(f)) foundTemplate = isTemplate; else {
            foundTemplate = (foundTemplate || isTemplate);
            if (parentPath == null) f = null; else f = new File(parentPath, selfPath);
        }
        return f;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14153.java,183,246
default,16429.java,188,251
----------------------------------------
    byte addAnswer(Message response, Name name, int type, int dclass, int iterations, int flags) {
        SetResponse sr;
        byte rcode = Rcode.NOERROR;
        if (iterations > 6) return Rcode.NOERROR;
        if (type == Type.SIG) {
            type = Type.ANY;
            flags |= FLAG_SIGONLY;
        }
        Zone zone = findBestZone(name);
        if (zone != null) sr = zone.findRecords(name, type); else {
            Cache cache = getCache(dclass);
            sr = cache.lookupRecords(name, type, Credibility.NORMAL);
        }
        if (sr.isUnknown()) {
            addCacheNS(response, getCache(dclass), name);
        }
        if (sr.isNXDOMAIN()) {
            response.getHeader().setRcode(Rcode.NXDOMAIN);
            if (zone != null) {
                addSOA(response, zone);
                if (iterations == 0) response.getHeader().setFlag(Flags.AA);
            }
            rcode = Rcode.NXDOMAIN;
        } else if (sr.isNXRRSET()) {
            if (zone != null) {
                addSOA(response, zone);
                if (iterations == 0) response.getHeader().setFlag(Flags.AA);
            }
        } else if (sr.isDelegation()) {
            RRset nsRecords = sr.getNS();
            addRRset(nsRecords.getName(), response, nsRecords, Section.AUTHORITY, flags);
        } else if (sr.isCNAME()) {
            RRset rrset = new RRset();
            CNAMERecord cname = sr.getCNAME();
            rrset.addRR(cname);
            addRRset(name, response, rrset, Section.ANSWER, flags);
            if (zone != null && iterations == 0) response.getHeader().setFlag(Flags.AA);
            rcode = addAnswer(response, cname.getTarget(), type, dclass, iterations + 1, flags);
        } else if (sr.isDNAME()) {
            RRset rrset = new RRset();
            DNAMERecord dname = sr.getDNAME();
            rrset.addRR(dname);
            addRRset(name, response, rrset, Section.ANSWER, flags);
            Name newname;
            try {
                newname = name.fromDNAME(dname);
            } catch (NameTooLongException e) {
                return Rcode.YXDOMAIN;
            }
            rrset = new RRset();
            rrset.addRR(new CNAMERecord(name, dclass, 0, newname));
            addRRset(name, response, rrset, Section.ANSWER, flags);
            if (zone != null && iterations == 0) response.getHeader().setFlag(Flags.AA);
            rcode = addAnswer(response, newname, type, dclass, iterations + 1, flags);
        } else if (sr.isSuccessful()) {
            RRset[] rrsets = sr.answers();
            for (int i = 0; i < rrsets.length; i++) addRRset(name, response, rrsets[i], Section.ANSWER, flags);
            if (zone != null) {
                addNS(response, zone, flags);
                if (iterations == 0) response.getHeader().setFlag(Flags.AA);
            } else addCacheNS(response, getCache(dclass), name);
        }
        return rcode;
    }
----------------------------------------
    byte addAnswer(Message response, Name name, int type, int dclass, int iterations, int flags) {
        SetResponse sr;
        byte rcode = Rcode.NOERROR;
        if (iterations > 6) return Rcode.NOERROR;
        if (type == Type.SIG || type == Type.RRSIG) {
            type = Type.ANY;
            flags |= FLAG_SIGONLY;
        }
        Zone zone = findBestZone(name);
        if (zone != null) sr = zone.findRecords(name, type); else {
            Cache cache = getCache(dclass);
            sr = cache.lookupRecords(name, type, Credibility.NORMAL);
        }
        if (sr.isUnknown()) {
            addCacheNS(response, getCache(dclass), name);
        }
        if (sr.isNXDOMAIN()) {
            response.getHeader().setRcode(Rcode.NXDOMAIN);
            if (zone != null) {
                addSOA(response, zone);
                if (iterations == 0) response.getHeader().setFlag(Flags.AA);
            }
            rcode = Rcode.NXDOMAIN;
        } else if (sr.isNXRRSET()) {
            if (zone != null) {
                addSOA(response, zone);
                if (iterations == 0) response.getHeader().setFlag(Flags.AA);
            }
        } else if (sr.isDelegation()) {
            RRset nsRecords = sr.getNS();
            addRRset(nsRecords.getName(), response, nsRecords, Section.AUTHORITY, flags);
        } else if (sr.isCNAME()) {
            RRset rrset = new RRset();
            CNAMERecord cname = sr.getCNAME();
            rrset.addRR(cname);
            addRRset(name, response, rrset, Section.ANSWER, flags);
            if (zone != null && iterations == 0) response.getHeader().setFlag(Flags.AA);
            rcode = addAnswer(response, cname.getTarget(), type, dclass, iterations + 1, flags);
        } else if (sr.isDNAME()) {
            RRset rrset = new RRset();
            DNAMERecord dname = sr.getDNAME();
            rrset.addRR(dname);
            addRRset(name, response, rrset, Section.ANSWER, flags);
            Name newname;
            try {
                newname = name.fromDNAME(dname);
            } catch (NameTooLongException e) {
                return Rcode.YXDOMAIN;
            }
            rrset = new RRset();
            rrset.addRR(new CNAMERecord(name, dclass, 0, newname));
            addRRset(name, response, rrset, Section.ANSWER, flags);
            if (zone != null && iterations == 0) response.getHeader().setFlag(Flags.AA);
            rcode = addAnswer(response, newname, type, dclass, iterations + 1, flags);
        } else if (sr.isSuccessful()) {
            RRset[] rrsets = sr.answers();
            for (int i = 0; i < rrsets.length; i++) addRRset(name, response, rrsets[i], Section.ANSWER, flags);
            if (zone != null) {
                addNS(response, zone, flags);
                if (iterations == 0) response.getHeader().setFlag(Flags.AA);
            } else addCacheNS(response, getCache(dclass), name);
        }
        return rcode;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1723164.java,632,694
selected,375548.java,400,452
----------------------------------------
    private void buildMap(Document doc) throws Exception {
        Node item, mapNode;
        mapNode = doc.getDocumentElement();
        if (!"map".equals(mapNode.getNodeName())) {
            throw new Exception("Not a valid tmx map file.");
        }
        int mapWidth = getAttribute(mapNode, "width", 0);
        int mapHeight = getAttribute(mapNode, "height", 0);
        if (mapWidth > 0 && mapHeight > 0) {
            map = new Map(mapWidth, mapHeight);
        } else {
            NodeList l = doc.getElementsByTagName("dimensions");
            for (int i = 0; (item = l.item(i)) != null; i++) {
                if (item.getParentNode() == mapNode) {
                    mapWidth = getAttribute(item, "width", 0);
                    mapHeight = getAttribute(item, "height", 0);
                    if (mapWidth > 0 && mapHeight > 0) {
                        map = new Map(mapWidth, mapHeight);
                    }
                }
            }
        }
        if (map == null) {
            throw new Exception("Couldn't locate map dimensions.");
        }
        String orientation = getAttributeValue(mapNode, "orientation");
        int tileWidth = getAttribute(mapNode, "tilewidth", 0);
        int tileHeight = getAttribute(mapNode, "tileheight", 0);
        if (tileWidth > 0) {
            map.setTileWidth(tileWidth);
        }
        if (tileHeight > 0) {
            map.setTileHeight(tileHeight);
        }
        if (orientation != null) {
            setOrientation(orientation);
        } else {
            setOrientation("orthogonal");
        }
        readProperties(mapNode.getChildNodes(), map.getProperties());
        NodeList l = doc.getElementsByTagName("tileset");
        for (int i = 0; (item = l.item(i)) != null; i++) {
            map.addTileset(unmarshalTileset(item));
        }
        for (Node sibs = mapNode.getFirstChild(); sibs != null; sibs = sibs.getNextSibling()) {
            if ("layer".equals(sibs.getNodeName())) {
                MapLayer layer = readLayer(sibs);
                if (layer != null) {
                    map.addLayer(layer);
                }
            } else if ("unitgroup".equals(sibs.getNodeName())) {
                MapLayer layer = unmarshalUnitGroup(sibs);
                if (layer != null) {
                    map.addLayer(layer);
                }
            } else if ("zonegroup".equals(sibs.getNodeName())) {
                MapLayer layer = unmarshalZoneGroup(sibs);
                if (layer != null) {
                    map.addLayer(layer);
                }
            }
        }
    }
----------------------------------------
    private void buildMap(Document doc) throws Exception {
        Node item, mapNode;
        mapNode = doc.getDocumentElement();
        if (!mapNode.getNodeName().equals("map")) {
            throw new Exception("Not a valid tmx map file.");
        }
        int mapWidth = getAttribute(mapNode, "width", 0);
        int mapHeight = getAttribute(mapNode, "height", 0);
        if (mapWidth > 0 && mapHeight > 0) {
            map = new Map(mapWidth, mapHeight);
        } else {
            NodeList l = doc.getElementsByTagName("dimensions");
            for (int i = 0; (item = l.item(i)) != null; i++) {
                if (item.getParentNode() == mapNode) {
                    mapWidth = getAttribute(item, "width", 0);
                    mapHeight = getAttribute(item, "height", 0);
                    if (mapWidth > 0 && mapHeight > 0) {
                        map = new Map(mapWidth, mapHeight);
                    }
                }
            }
        }
        if (map == null) {
            throw new Exception("Couldn't locate map dimensions.");
        }
        String orientation = getAttributeValue(mapNode, "orientation");
        int tileWidth = getAttribute(mapNode, "tilewidth", 0);
        int tileHeight = getAttribute(mapNode, "tileheight", 0);
        if (tileWidth > 0) {
            map.setTileWidth(tileWidth);
        }
        if (tileHeight > 0) {
            map.setTileHeight(tileHeight);
        }
        if (orientation != null) {
            setOrientation(orientation);
        } else {
            setOrientation("orthogonal");
        }
        Properties mapProps = map.getProperties();
        for (Node sibs = mapNode.getFirstChild(); sibs != null; sibs = sibs.getNextSibling()) {
            if (sibs.getNodeName().equals("tileset")) {
                map.addTileset(unmarshalTileset(sibs));
            } else if (sibs.getNodeName().equals("property")) {
                mapProps.setProperty(getAttributeValue(sibs, "name"), getAttributeValue(sibs, "value"));
            } else if (sibs.getNodeName().equals("layer")) {
                MapLayer layer = unmarshalLayer(sibs);
                if (layer != null) {
                    map.addLayer(layer);
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59943.java,24,83
default,42859.java,23,84
----------------------------------------
    public jnamed(String conffile) throws IOException, ZoneTransferException {
        FileInputStream fs;
        List ports = new ArrayList();
        List addresses = new ArrayList();
        try {
            fs = new FileInputStream(conffile);
        } catch (Exception e) {
            System.out.println("Cannot open " + conffile);
            return;
        }
        try {
            caches = new HashMap();
            znames = new HashMap();
            TSIGs = new HashMap();
            InputStreamReader isr = new InputStreamReader(fs);
            BufferedReader br = new BufferedReader(isr);
            String line = null;
            while ((line = br.readLine()) != null) {
                StringTokenizer st = new StringTokenizer(line);
                if (!st.hasMoreTokens()) continue;
                String keyword = st.nextToken();
                if (!st.hasMoreTokens()) {
                    System.out.println("Invalid line: " + line);
                    continue;
                }
                if (keyword.charAt(0) == '#') continue;
                if (keyword.equals("primary")) addPrimaryZone(st.nextToken(), st.nextToken()); else if (keyword.equals("secondary")) addSecondaryZone(st.nextToken(), st.nextToken()); else if (keyword.equals("cache")) {
                    Cache cache = new Cache(st.nextToken());
                    caches.put(new Integer(DClass.IN), cache);
                } else if (keyword.equals("key")) {
                    String s1 = st.nextToken();
                    String s2 = st.nextToken();
                    if (st.hasMoreTokens()) addTSIG(s1, s2, st.nextToken()); else addTSIG("hmac-md5", s1, s2);
                } else if (keyword.equals("port")) {
                    ports.add(Integer.valueOf(st.nextToken()));
                } else if (keyword.equals("address")) {
                    String addr = st.nextToken();
                    addresses.add(Address.getByAddress(addr));
                } else {
                    System.out.println("unknown keyword: " + keyword);
                }
            }
            if (ports.size() == 0) ports.add(new Integer(53));
            if (addresses.size() == 0) addresses.add(Address.getByAddress("0.0.0.0"));
            Iterator iaddr = addresses.iterator();
            while (iaddr.hasNext()) {
                InetAddress addr = (InetAddress) iaddr.next();
                Iterator iport = ports.iterator();
                while (iport.hasNext()) {
                    int port = ((Integer) iport.next()).intValue();
                    addUDP(addr, port);
                    addTCP(addr, port);
                    System.out.println("jnamed: listening on " + addrport(addr, port));
                }
            }
            System.out.println("jnamed: running");
        } finally {
            fs.close();
        }
    }
----------------------------------------
    public jnamed(String conffile) throws IOException, ZoneTransferException {
        FileInputStream fs;
        InputStreamReader isr;
        BufferedReader br;
        List ports = new ArrayList();
        List addresses = new ArrayList();
        try {
            fs = new FileInputStream(conffile);
            isr = new InputStreamReader(fs);
            br = new BufferedReader(isr);
        } catch (Exception e) {
            System.out.println("Cannot open " + conffile);
            return;
        }
        try {
            caches = new HashMap();
            znames = new HashMap();
            TSIGs = new HashMap();
            String line = null;
            while ((line = br.readLine()) != null) {
                StringTokenizer st = new StringTokenizer(line);
                if (!st.hasMoreTokens()) continue;
                String keyword = st.nextToken();
                if (!st.hasMoreTokens()) {
                    System.out.println("Invalid line: " + line);
                    continue;
                }
                if (keyword.charAt(0) == '#') continue;
                if (keyword.equals("primary")) addPrimaryZone(st.nextToken(), st.nextToken()); else if (keyword.equals("secondary")) addSecondaryZone(st.nextToken(), st.nextToken()); else if (keyword.equals("cache")) {
                    Cache cache = new Cache(st.nextToken());
                    caches.put(new Integer(DClass.IN), cache);
                } else if (keyword.equals("key")) {
                    String s1 = st.nextToken();
                    String s2 = st.nextToken();
                    if (st.hasMoreTokens()) addTSIG(s1, s2, st.nextToken()); else addTSIG("hmac-md5", s1, s2);
                } else if (keyword.equals("port")) {
                    ports.add(Integer.valueOf(st.nextToken()));
                } else if (keyword.equals("address")) {
                    String addr = st.nextToken();
                    addresses.add(Address.getByAddress(addr));
                } else {
                    System.out.println("unknown keyword: " + keyword);
                }
            }
            if (ports.size() == 0) ports.add(new Integer(53));
            if (addresses.size() == 0) addresses.add(Address.getByAddress("0.0.0.0"));
            Iterator iaddr = addresses.iterator();
            while (iaddr.hasNext()) {
                InetAddress addr = (InetAddress) iaddr.next();
                Iterator iport = ports.iterator();
                while (iport.hasNext()) {
                    int port = ((Integer) iport.next()).intValue();
                    addUDP(addr, port);
                    addTCP(addr, port);
                    System.out.println("jnamed: listening on " + addrport(addr, port));
                }
            }
            System.out.println("jnamed: running");
        } finally {
            fs.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,18888.java,202,265
default,87946.java,202,265
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,15515.java,202,265
default,130814.java,202,265
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,22134.java,202,265
default,104991.java,202,265
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,7384.java,202,265
default,117641.java,202,265
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43963.java,202,265
default,26700.java,202,265
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,106637.java,202,265
default,50141.java,202,265
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1387869.java,134,194
selected,1387869.java,196,257
----------------------------------------
    public static void grab_service_macros(objects_h.service svc) {
        objects_h.serviceextinfo temp_serviceextinfo;
        long current_time;
        long duration;
        int days;
        int hours;
        int minutes;
        int seconds;
        logger.trace("entering " + cn + ".grab_service_macros");
        blue.macro_x[blue_h.MACRO_SERVICEDESC] = svc.description;
        blue.macro_x[blue_h.MACRO_SERVICEOUTPUT] = svc.plugin_output;
        blue.macro_x[blue_h.MACRO_SERVICEPERFDATA] = svc.perf_data;
        blue.macro_x[blue_h.MACRO_SERVICECHECKCOMMAND] = svc.service_check_command;
        blue.macro_x[blue_h.MACRO_SERVICECHECKTYPE] = ((svc.check_type == common_h.SERVICE_CHECK_PASSIVE) ? "PASSIVE" : "ACTIVE");
        blue.macro_x[blue_h.MACRO_SERVICESTATETYPE] = ((svc.state_type == common_h.HARD_STATE) ? "HARD" : "SOFT");
        if (svc.current_state == blue_h.STATE_OK) blue.macro_x[blue_h.MACRO_SERVICESTATE] = "OK"; else if (svc.current_state == blue_h.STATE_WARNING) blue.macro_x[blue_h.MACRO_SERVICESTATE] = "WARNING"; else if (svc.current_state == blue_h.STATE_CRITICAL) blue.macro_x[blue_h.MACRO_SERVICESTATE] = "CRITICAL"; else blue.macro_x[blue_h.MACRO_SERVICESTATE] = "UNKNOWN";
        blue.macro_x[blue_h.MACRO_SERVICESTATEID] = "" + svc.current_state;
        blue.macro_x[blue_h.MACRO_SERVICEATTEMPT] = "" + svc.current_attempt;
        blue.macro_x[blue_h.MACRO_SERVICEEXECUTIONTIME] = "" + svc.execution_time;
        blue.macro_x[blue_h.MACRO_SERVICELATENCY] = "" + svc.latency;
        blue.macro_x[blue_h.MACRO_LASTSERVICECHECK] = "" + svc.last_check;
        blue.macro_x[blue_h.MACRO_LASTSERVICESTATECHANGE] = "" + svc.last_state_change;
        blue.macro_x[blue_h.MACRO_LASTSERVICEOK] = "" + svc.last_time_ok;
        blue.macro_x[blue_h.MACRO_LASTSERVICEWARNING] = "" + svc.last_time_warning;
        blue.macro_x[blue_h.MACRO_LASTSERVICEUNKNOWN] = "" + svc.last_time_unknown;
        blue.macro_x[blue_h.MACRO_LASTSERVICECRITICAL] = "" + svc.last_time_critical;
        blue.macro_x[blue_h.MACRO_SERVICEDOWNTIME] = "" + svc.scheduled_downtime_depth;
        blue.macro_x[blue_h.MACRO_SERVICEPERCENTCHANGE] = "" + svc.percent_state_change;
        current_time = utils.currentTimeInSeconds();
        duration = (current_time - svc.last_state_change);
        blue.macro_x[blue_h.MACRO_SERVICEDURATIONSEC] = "" + duration;
        days = (int) duration / 86400;
        duration -= (days * 86400);
        hours = (int) duration / 3600;
        duration -= (hours * 3600);
        minutes = (int) duration / 60;
        duration -= (minutes * 60);
        seconds = (int) duration;
        blue.macro_x[blue_h.MACRO_SERVICEDURATION] = days + "d " + hours + "h " + minutes + "m " + seconds + "s";
        for (objects_h.servicegroup temp_servicegroup : (ArrayList<objects_h.servicegroup>) objects.servicegroup_list) {
            if (objects.is_service_member_of_servicegroup(temp_servicegroup, svc) == common_h.TRUE) {
                blue.macro_x[blue_h.MACRO_SERVICEGROUPNAME] = temp_servicegroup.group_name;
                blue.macro_x[blue_h.MACRO_SERVICEGROUPALIAS] = temp_servicegroup.alias;
                break;
            }
        }
        temp_serviceextinfo = objects.find_serviceextinfo(svc.host_name, svc.description);
        if (temp_serviceextinfo != null) {
            blue.macro_x[blue_h.MACRO_SERVICEACTIONURL] = temp_serviceextinfo.action_url;
            blue.macro_x[blue_h.MACRO_SERVICENOTESURL] = temp_serviceextinfo.notes_url;
            blue.macro_x[blue_h.MACRO_SERVICENOTES] = temp_serviceextinfo.notes;
        }
        grab_datetime_macros();
        blue.macro_x[blue_h.MACRO_SERVICEOUTPUT] = strip(blue.macro_x[blue_h.MACRO_SERVICEOUTPUT]);
        blue.macro_x[blue_h.MACRO_SERVICEPERFDATA] = strip(blue.macro_x[blue_h.MACRO_SERVICEPERFDATA]);
        blue.macro_x[blue_h.MACRO_SERVICECHECKCOMMAND] = strip(blue.macro_x[blue_h.MACRO_SERVICECHECKCOMMAND]);
        blue.macro_x[blue_h.MACRO_SERVICENOTES] = strip(blue.macro_x[blue_h.MACRO_SERVICENOTES]);
        blue.macro_x[blue_h.MACRO_SERVICEACTIONURL] = process_macros(blue.macro_x[blue_h.MACRO_SERVICEACTIONURL], blue_h.URL_ENCODE_MACRO_CHARS);
        blue.macro_x[blue_h.MACRO_SERVICENOTESURL] = process_macros(blue.macro_x[blue_h.MACRO_SERVICENOTESURL], blue_h.URL_ENCODE_MACRO_CHARS);
        logger.trace("exiting " + cn + ".grab_service_macros");
    }
----------------------------------------
    public static void grab_host_macros(objects_h.host hst) {
        objects_h.hostextinfo temp_hostextinfo;
        long current_time;
        long duration;
        int days;
        int hours;
        int minutes;
        int seconds;
        logger.trace("entering " + cn + ".grab_host_macros");
        blue.macro_x[blue_h.MACRO_HOSTNAME] = hst.name;
        blue.macro_x[blue_h.MACRO_HOSTALIAS] = hst.alias;
        blue.macro_x[blue_h.MACRO_HOSTADDRESS] = hst.address;
        if (hst.current_state == blue_h.HOST_DOWN) blue.macro_x[blue_h.MACRO_HOSTSTATE] = "DOWN"; else if (hst.current_state == blue_h.HOST_UNREACHABLE) blue.macro_x[blue_h.MACRO_HOSTSTATE] = "UNREACHABLE"; else blue.macro_x[blue_h.MACRO_HOSTSTATE] = "UP";
        blue.macro_x[blue_h.MACRO_HOSTSTATEID] = "" + hst.current_state;
        blue.macro_x[blue_h.MACRO_HOSTCHECKTYPE] = ((hst.check_type == common_h.HOST_CHECK_PASSIVE) ? "PASSIVE" : "ACTIVE");
        blue.macro_x[blue_h.MACRO_HOSTSTATETYPE] = ((hst.state_type == common_h.HARD_STATE) ? "HARD" : "SOFT");
        blue.macro_x[blue_h.MACRO_HOSTOUTPUT] = hst.plugin_output;
        blue.macro_x[blue_h.MACRO_HOSTPERFDATA] = hst.perf_data;
        blue.macro_x[blue_h.MACRO_HOSTCHECKCOMMAND] = hst.host_check_command;
        blue.macro_x[blue_h.MACRO_HOSTATTEMPT] = "" + hst.current_attempt;
        blue.macro_x[blue_h.MACRO_HOSTDOWNTIME] = "" + hst.scheduled_downtime_depth;
        blue.macro_x[blue_h.MACRO_HOSTPERCENTCHANGE] = "" + hst.percent_state_change;
        current_time = utils.currentTimeInSeconds();
        duration = (current_time - hst.last_state_change);
        blue.macro_x[blue_h.MACRO_HOSTDURATIONSEC] = "" + duration;
        days = (int) duration / 86400;
        duration -= (days * 86400);
        hours = (int) duration / 3600;
        duration -= (hours * 3600);
        minutes = (int) duration / 60;
        duration -= (minutes * 60);
        seconds = (int) duration;
        blue.macro_x[blue_h.MACRO_HOSTDURATION] = "" + days + " " + hours + " " + minutes + " " + seconds;
        blue.macro_x[blue_h.MACRO_HOSTEXECUTIONTIME] = "" + hst.execution_time;
        blue.macro_x[blue_h.MACRO_HOSTLATENCY] = "" + hst.latency;
        blue.macro_x[blue_h.MACRO_LASTHOSTCHECK] = "" + hst.last_check;
        blue.macro_x[blue_h.MACRO_LASTHOSTSTATECHANGE] = "" + hst.last_state_change;
        blue.macro_x[blue_h.MACRO_LASTHOSTUP] = "" + hst.last_time_up;
        blue.macro_x[blue_h.MACRO_LASTHOSTDOWN] = "" + hst.last_time_down;
        blue.macro_x[blue_h.MACRO_LASTHOSTUNREACHABLE] = "" + hst.last_time_unreachable;
        for (objects_h.hostgroup temp_hostgroup : (ArrayList<objects_h.hostgroup>) objects.hostgroup_list) {
            if (objects.is_host_member_of_hostgroup(temp_hostgroup, hst) == common_h.TRUE) {
                blue.macro_x[blue_h.MACRO_HOSTGROUPNAME] = temp_hostgroup.group_name;
                blue.macro_x[blue_h.MACRO_HOSTGROUPALIAS] = temp_hostgroup.alias;
                break;
            }
        }
        temp_hostextinfo = objects.find_hostextinfo(hst.name);
        if (temp_hostextinfo != null) {
            blue.macro_x[blue_h.MACRO_HOSTACTIONURL] = temp_hostextinfo.action_url;
            blue.macro_x[blue_h.MACRO_HOSTNOTESURL] = temp_hostextinfo.notes_url;
            blue.macro_x[blue_h.MACRO_HOSTNOTES] = temp_hostextinfo.notes;
        }
        grab_datetime_macros();
        blue.macro_x[blue_h.MACRO_HOSTOUTPUT] = strip(blue.macro_x[blue_h.MACRO_HOSTOUTPUT]);
        blue.macro_x[blue_h.MACRO_HOSTPERFDATA] = strip(blue.macro_x[blue_h.MACRO_HOSTPERFDATA]);
        blue.macro_x[blue_h.MACRO_HOSTCHECKCOMMAND] = strip(blue.macro_x[blue_h.MACRO_HOSTCHECKCOMMAND]);
        blue.macro_x[blue_h.MACRO_HOSTNOTES] = strip(blue.macro_x[blue_h.MACRO_HOSTNOTES]);
        blue.macro_x[blue_h.MACRO_HOSTACTIONURL] = process_macros(blue.macro_x[blue_h.MACRO_HOSTACTIONURL], blue_h.URL_ENCODE_MACRO_CHARS);
        blue.macro_x[blue_h.MACRO_HOSTNOTESURL] = process_macros(blue.macro_x[blue_h.MACRO_HOSTNOTESURL], blue_h.URL_ENCODE_MACRO_CHARS);
        logger.trace("exiting " + cn + ".grab_host_macros");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6658.java,202,265
default,12681.java,202,265
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,255050.java,167,228
selected,615198.java,185,246
----------------------------------------
    protected void performSaveAs(IProgressMonitor progressMonitor) {
        Shell shell = getSite().getShell();
        IEditorInput input = getEditorInput();
        SaveAsDialog dialog = new SaveAsDialog(shell);
        IFile original = input instanceof IFileEditorInput ? ((IFileEditorInput) input).getFile() : null;
        if (original != null) {
            dialog.setOriginalFile(original);
        }
        dialog.create();
        IDocumentProvider provider = getDocumentProvider();
        if (provider == null) {
            return;
        }
        if (provider.isDeleted(input) && original != null) {
            String message = NLS.bind(dataflowScheme.diagram.part.Messages.ModelDiagramEditor_SavingDeletedFile, original.getName());
            dialog.setErrorMessage(null);
            dialog.setMessage(message, IMessageProvider.WARNING);
        }
        if (dialog.open() == Window.CANCEL) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IPath filePath = dialog.getResult();
        if (filePath == null) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
        IFile file = workspaceRoot.getFile(filePath);
        final IEditorInput newInput = new FileEditorInput(file);
        IEditorMatchingStrategy matchingStrategy = getEditorDescriptor().getEditorMatchingStrategy();
        IEditorReference[] editorRefs = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getEditorReferences();
        for (int i = 0; i < editorRefs.length; i++) {
            if (matchingStrategy.matches(editorRefs[i], newInput)) {
                MessageDialog.openWarning(shell, dataflowScheme.diagram.part.Messages.ModelDiagramEditor_SaveAsErrorTitle, dataflowScheme.diagram.part.Messages.ModelDiagramEditor_SaveAsErrorMessage);
                return;
            }
        }
        boolean success = false;
        try {
            provider.aboutToChange(newInput);
            getDocumentProvider(newInput).saveDocument(progressMonitor, newInput, getDocumentProvider().getDocument(getEditorInput()), true);
            success = true;
        } catch (CoreException x) {
            IStatus status = x.getStatus();
            if (status == null || status.getSeverity() != IStatus.CANCEL) {
                ErrorDialog.openError(shell, dataflowScheme.diagram.part.Messages.ModelDiagramEditor_SaveErrorTitle, dataflowScheme.diagram.part.Messages.ModelDiagramEditor_SaveErrorMessage, x.getStatus());
            }
        } finally {
            provider.changed(newInput);
            if (success) {
                setInput(newInput);
            }
        }
        if (progressMonitor != null) {
            progressMonitor.setCanceled(!success);
        }
    }
----------------------------------------
    protected void performSaveAs(IProgressMonitor progressMonitor) {
        Shell shell = getSite().getShell();
        IEditorInput input = getEditorInput();
        SaveAsDialog dialog = new SaveAsDialog(shell);
        IFile original = input instanceof IFileEditorInput ? ((IFileEditorInput) input).getFile() : null;
        if (original != null) {
            dialog.setOriginalFile(original);
        }
        dialog.create();
        IDocumentProvider provider = getDocumentProvider();
        if (provider == null) {
            return;
        }
        if (provider.isDeleted(input) && original != null) {
            String message = NLS.bind(Messages.FilesystemDiagramEditor_SavingDeletedFile, original.getName());
            dialog.setErrorMessage(null);
            dialog.setMessage(message, IMessageProvider.WARNING);
        }
        if (dialog.open() == Window.CANCEL) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IPath filePath = dialog.getResult();
        if (filePath == null) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
        IFile file = workspaceRoot.getFile(filePath);
        final IEditorInput newInput = new FileEditorInput(file);
        IEditorMatchingStrategy matchingStrategy = getEditorDescriptor().getEditorMatchingStrategy();
        IEditorReference[] editorRefs = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getEditorReferences();
        for (int i = 0; i < editorRefs.length; i++) {
            if (matchingStrategy.matches(editorRefs[i], newInput)) {
                MessageDialog.openWarning(shell, Messages.FilesystemDiagramEditor_SaveAsErrorTitle, Messages.FilesystemDiagramEditor_SaveAsErrorMessage);
                return;
            }
        }
        boolean success = false;
        try {
            provider.aboutToChange(newInput);
            getDocumentProvider(newInput).saveDocument(progressMonitor, newInput, getDocumentProvider().getDocument(getEditorInput()), true);
            success = true;
        } catch (CoreException x) {
            IStatus status = x.getStatus();
            if (status == null || status.getSeverity() != IStatus.CANCEL) {
                ErrorDialog.openError(shell, Messages.FilesystemDiagramEditor_SaveErrorTitle, Messages.FilesystemDiagramEditor_SaveErrorMessage, x.getStatus());
            }
        } finally {
            provider.changed(newInput);
            if (success) {
                setInput(newInput);
            }
        }
        if (progressMonitor != null) {
            progressMonitor.setCanceled(!success);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1113584.java,230,292
selected,1113584.java,230,292
----------------------------------------
    protected void prepareParticleSystemForSaving(ParticleSystem ps) {
        List<Modifier> modifiers = ps.getModifiers();
        PointMass mass = null;
        int index = -1;
        for (Modifier modifier : modifiers) {
            if (modifier instanceof PointMass) {
                mass = (PointMass) modifier;
                if (mass.getPositionAnimator() != null) {
                    index = ps.getPanimators().indexOf(mass.getPositionAnimator());
                    mass.setPositionAnimatorIndex(index);
                } else mass.setPositionAnimatorIndex(-1);
            }
        }
        List<Generator> gens = ps.getGenerators();
        PositionAnimator panimator = null;
        ParticleBehaviour behaviour = null;
        GeneratorBehaviour genBehhaviour = null;
        SpaceAnimator animator = null;
        ParticleRender render = null;
        GeneratorSpace space = null;
        index = -1;
        for (Generator generator : gens) {
            behaviour = generator.getPb();
            if (behaviour != null) {
                index = ps.getBehaviours().indexOf(behaviour);
                generator.setParticleBehaviourIndex(index);
            } else generator.setParticleBehaviourIndex(-1);
            genBehhaviour = generator.getGb();
            if (genBehhaviour != null) {
                index = ps.getGenBehaviours().indexOf(genBehhaviour);
                generator.setGeneratorBehaviourIndex(index);
            } else generator.setGeneratorBehaviourIndex(-1);
            render = generator.getRender();
            if (render != null) {
                index = ps.getRenders().indexOf(render);
                generator.setRenderIndex(index);
            } else generator.setRenderIndex(-1);
            space = generator.getSpace();
            if (space != null) {
                index = ps.getSpaces().indexOf(space);
                generator.setSpaceIndex(index);
            } else generator.setSpaceIndex(-1);
            animator = generator.getAnimator();
            if (animator != null) {
                index = ps.getAnimators().indexOf(animator);
                generator.setSpaceAnimatorIndex(index);
            } else generator.setSpaceAnimatorIndex(-1);
            panimator = generator.getPositionAnimator();
            if (panimator != null) {
                index = ps.getPanimators().indexOf(panimator);
                generator.setPositionAnimatorIndex(index);
            } else generator.setPositionAnimatorIndex(-1);
            modifiers = generator.getModifiers();
            if (modifiers.size() > 0) {
                List<Integer> indexes = new ArrayList<Integer>();
                generator.setModifierIndexes(indexes);
                for (Modifier mod : modifiers) {
                    index = ps.getModifiers().indexOf(mod);
                    indexes.add(index);
                }
            } else generator.setModifierIndexes(null);
        }
    }
----------------------------------------
    protected void prepareParticleSystemForSaving(ParticleSystem ps) {
        List<Modifier> modifiers = ps.getModifiers();
        PointMass mass = null;
        int index = -1;
        for (Modifier modifier : modifiers) {
            if (modifier instanceof PointMass) {
                mass = (PointMass) modifier;
                if (mass.getPositionAnimator() != null) {
                    index = ps.getPanimators().indexOf(mass.getPositionAnimator());
                    mass.setPositionAnimatorIndex(index);
                } else mass.setPositionAnimatorIndex(-1);
            }
        }
        List<Generator> gens = ps.getGenerators();
        PositionAnimator panimator = null;
        ParticleBehaviour behaviour = null;
        GeneratorBehaviour genBehhaviour = null;
        SpaceAnimator animator = null;
        ParticleRender render = null;
        GeneratorSpace space = null;
        index = -1;
        for (Generator generator : gens) {
            behaviour = generator.getPb();
            if (behaviour != null) {
                index = ps.getBehaviours().indexOf(behaviour);
                generator.setParticleBehaviourIndex(index);
            } else generator.setParticleBehaviourIndex(-1);
            genBehhaviour = generator.getGb();
            if (genBehhaviour != null) {
                index = ps.getGenBehaviours().indexOf(genBehhaviour);
                generator.setGeneratorBehaviourIndex(index);
            } else generator.setGeneratorBehaviourIndex(-1);
            render = generator.getRender();
            if (render != null) {
                index = ps.getRenders().indexOf(render);
                generator.setRenderIndex(index);
            } else generator.setRenderIndex(-1);
            space = generator.getSpace();
            if (space != null) {
                index = ps.getSpaces().indexOf(space);
                generator.setSpaceIndex(index);
            } else generator.setSpaceIndex(-1);
            animator = generator.getAnimator();
            if (animator != null) {
                index = ps.getAnimators().indexOf(animator);
                generator.setSpaceAnimatorIndex(index);
            } else generator.setSpaceAnimatorIndex(-1);
            panimator = generator.getPositionAnimator();
            if (panimator != null) {
                index = ps.getPanimators().indexOf(panimator);
                generator.setPositionAnimatorIndex(index);
            } else generator.setPositionAnimatorIndex(-1);
            modifiers = generator.getModifiers();
            if (modifiers.size() > 0) {
                List<Integer> indexes = new ArrayList<Integer>();
                generator.setModifierIndexes(indexes);
                for (Modifier mod : modifiers) {
                    index = ps.getModifiers().indexOf(mod);
                    indexes.add(index);
                }
            } else generator.setModifierIndexes(null);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,17735.java,14,76
default,13075.java,14,76
----------------------------------------
    public static void main(String argv[]) {
        example.setIvar(42);
        example.setSvar((short) -31000);
        example.setLvar(65537);
        example.setUivar(123456);
        example.setUsvar(61000);
        example.setUlvar(654321);
        example.setScvar((byte) -13);
        example.setUcvar((short) 251);
        example.setCvar('S');
        example.setFvar((float) 3.14159);
        example.setDvar(2.1828);
        example.setStrvar("Hello World");
        example.setIptrvar(example.new_int(37));
        example.setPtptr(example.new_Point(37, 42));
        example.setName("Bill");
        System.out.println("Variables (values printed from Java)");
        System.out.println("ivar      =" + example.getIvar());
        System.out.println("svar      =" + example.getSvar());
        System.out.println("lvar      =" + example.getLvar());
        System.out.println("uivar     =" + example.getUivar());
        System.out.println("usvar     =" + example.getUsvar());
        System.out.println("ulvar     =" + example.getUlvar());
        System.out.println("scvar     =" + example.getScvar());
        System.out.println("ucvar     =" + example.getUcvar());
        System.out.println("fvar      =" + example.getFvar());
        System.out.println("dvar      =" + example.getDvar());
        System.out.println("cvar      =" + (char) example.getCvar());
        System.out.println("strvar    =" + example.getStrvar());
        System.out.println("cstrvar   =" + example.getCstrvar());
        System.out.println("iptrvar   =" + Long.toHexString(SWIGTYPE_p_int.getCPtr(example.getIptrvar())));
        System.out.println("name      =" + example.getName());
        System.out.println("ptptr     =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPtptr())) + example.Point_print(example.getPtptr()));
        System.out.println("pt        =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPt())) + example.Point_print(example.getPt()));
        System.out.println("\nVariables (values printed from C)");
        example.print_vars();
        System.out.println("\nNow I'm going to try and modify some read only variables");
        System.out.println("     Trying to set 'path'");
        try {
            Method m = example.class.getDeclaredMethod("setPath", new Class[] { String.class });
            m.invoke(example.class, new Object[] { "Whoa!" });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("     Trying to set 'status'");
        try {
            Method m = example.class.getDeclaredMethod("setStatus", new Class[] { Integer.class });
            m.invoke(example.class, new Object[] { new Integer(0) });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("\nI'm going to try and update a structure variable.\n");
        example.setPt(example.getPtptr());
        System.out.println("The new value is");
        example.pt_print();
        System.out.println("You should see the value" + example.Point_print(example.getPtptr()));
    }
----------------------------------------
    public static void main(String argv[]) {
        example.setIvar(42);
        example.setSvar((short) -31000);
        example.setLvar(65537);
        example.setUivar(123456);
        example.setUsvar(61000);
        example.setUlvar(654321);
        example.setScvar((byte) -13);
        example.setUcvar((short) 251);
        example.setCvar('S');
        example.setFvar((float) 3.14159);
        example.setDvar(2.1828);
        example.setStrvar("Hello World");
        example.setIptrvar(example.new_int(37));
        example.setPtptr(example.new_Point(37, 42));
        example.setName("Bill");
        System.out.println("Variables (values printed from Java)");
        System.out.println("ivar      =" + example.getIvar());
        System.out.println("svar      =" + example.getSvar());
        System.out.println("lvar      =" + example.getLvar());
        System.out.println("uivar     =" + example.getUivar());
        System.out.println("usvar     =" + example.getUsvar());
        System.out.println("ulvar     =" + example.getUlvar());
        System.out.println("scvar     =" + example.getScvar());
        System.out.println("ucvar     =" + example.getUcvar());
        System.out.println("fvar      =" + example.getFvar());
        System.out.println("dvar      =" + example.getDvar());
        System.out.println("cvar      =" + (char) example.getCvar());
        System.out.println("strvar    =" + example.getStrvar());
        System.out.println("cstrvar   =" + example.getCstrvar());
        System.out.println("iptrvar   =" + Long.toHexString(SWIGTYPE_p_int.getCPtr(example.getIptrvar())));
        System.out.println("name      =" + example.getName());
        System.out.println("ptptr     =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPtptr())) + example.Point_print(example.getPtptr()));
        System.out.println("pt        =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPt())) + example.Point_print(example.getPt()));
        System.out.println("\nVariables (values printed from C)");
        example.print_vars();
        System.out.println("\nNow I'm going to try and modify some read only variables");
        System.out.println("     Trying to set 'path'");
        try {
            Method m = example.class.getDeclaredMethod("setPath", new Class[] { String.class });
            m.invoke(example.class, new Object[] { "Whoa!" });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("     Trying to set 'status'");
        try {
            Method m = example.class.getDeclaredMethod("setStatus", new Class[] { Integer.class });
            m.invoke(example.class, new Object[] { new Integer(0) });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("\nI'm going to try and update a structure variable.\n");
        example.setPt(example.getPtptr());
        System.out.println("The new value is");
        example.pt_print();
        System.out.println("You should see the value" + example.Point_print(example.getPtptr()));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,478960.java,168,229
selected,1098434.java,167,228
----------------------------------------
    protected void performSaveAs(IProgressMonitor progressMonitor) {
        Shell shell = getSite().getShell();
        IEditorInput input = getEditorInput();
        SaveAsDialog dialog = new SaveAsDialog(shell);
        IFile original = input instanceof IFileEditorInput ? ((IFileEditorInput) input).getFile() : null;
        if (original != null) {
            dialog.setOriginalFile(original);
        }
        dialog.create();
        IDocumentProvider provider = getDocumentProvider();
        if (provider == null) {
            return;
        }
        if (provider.isDeleted(input) && original != null) {
            String message = NLS.bind(Messages.SchoolDiagramEditor_SavingDeletedFile, original.getName());
            dialog.setErrorMessage(null);
            dialog.setMessage(message, IMessageProvider.WARNING);
        }
        if (dialog.open() == Window.CANCEL) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IPath filePath = dialog.getResult();
        if (filePath == null) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
        IFile file = workspaceRoot.getFile(filePath);
        final IEditorInput newInput = new FileEditorInput(file);
        IEditorMatchingStrategy matchingStrategy = getEditorDescriptor().getEditorMatchingStrategy();
        IEditorReference[] editorRefs = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getEditorReferences();
        for (int i = 0; i < editorRefs.length; i++) {
            if (matchingStrategy.matches(editorRefs[i], newInput)) {
                MessageDialog.openWarning(shell, Messages.SchoolDiagramEditor_SaveAsErrorTitle, Messages.SchoolDiagramEditor_SaveAsErrorMessage);
                return;
            }
        }
        boolean success = false;
        try {
            provider.aboutToChange(newInput);
            getDocumentProvider(newInput).saveDocument(progressMonitor, newInput, getDocumentProvider().getDocument(getEditorInput()), true);
            success = true;
        } catch (CoreException x) {
            IStatus status = x.getStatus();
            if (status == null || status.getSeverity() != IStatus.CANCEL) {
                ErrorDialog.openError(shell, Messages.SchoolDiagramEditor_SaveErrorTitle, Messages.SchoolDiagramEditor_SaveErrorMessage, x.getStatus());
            }
        } finally {
            provider.changed(newInput);
            if (success) {
                setInput(newInput);
            }
        }
        if (progressMonitor != null) {
            progressMonitor.setCanceled(!success);
        }
    }
----------------------------------------
    protected void performSaveAs(IProgressMonitor progressMonitor) {
        Shell shell = getSite().getShell();
        IEditorInput input = getEditorInput();
        SaveAsDialog dialog = new SaveAsDialog(shell);
        IFile original = input instanceof IFileEditorInput ? ((IFileEditorInput) input).getFile() : null;
        if (original != null) {
            dialog.setOriginalFile(original);
        }
        dialog.create();
        IDocumentProvider provider = getDocumentProvider();
        if (provider == null) {
            return;
        }
        if (provider.isDeleted(input) && original != null) {
            String message = NLS.bind(org.codescale.eDependency.diagram.part.Messages.EDependencyDiagramEditor_SavingDeletedFile, original.getName());
            dialog.setErrorMessage(null);
            dialog.setMessage(message, IMessageProvider.WARNING);
        }
        if (dialog.open() == Window.CANCEL) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IPath filePath = dialog.getResult();
        if (filePath == null) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
        IFile file = workspaceRoot.getFile(filePath);
        final IEditorInput newInput = new FileEditorInput(file);
        IEditorMatchingStrategy matchingStrategy = getEditorDescriptor().getEditorMatchingStrategy();
        IEditorReference[] editorRefs = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getEditorReferences();
        for (int i = 0; i < editorRefs.length; i++) {
            if (matchingStrategy.matches(editorRefs[i], newInput)) {
                MessageDialog.openWarning(shell, org.codescale.eDependency.diagram.part.Messages.EDependencyDiagramEditor_SaveAsErrorTitle, org.codescale.eDependency.diagram.part.Messages.EDependencyDiagramEditor_SaveAsErrorMessage);
                return;
            }
        }
        boolean success = false;
        try {
            provider.aboutToChange(newInput);
            getDocumentProvider(newInput).saveDocument(progressMonitor, newInput, getDocumentProvider().getDocument(getEditorInput()), true);
            success = true;
        } catch (CoreException x) {
            IStatus status = x.getStatus();
            if (status == null || status.getSeverity() != IStatus.CANCEL) {
                ErrorDialog.openError(shell, org.codescale.eDependency.diagram.part.Messages.EDependencyDiagramEditor_SaveErrorTitle, org.codescale.eDependency.diagram.part.Messages.EDependencyDiagramEditor_SaveErrorMessage, x.getStatus());
            }
        } finally {
            provider.changed(newInput);
            if (success) {
                setInput(newInput);
            }
        }
        if (progressMonitor != null) {
            progressMonitor.setCanceled(!success);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,593263.java,446,508
selected,2108660.java,461,523
----------------------------------------
    public static String encodeBytes(byte[] source, int off, int len, int options) {
        int dontBreakLines = (options & DONT_BREAK_LINES);
        int gzip = (options & GZIP);
        if (gzip == GZIP) {
            java.io.ByteArrayOutputStream baos = null;
            java.util.zip.GZIPOutputStream gzos = null;
            Base64.OutputStream b64os = null;
            try {
                baos = new java.io.ByteArrayOutputStream();
                b64os = new Base64.OutputStream(baos, ENCODE | options);
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                gzos.write(source, off, len);
                gzos.close();
            } catch (java.io.IOException e) {
                e.printStackTrace();
                return null;
            } finally {
                try {
                    gzos.close();
                } catch (Exception e) {
                }
                try {
                    b64os.close();
                } catch (Exception e) {
                }
                try {
                    baos.close();
                } catch (Exception e) {
                }
            }
            try {
                return new String(baos.toByteArray(), PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(baos.toByteArray());
            }
        } else {
            boolean breakLines = dontBreakLines == 0;
            int len43 = len * 4 / 3;
            byte[] outBuff = new byte[(len43) + ((len % 3) > 0 ? 4 : 0) + (breakLines ? (len43 / MAX_LINE_LENGTH) : 0)];
            int d = 0;
            int e = 0;
            int len2 = len - 2;
            int lineLength = 0;
            for (; d < len2; d += 3, e += 4) {
                encode3to4(source, d + off, 3, outBuff, e, options);
                lineLength += 4;
                if (breakLines && lineLength == MAX_LINE_LENGTH) {
                    outBuff[e + 4] = NEW_LINE;
                    e++;
                    lineLength = 0;
                }
            }
            if (d < len) {
                encode3to4(source, d + off, len - d, outBuff, e, options);
                e += 4;
            }
            try {
                return new String(outBuff, 0, e, PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(outBuff, 0, e);
            }
        }
    }
----------------------------------------
    public static String encodeBytes(byte[] source, int off, int len, int options) {
        int dontBreakLines = (options & DONT_BREAK_LINES);
        int gzip = (options & GZIP);
        if (gzip == GZIP) {
            java.io.ByteArrayOutputStream baos = null;
            java.util.zip.GZIPOutputStream gzos = null;
            Base64.OutputStream b64os = null;
            try {
                baos = new java.io.ByteArrayOutputStream();
                b64os = new Base64.OutputStream(baos, ENCODE | options);
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                gzos.write(source, off, len);
                gzos.close();
            } catch (java.io.IOException e) {
                e.printStackTrace();
                return null;
            } finally {
                try {
                    gzos.close();
                } catch (Exception e) {
                }
                try {
                    b64os.close();
                } catch (Exception e) {
                }
                try {
                    baos.close();
                } catch (Exception e) {
                }
            }
            try {
                return new String(baos.toByteArray(), PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(baos.toByteArray());
            }
        } else {
            boolean breakLines = dontBreakLines == 0;
            int len43 = len * 4 / 3;
            byte[] outBuff = new byte[(len43) + ((len % 3) > 0 ? 4 : 0) + (breakLines ? (len43 / MAX_LINE_LENGTH) : 0)];
            int d = 0;
            int e = 0;
            int len2 = len - 2;
            int lineLength = 0;
            for (; d < len2; d += 3, e += 4) {
                encode3to4(source, d + off, 3, outBuff, e, options);
                lineLength += 4;
                if (breakLines && lineLength == MAX_LINE_LENGTH) {
                    outBuff[e + 4] = NEW_LINE;
                    e++;
                    lineLength = 0;
                }
            }
            if (d < len) {
                encode3to4(source, d + off, len - d, outBuff, e, options);
                e += 4;
            }
            try {
                return new String(outBuff, 0, e, PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(outBuff, 0, e);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14017.java,14,76
default,21631.java,14,76
----------------------------------------
    public static void main(String argv[]) {
        example.setIvar(42);
        example.setSvar((short) -31000);
        example.setLvar(65537);
        example.setUivar(123456);
        example.setUsvar(61000);
        example.setUlvar(654321);
        example.setScvar((byte) -13);
        example.setUcvar((short) 251);
        example.setCvar('S');
        example.setFvar((float) 3.14159);
        example.setDvar(2.1828);
        example.setStrvar("Hello World");
        example.setIptrvar(example.new_int(37));
        example.setPtptr(example.new_Point(37, 42));
        example.setName("Bill");
        System.out.println("Variables (values printed from Java)");
        System.out.println("ivar      =" + example.getIvar());
        System.out.println("svar      =" + example.getSvar());
        System.out.println("lvar      =" + example.getLvar());
        System.out.println("uivar     =" + example.getUivar());
        System.out.println("usvar     =" + example.getUsvar());
        System.out.println("ulvar     =" + example.getUlvar());
        System.out.println("scvar     =" + example.getScvar());
        System.out.println("ucvar     =" + example.getUcvar());
        System.out.println("fvar      =" + example.getFvar());
        System.out.println("dvar      =" + example.getDvar());
        System.out.println("cvar      =" + (char) example.getCvar());
        System.out.println("strvar    =" + example.getStrvar());
        System.out.println("cstrvar   =" + example.getCstrvar());
        System.out.println("iptrvar   =" + Long.toHexString(SWIGTYPE_p_int.getCPtr(example.getIptrvar())));
        System.out.println("name      =" + example.getName());
        System.out.println("ptptr     =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPtptr())) + example.Point_print(example.getPtptr()));
        System.out.println("pt        =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPt())) + example.Point_print(example.getPt()));
        System.out.println("\nVariables (values printed from C)");
        example.print_vars();
        System.out.println("\nNow I'm going to try and modify some read only variables");
        System.out.println("     Trying to set 'path'");
        try {
            Method m = example.class.getDeclaredMethod("setPath", new Class[] { String.class });
            m.invoke(example.class, new Object[] { "Whoa!" });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("     Trying to set 'status'");
        try {
            Method m = example.class.getDeclaredMethod("setStatus", new Class[] { Integer.class });
            m.invoke(example.class, new Object[] { new Integer(0) });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("\nI'm going to try and update a structure variable.\n");
        example.setPt(example.getPtptr());
        System.out.println("The new value is");
        example.pt_print();
        System.out.println("You should see the value" + example.Point_print(example.getPtptr()));
    }
----------------------------------------
    public static void main(String argv[]) {
        example.setIvar(42);
        example.setSvar((short) -31000);
        example.setLvar(65537);
        example.setUivar(123456);
        example.setUsvar(61000);
        example.setUlvar(654321);
        example.setScvar((byte) -13);
        example.setUcvar((short) 251);
        example.setCvar('S');
        example.setFvar((float) 3.14159);
        example.setDvar(2.1828);
        example.setStrvar("Hello World");
        example.setIptrvar(example.new_int(37));
        example.setPtptr(example.new_Point(37, 42));
        example.setName("Bill");
        System.out.println("Variables (values printed from Java)");
        System.out.println("ivar      =" + example.getIvar());
        System.out.println("svar      =" + example.getSvar());
        System.out.println("lvar      =" + example.getLvar());
        System.out.println("uivar     =" + example.getUivar());
        System.out.println("usvar     =" + example.getUsvar());
        System.out.println("ulvar     =" + example.getUlvar());
        System.out.println("scvar     =" + example.getScvar());
        System.out.println("ucvar     =" + example.getUcvar());
        System.out.println("fvar      =" + example.getFvar());
        System.out.println("dvar      =" + example.getDvar());
        System.out.println("cvar      =" + (char) example.getCvar());
        System.out.println("strvar    =" + example.getStrvar());
        System.out.println("cstrvar   =" + example.getCstrvar());
        System.out.println("iptrvar   =" + Long.toHexString(SWIGTYPE_p_int.getCPtr(example.getIptrvar())));
        System.out.println("name      =" + example.getName());
        System.out.println("ptptr     =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPtptr())) + example.Point_print(example.getPtptr()));
        System.out.println("pt        =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPt())) + example.Point_print(example.getPt()));
        System.out.println("\nVariables (values printed from C)");
        example.print_vars();
        System.out.println("\nNow I'm going to try and modify some read only variables");
        System.out.println("     Trying to set 'path'");
        try {
            Method m = example.class.getDeclaredMethod("setPath", new Class[] { String.class });
            m.invoke(example.class, new Object[] { "Whoa!" });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("     Trying to set 'status'");
        try {
            Method m = example.class.getDeclaredMethod("setStatus", new Class[] { Integer.class });
            m.invoke(example.class, new Object[] { new Integer(0) });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("\nI'm going to try and update a structure variable.\n");
        example.setPt(example.getPtptr());
        System.out.println("The new value is");
        example.pt_print();
        System.out.println("You should see the value" + example.Point_print(example.getPtptr()));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1126894.java,168,229
selected,2112291.java,168,229
----------------------------------------
    protected void performSaveAs(IProgressMonitor progressMonitor) {
        Shell shell = getSite().getShell();
        IEditorInput input = getEditorInput();
        SaveAsDialog dialog = new SaveAsDialog(shell);
        IFile original = input instanceof IFileEditorInput ? ((IFileEditorInput) input).getFile() : null;
        if (original != null) {
            dialog.setOriginalFile(original);
        }
        dialog.create();
        IDocumentProvider provider = getDocumentProvider();
        if (provider == null) {
            return;
        }
        if (provider.isDeleted(input) && original != null) {
            String message = NLS.bind(Messages.TestDiagramEditor_SavingDeletedFile, original.getName());
            dialog.setErrorMessage(null);
            dialog.setMessage(message, IMessageProvider.WARNING);
        }
        if (dialog.open() == Window.CANCEL) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IPath filePath = dialog.getResult();
        if (filePath == null) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
        IFile file = workspaceRoot.getFile(filePath);
        final IEditorInput newInput = new FileEditorInput(file);
        IEditorMatchingStrategy matchingStrategy = getEditorDescriptor().getEditorMatchingStrategy();
        IEditorReference[] editorRefs = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getEditorReferences();
        for (int i = 0; i < editorRefs.length; i++) {
            if (matchingStrategy.matches(editorRefs[i], newInput)) {
                MessageDialog.openWarning(shell, Messages.TestDiagramEditor_SaveAsErrorTitle, Messages.TestDiagramEditor_SaveAsErrorMessage);
                return;
            }
        }
        boolean success = false;
        try {
            provider.aboutToChange(newInput);
            getDocumentProvider(newInput).saveDocument(progressMonitor, newInput, getDocumentProvider().getDocument(getEditorInput()), true);
            success = true;
        } catch (CoreException x) {
            IStatus status = x.getStatus();
            if (status == null || status.getSeverity() != IStatus.CANCEL) {
                ErrorDialog.openError(shell, Messages.TestDiagramEditor_SaveErrorTitle, Messages.TestDiagramEditor_SaveErrorMessage, x.getStatus());
            }
        } finally {
            provider.changed(newInput);
            if (success) {
                setInput(newInput);
            }
        }
        if (progressMonitor != null) {
            progressMonitor.setCanceled(!success);
        }
    }
----------------------------------------
    protected void performSaveAs(IProgressMonitor progressMonitor) {
        Shell shell = getSite().getShell();
        IEditorInput input = getEditorInput();
        SaveAsDialog dialog = new SaveAsDialog(shell);
        IFile original = input instanceof IFileEditorInput ? ((IFileEditorInput) input).getFile() : null;
        if (original != null) {
            dialog.setOriginalFile(original);
        }
        dialog.create();
        IDocumentProvider provider = getDocumentProvider();
        if (provider == null) {
            return;
        }
        if (provider.isDeleted(input) && original != null) {
            String message = NLS.bind(Messages.TransactioneditorDiagramEditor_SavingDeletedFile, original.getName());
            dialog.setErrorMessage(null);
            dialog.setMessage(message, IMessageProvider.WARNING);
        }
        if (dialog.open() == Window.CANCEL) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IPath filePath = dialog.getResult();
        if (filePath == null) {
            if (progressMonitor != null) {
                progressMonitor.setCanceled(true);
            }
            return;
        }
        IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
        IFile file = workspaceRoot.getFile(filePath);
        final IEditorInput newInput = new FileEditorInput(file);
        IEditorMatchingStrategy matchingStrategy = getEditorDescriptor().getEditorMatchingStrategy();
        IEditorReference[] editorRefs = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getEditorReferences();
        for (int i = 0; i < editorRefs.length; i++) {
            if (matchingStrategy.matches(editorRefs[i], newInput)) {
                MessageDialog.openWarning(shell, Messages.TransactioneditorDiagramEditor_SaveAsErrorTitle, Messages.TransactioneditorDiagramEditor_SaveAsErrorMessage);
                return;
            }
        }
        boolean success = false;
        try {
            provider.aboutToChange(newInput);
            getDocumentProvider(newInput).saveDocument(progressMonitor, newInput, getDocumentProvider().getDocument(getEditorInput()), true);
            success = true;
        } catch (CoreException x) {
            IStatus status = x.getStatus();
            if (status == null || status.getSeverity() != IStatus.CANCEL) {
                ErrorDialog.openError(shell, Messages.TransactioneditorDiagramEditor_SaveErrorTitle, Messages.TransactioneditorDiagramEditor_SaveErrorMessage, x.getStatus());
            }
        } finally {
            provider.changed(newInput);
            if (success) {
                setInput(newInput);
            }
        }
        if (progressMonitor != null) {
            progressMonitor.setCanceled(!success);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2339370.java,371,433
selected,1882693.java,446,508
----------------------------------------
    public static String encodeBytes(byte[] source, int off, int len, int options) {
        int dontBreakLines = (options & DONT_BREAK_LINES);
        int gzip = (options & GZIP);
        if (gzip == GZIP) {
            java.io.ByteArrayOutputStream baos = null;
            java.util.zip.GZIPOutputStream gzos = null;
            Base64.OutputStream b64os = null;
            try {
                baos = new java.io.ByteArrayOutputStream();
                b64os = new Base64.OutputStream(baos, ENCODE | options);
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                gzos.write(source, off, len);
                gzos.close();
            } catch (java.io.IOException e) {
                e.printStackTrace();
                return null;
            } finally {
                try {
                    gzos.close();
                } catch (Exception e) {
                }
                try {
                    b64os.close();
                } catch (Exception e) {
                }
                try {
                    baos.close();
                } catch (Exception e) {
                }
            }
            try {
                return new String(baos.toByteArray(), PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(baos.toByteArray());
            }
        } else {
            boolean breakLines = dontBreakLines == 0;
            int len43 = len * 4 / 3;
            byte[] outBuff = new byte[(len43) + ((len % 3) > 0 ? 4 : 0) + (breakLines ? (len43 / MAX_LINE_LENGTH) : 0)];
            int d = 0;
            int e = 0;
            int len2 = len - 2;
            int lineLength = 0;
            for (; d < len2; d += 3, e += 4) {
                encode3to4(source, d + off, 3, outBuff, e, options);
                lineLength += 4;
                if (breakLines && lineLength == MAX_LINE_LENGTH) {
                    outBuff[e + 4] = NEW_LINE;
                    e++;
                    lineLength = 0;
                }
            }
            if (d < len) {
                encode3to4(source, d + off, len - d, outBuff, e, options);
                e += 4;
            }
            try {
                return new String(outBuff, 0, e, PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(outBuff, 0, e);
            }
        }
    }
----------------------------------------
    public static String encodeBytes(byte[] source, int off, int len, int options) {
        int dontBreakLines = (options & DONT_BREAK_LINES);
        int gzip = (options & GZIP);
        if (gzip == GZIP) {
            java.io.ByteArrayOutputStream baos = null;
            java.util.zip.GZIPOutputStream gzos = null;
            Base64.OutputStream b64os = null;
            try {
                baos = new java.io.ByteArrayOutputStream();
                b64os = new Base64.OutputStream(baos, ENCODE | options);
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                gzos.write(source, off, len);
                gzos.close();
            } catch (java.io.IOException e) {
                e.printStackTrace();
                return null;
            } finally {
                try {
                    gzos.close();
                } catch (Exception e) {
                }
                try {
                    b64os.close();
                } catch (Exception e) {
                }
                try {
                    baos.close();
                } catch (Exception e) {
                }
            }
            try {
                return new String(baos.toByteArray(), PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(baos.toByteArray());
            }
        } else {
            boolean breakLines = dontBreakLines == 0;
            int len43 = len * 4 / 3;
            byte[] outBuff = new byte[(len43) + ((len % 3) > 0 ? 4 : 0) + (breakLines ? (len43 / MAX_LINE_LENGTH) : 0)];
            int d = 0;
            int e = 0;
            int len2 = len - 2;
            int lineLength = 0;
            for (; d < len2; d += 3, e += 4) {
                encode3to4(source, d + off, 3, outBuff, e, options);
                lineLength += 4;
                if (breakLines && lineLength == MAX_LINE_LENGTH) {
                    outBuff[e + 4] = NEW_LINE;
                    e++;
                    lineLength = 0;
                }
            }
            if (d < len) {
                encode3to4(source, d + off, len - d, outBuff, e, options);
                e += 4;
            }
            try {
                return new String(outBuff, 0, e, PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(outBuff, 0, e);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,21631.java,14,76
default,9202.java,14,76
----------------------------------------
    public static void main(String argv[]) {
        example.setIvar(42);
        example.setSvar((short) -31000);
        example.setLvar(65537);
        example.setUivar(123456);
        example.setUsvar(61000);
        example.setUlvar(654321);
        example.setScvar((byte) -13);
        example.setUcvar((short) 251);
        example.setCvar('S');
        example.setFvar((float) 3.14159);
        example.setDvar(2.1828);
        example.setStrvar("Hello World");
        example.setIptrvar(example.new_int(37));
        example.setPtptr(example.new_Point(37, 42));
        example.setName("Bill");
        System.out.println("Variables (values printed from Java)");
        System.out.println("ivar      =" + example.getIvar());
        System.out.println("svar      =" + example.getSvar());
        System.out.println("lvar      =" + example.getLvar());
        System.out.println("uivar     =" + example.getUivar());
        System.out.println("usvar     =" + example.getUsvar());
        System.out.println("ulvar     =" + example.getUlvar());
        System.out.println("scvar     =" + example.getScvar());
        System.out.println("ucvar     =" + example.getUcvar());
        System.out.println("fvar      =" + example.getFvar());
        System.out.println("dvar      =" + example.getDvar());
        System.out.println("cvar      =" + (char) example.getCvar());
        System.out.println("strvar    =" + example.getStrvar());
        System.out.println("cstrvar   =" + example.getCstrvar());
        System.out.println("iptrvar   =" + Long.toHexString(SWIGTYPE_p_int.getCPtr(example.getIptrvar())));
        System.out.println("name      =" + example.getName());
        System.out.println("ptptr     =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPtptr())) + example.Point_print(example.getPtptr()));
        System.out.println("pt        =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPt())) + example.Point_print(example.getPt()));
        System.out.println("\nVariables (values printed from C)");
        example.print_vars();
        System.out.println("\nNow I'm going to try and modify some read only variables");
        System.out.println("     Trying to set 'path'");
        try {
            Method m = example.class.getDeclaredMethod("setPath", new Class[] { String.class });
            m.invoke(example.class, new Object[] { "Whoa!" });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("     Trying to set 'status'");
        try {
            Method m = example.class.getDeclaredMethod("setStatus", new Class[] { Integer.class });
            m.invoke(example.class, new Object[] { new Integer(0) });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("\nI'm going to try and update a structure variable.\n");
        example.setPt(example.getPtptr());
        System.out.println("The new value is");
        example.pt_print();
        System.out.println("You should see the value" + example.Point_print(example.getPtptr()));
    }
----------------------------------------
    public static void main(String argv[]) {
        example.setIvar(42);
        example.setSvar((short) -31000);
        example.setLvar(65537);
        example.setUivar(123456);
        example.setUsvar(61000);
        example.setUlvar(654321);
        example.setScvar((byte) -13);
        example.setUcvar((short) 251);
        example.setCvar('S');
        example.setFvar((float) 3.14159);
        example.setDvar(2.1828);
        example.setStrvar("Hello World");
        example.setIptrvar(example.new_int(37));
        example.setPtptr(example.new_Point(37, 42));
        example.setName("Bill");
        System.out.println("Variables (values printed from Java)");
        System.out.println("ivar      =" + example.getIvar());
        System.out.println("svar      =" + example.getSvar());
        System.out.println("lvar      =" + example.getLvar());
        System.out.println("uivar     =" + example.getUivar());
        System.out.println("usvar     =" + example.getUsvar());
        System.out.println("ulvar     =" + example.getUlvar());
        System.out.println("scvar     =" + example.getScvar());
        System.out.println("ucvar     =" + example.getUcvar());
        System.out.println("fvar      =" + example.getFvar());
        System.out.println("dvar      =" + example.getDvar());
        System.out.println("cvar      =" + (char) example.getCvar());
        System.out.println("strvar    =" + example.getStrvar());
        System.out.println("cstrvar   =" + example.getCstrvar());
        System.out.println("iptrvar   =" + Long.toHexString(SWIGTYPE_p_int.getCPtr(example.getIptrvar())));
        System.out.println("name      =" + example.getName());
        System.out.println("ptptr     =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPtptr())) + example.Point_print(example.getPtptr()));
        System.out.println("pt        =" + Long.toHexString(SWIGTYPE_p_Point.getCPtr(example.getPt())) + example.Point_print(example.getPt()));
        System.out.println("\nVariables (values printed from C)");
        example.print_vars();
        System.out.println("\nNow I'm going to try and modify some read only variables");
        System.out.println("     Trying to set 'path'");
        try {
            Method m = example.class.getDeclaredMethod("setPath", new Class[] { String.class });
            m.invoke(example.class, new Object[] { "Whoa!" });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("     Trying to set 'status'");
        try {
            Method m = example.class.getDeclaredMethod("setStatus", new Class[] { Integer.class });
            m.invoke(example.class, new Object[] { new Integer(0) });
            System.out.println("Hey, what's going on?!?! This shouldn't work");
        } catch (NoSuchMethodException e) {
            System.out.println("Good.");
        } catch (Throwable t) {
            System.out.println("You shouldn't see this!");
        }
        System.out.println("\nI'm going to try and update a structure variable.\n");
        example.setPt(example.getPtptr());
        System.out.println("The new value is");
        example.pt_print();
        System.out.println("You should see the value" + example.Point_print(example.getPtptr()));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,64999.java,61,122
default,74770.java,61,122
----------------------------------------
    public static void main(String[] args) {
        final String dbdriver = "org.postgresql.Driver";
        final String dbconnect = "jdbc:postgresql://localhost:5432/wdb";
        final String dbuser = "wcitest";
        final String dbpasswd = "";
        Connection con = null;
        Statement statement = null;
        try {
            Class.forName(dbdriver);
            con = DriverManager.getConnection(dbconnect, dbuser, dbpasswd);
            statement = con.createStatement();
        } catch (Exception e) {
            System.out.println("FATAL: cant load the database driver <" + dbdriver + ">!");
            System.exit(1);
        }
        String wdbInit = "SELECT wci.begin('" + dbuser + "')";
        String sql = " SELECT * " + " FROM wci.read( array['test wci 5'], NULL, " + "                '2009-11-13 00:00:00+00', " + "                NULL, " + "                array['air temperature', " + "                      'air pressure'], " + "                NULL, " + "                array[-1], " + "                NULL::wci.returngid )";
        final String colNames[] = { "valueParameterName", "validTimeFrom" };
        ResultSet rs = null;
        try {
            statement.execute(wdbInit);
            rs = statement.executeQuery(sql);
            ResultSetMetaData rsMetaData = rs.getMetaData();
            String data;
            boolean first;
            while (rs.next()) {
                Statement getGridStatement = con.createStatement();
                first = true;
                long gridId = rs.getLong("value");
                ResultSet blobResult = getGridStatement.executeQuery("SELECT * FROM wci.fetch(" + gridId + ", NULL::wci.grid)");
                while (blobResult.next()) {
                    int size = blobResult.getInt("numberX") + blobResult.getInt("numberX");
                    InputStream blob = blobResult.getBinaryStream("grid");
                    DataInputStream blobReader = new DataInputStream(blob);
                    int floatToRead = 42;
                    blobReader.skip(floatToRead * 4);
                    float value = blobReader.readFloat();
                    System.out.print(value + "\t");
                    for (String name : colNames) {
                        data = rs.getString(name);
                        if (first) {
                            first = false;
                        } else {
                            System.out.print(", ");
                        }
                        if (data != null) System.out.print(data); else System.out.print("\\N");
                    }
                    System.out.print("  (BLOB size: " + size + ")");
                    System.out.println();
                }
                blobResult.close();
            }
        } catch (Exception ex) {
            System.out.println("SELECT error: " + ex);
        } finally {
            try {
                if (rs != null) rs.close();
            } catch (SQLException ex) {
                System.out.println("EXCEPTION: rs.close: " + ex);
            }
        }
    }
----------------------------------------
    public static void main(String[] args) {
        final String dbdriver = "org.postgresql.Driver";
        final String dbconnect = "jdbc:postgresql://localhost:5432/wdb";
        final String dbuser = "wcitest";
        final String dbpasswd = "";
        Connection con = null;
        Statement statement = null;
        try {
            Class.forName(dbdriver);
            con = DriverManager.getConnection(dbconnect, dbuser, dbpasswd);
            statement = con.createStatement();
        } catch (Exception e) {
            System.out.println("FATAL: cant load the database driver <" + dbdriver + ">!");
            System.exit(1);
        }
        String wdbInit = "SELECT wci.begin('" + dbuser + "')";
        String sql = " SELECT * " + " FROM wci.read( array['test wci 5'], NULL, " + "                '2009-11-13 00:00:00+00', " + "                NULL, " + "                array['air temperature', " + "                      'air pressure'], " + "                NULL, " + "                array[-1], " + "                NULL::wci.returngid )";
        final String colNames[] = { "valueParameterName", "validTimeFrom" };
        ResultSet rs = null;
        try {
            statement.execute(wdbInit);
            rs = statement.executeQuery(sql);
            ResultSetMetaData rsMetaData = rs.getMetaData();
            String data;
            boolean first;
            while (rs.next()) {
                Statement getGridStatement = con.createStatement();
                first = true;
                long gridId = rs.getLong("value");
                ResultSet blobResult = getGridStatement.executeQuery("SELECT * FROM wci.fetch(" + gridId + ", NULL::wci.grid)");
                while (blobResult.next()) {
                    int size = blobResult.getInt("numberX") + blobResult.getInt("numberX");
                    InputStream blob = blobResult.getBinaryStream("grid");
                    DataInputStream blobReader = new DataInputStream(blob);
                    int floatToRead = 42;
                    blobReader.skip(floatToRead * 4);
                    float value = blobReader.readFloat();
                    System.out.print(value + "\t");
                    for (String name : colNames) {
                        data = rs.getString(name);
                        if (first) {
                            first = false;
                        } else {
                            System.out.print(", ");
                        }
                        if (data != null) System.out.print(data); else System.out.print("\\N");
                    }
                    System.out.print("  (BLOB size: " + size + ")");
                    System.out.println();
                }
                blobResult.close();
            }
        } catch (Exception ex) {
            System.out.println("SELECT error: " + ex);
        } finally {
            try {
                if (rs != null) rs.close();
            } catch (SQLException ex) {
                System.out.println("EXCEPTION: rs.close: " + ex);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33328.java,63,112
default,64999.java,61,122
----------------------------------------
    public static void main(String[] args) {
        final String dbdriver = "org.postgresql.Driver";
        final String dbconnect = "jdbc:postgresql://localhost:5432/wdb";
        final String dbuser = "wcitest";
        final String dbpasswd = "";
        Connection con = null;
        Statement statement = null;
        try {
            Class.forName(dbdriver);
            con = DriverManager.getConnection(dbconnect, dbuser, dbpasswd);
            statement = con.createStatement();
        } catch (Exception e) {
            System.out.println("FATAL: cant load the database driver <" + dbdriver + ">!");
            System.exit(1);
        }
        String wdbInit = "SELECT wci.begin('" + dbuser + "')";
        String sql = " SELECT * " + " FROM wci.read( array['test wci 5'], 'POINT( 10.0 59.0 )', " + "                '2009-11-13 00:00:00+00', " + "                NULL, " + "                array['air temperature', " + "                      'air pressure'], " + "                NULL, " + "                array[-1], " + "                NULL::wci.returnFloat )";
        final String colNames[] = { "value", "valueParameterName", "validTimeFrom" };
        ResultSet rs = null;
        try {
            statement.execute(wdbInit);
            rs = statement.executeQuery(sql);
            ResultSetMetaData rsMetaData = rs.getMetaData();
            String data;
            boolean first;
            while (rs.next()) {
                first = true;
                for (String name : colNames) {
                    data = rs.getString(name);
                    if (first) {
                        first = false;
                    } else {
                        System.out.print(", ");
                    }
                    if (data != null) System.out.print(data); else System.out.print("\\N");
                }
                System.out.println();
            }
        } catch (Exception ex) {
            System.out.println("SELECT error: " + ex);
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException ex) {
                    System.out.println("EXCEPTION: rs.close: " + ex);
                }
            }
        }
    }
----------------------------------------
    public static void main(String[] args) {
        final String dbdriver = "org.postgresql.Driver";
        final String dbconnect = "jdbc:postgresql://localhost:5432/wdb";
        final String dbuser = "wcitest";
        final String dbpasswd = "";
        Connection con = null;
        Statement statement = null;
        try {
            Class.forName(dbdriver);
            con = DriverManager.getConnection(dbconnect, dbuser, dbpasswd);
            statement = con.createStatement();
        } catch (Exception e) {
            System.out.println("FATAL: cant load the database driver <" + dbdriver + ">!");
            System.exit(1);
        }
        String wdbInit = "SELECT wci.begin('" + dbuser + "')";
        String sql = " SELECT * " + " FROM wci.read( array['test wci 5'], NULL, " + "                '2009-11-13 00:00:00+00', " + "                NULL, " + "                array['air temperature', " + "                      'air pressure'], " + "                NULL, " + "                array[-1], " + "                NULL::wci.returngid )";
        final String colNames[] = { "valueParameterName", "validTimeFrom" };
        ResultSet rs = null;
        try {
            statement.execute(wdbInit);
            rs = statement.executeQuery(sql);
            ResultSetMetaData rsMetaData = rs.getMetaData();
            String data;
            boolean first;
            while (rs.next()) {
                Statement getGridStatement = con.createStatement();
                first = true;
                long gridId = rs.getLong("value");
                ResultSet blobResult = getGridStatement.executeQuery("SELECT * FROM wci.fetch(" + gridId + ", NULL::wci.grid)");
                while (blobResult.next()) {
                    int size = blobResult.getInt("numberX") + blobResult.getInt("numberX");
                    InputStream blob = blobResult.getBinaryStream("grid");
                    DataInputStream blobReader = new DataInputStream(blob);
                    int floatToRead = 42;
                    blobReader.skip(floatToRead * 4);
                    float value = blobReader.readFloat();
                    System.out.print(value + "\t");
                    for (String name : colNames) {
                        data = rs.getString(name);
                        if (first) {
                            first = false;
                        } else {
                            System.out.print(", ");
                        }
                        if (data != null) System.out.print(data); else System.out.print("\\N");
                    }
                    System.out.print("  (BLOB size: " + size + ")");
                    System.out.println();
                }
                blobResult.close();
            }
        } catch (Exception ex) {
            System.out.println("SELECT error: " + ex);
        } finally {
            try {
                if (rs != null) rs.close();
            } catch (SQLException ex) {
                System.out.println("EXCEPTION: rs.close: " + ex);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,438322.java,493,545
selected,304936.java,447,509
----------------------------------------
    public static String encodeBytes(byte[] source, int off, int len, int options) {
        int dontBreakLines = (options & DONT_BREAK_LINES);
        int gzip = (options & GZIP);
        if (gzip == GZIP) {
            java.io.ByteArrayOutputStream baos = null;
            java.util.zip.GZIPOutputStream gzos = null;
            Base64.OutputStream b64os = null;
            try {
                baos = new java.io.ByteArrayOutputStream();
                b64os = new Base64.OutputStream(baos, ENCODE | options);
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                gzos.write(source, off, len);
                gzos.close();
            } catch (java.io.IOException e) {
                e.printStackTrace();
                return null;
            } finally {
                closeQuietly(gzos);
                closeQuietly(b64os);
                closeQuietly(baos);
            }
            try {
                return new String(baos.toByteArray(), PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(baos.toByteArray());
            }
        }
        boolean breakLines = dontBreakLines == 0;
        int len43 = len * 4 / 3;
        byte[] outBuff = new byte[(len43) + ((len % 3) > 0 ? 4 : 0) + (breakLines ? (len43 / MAX_LINE_LENGTH) : 0)];
        int d = 0;
        int e = 0;
        int len2 = len - 2;
        int lineLength = 0;
        for (; d < len2; d += 3, e += 4) {
            encode3to4(source, d + off, 3, outBuff, e, options);
            lineLength += 4;
            if (breakLines && lineLength == MAX_LINE_LENGTH) {
                outBuff[e + 4] = NEW_LINE;
                e++;
                lineLength = 0;
            }
        }
        if (d < len) {
            encode3to4(source, d + off, len - d, outBuff, e, options);
            e += 4;
        }
        try {
            return new String(outBuff, 0, e, PREFERRED_ENCODING);
        } catch (java.io.UnsupportedEncodingException uue) {
            return new String(outBuff, 0, e);
        }
    }
----------------------------------------
    public static String encodeBytes(byte[] source, int off, int len, int options) {
        int dontBreakLines = (options & DONT_BREAK_LINES);
        int gzip = (options & GZIP);
        if (gzip == GZIP) {
            java.io.ByteArrayOutputStream baos = null;
            java.util.zip.GZIPOutputStream gzos = null;
            Base64.OutputStream b64os = null;
            try {
                baos = new java.io.ByteArrayOutputStream();
                b64os = new Base64.OutputStream(baos, ENCODE | options);
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                gzos.write(source, off, len);
                gzos.close();
            } catch (java.io.IOException e) {
                e.printStackTrace();
                return null;
            } finally {
                try {
                    gzos.close();
                } catch (Exception e) {
                }
                try {
                    b64os.close();
                } catch (Exception e) {
                }
                try {
                    baos.close();
                } catch (Exception e) {
                }
            }
            try {
                return new String(baos.toByteArray(), PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(baos.toByteArray());
            }
        } else {
            boolean breakLines = dontBreakLines == 0;
            int len43 = len * 4 / 3;
            byte[] outBuff = new byte[(len43) + ((len % 3) > 0 ? 4 : 0) + (breakLines ? (len43 / MAX_LINE_LENGTH) : 0)];
            int d = 0;
            int e = 0;
            int len2 = len - 2;
            int lineLength = 0;
            for (; d < len2; d += 3, e += 4) {
                encode3to4(source, d + off, 3, outBuff, e, options);
                lineLength += 4;
                if (breakLines && lineLength == MAX_LINE_LENGTH) {
                    outBuff[e + 4] = NEW_LINE;
                    e++;
                    lineLength = 0;
                }
            }
            if (d < len) {
                encode3to4(source, d + off, len - d, outBuff, e, options);
                e += 4;
            }
            try {
                return new String(outBuff, 0, e, PREFERRED_ENCODING);
            } catch (java.io.UnsupportedEncodingException uue) {
                return new String(outBuff, 0, e);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,847160.java,19,79
selected,2482618.java,19,69
----------------------------------------
    public org.omg.CORBA.portable.OutputStream _invoke(String opName, org.omg.CORBA.portable.InputStream in, org.omg.CORBA.portable.ResponseHandler handler) {
        final String[] _ob_names = { "_get_MyAdmin", "_get_MyType", "_get_lifetime_filter", "_get_priority_filter", "_set_lifetime_filter", "_set_priority_filter", "add_filter", "connect_typed_pull_consumer", "disconnect_pull_supplier", "get_all_filters", "get_filter", "get_qos", "get_typed_supplier", "obtain_offered_types", "pull", "remove_all_filters", "remove_filter", "set_qos", "subscription_change", "try_pull", "validate_event_qos", "validate_qos" };
        int _ob_left = 0;
        int _ob_right = _ob_names.length;
        int _ob_index = -1;
        while (_ob_left < _ob_right) {
            int _ob_m = (_ob_left + _ob_right) / 2;
            int _ob_res = _ob_names[_ob_m].compareTo(opName);
            if (_ob_res == 0) {
                _ob_index = _ob_m;
                break;
            } else if (_ob_res > 0) _ob_right = _ob_m; else _ob_left = _ob_m + 1;
        }
        switch(_ob_index) {
            case 0:
                return _OB_att_get_MyAdmin(in, handler);
            case 1:
                return _OB_att_get_MyType(in, handler);
            case 2:
                return _OB_att_get_lifetime_filter(in, handler);
            case 3:
                return _OB_att_get_priority_filter(in, handler);
            case 4:
                return _OB_att_set_lifetime_filter(in, handler);
            case 5:
                return _OB_att_set_priority_filter(in, handler);
            case 6:
                return _OB_op_add_filter(in, handler);
            case 7:
                return _OB_op_connect_typed_pull_consumer(in, handler);
            case 8:
                return _OB_op_disconnect_pull_supplier(in, handler);
            case 9:
                return _OB_op_get_all_filters(in, handler);
            case 10:
                return _OB_op_get_filter(in, handler);
            case 11:
                return _OB_op_get_qos(in, handler);
            case 12:
                return _OB_op_get_typed_supplier(in, handler);
            case 13:
                return _OB_op_obtain_offered_types(in, handler);
            case 14:
                return _OB_op_pull(in, handler);
            case 15:
                return _OB_op_remove_all_filters(in, handler);
            case 16:
                return _OB_op_remove_filter(in, handler);
            case 17:
                return _OB_op_set_qos(in, handler);
            case 18:
                return _OB_op_subscription_change(in, handler);
            case 19:
                return _OB_op_try_pull(in, handler);
            case 20:
                return _OB_op_validate_event_qos(in, handler);
            case 21:
                return _OB_op_validate_qos(in, handler);
        }
        throw new org.omg.CORBA.BAD_OPERATION();
    }
----------------------------------------
    public org.omg.CORBA.portable.OutputStream _invoke(String opName, org.omg.CORBA.portable.InputStream in, org.omg.CORBA.portable.ResponseHandler handler) {
        final String[] _ob_names = { "_get_MyAdmin", "_get_MyType", "add_filter", "connect_structured_pull_supplier", "disconnect_structured_pull_consumer", "get_all_filters", "get_filter", "get_qos", "obtain_subscription_types", "offer_change", "remove_all_filters", "remove_filter", "resume_connection", "set_qos", "suspend_connection", "validate_event_qos", "validate_qos" };
        int _ob_left = 0;
        int _ob_right = _ob_names.length;
        int _ob_index = -1;
        while (_ob_left < _ob_right) {
            int _ob_m = (_ob_left + _ob_right) / 2;
            int _ob_res = _ob_names[_ob_m].compareTo(opName);
            if (_ob_res == 0) {
                _ob_index = _ob_m;
                break;
            } else if (_ob_res > 0) _ob_right = _ob_m; else _ob_left = _ob_m + 1;
        }
        switch(_ob_index) {
            case 0:
                return _OB_att_get_MyAdmin(in, handler);
            case 1:
                return _OB_att_get_MyType(in, handler);
            case 2:
                return _OB_op_add_filter(in, handler);
            case 3:
                return _OB_op_connect_structured_pull_supplier(in, handler);
            case 4:
                return _OB_op_disconnect_structured_pull_consumer(in, handler);
            case 5:
                return _OB_op_get_all_filters(in, handler);
            case 6:
                return _OB_op_get_filter(in, handler);
            case 7:
                return _OB_op_get_qos(in, handler);
            case 8:
                return _OB_op_obtain_subscription_types(in, handler);
            case 9:
                return _OB_op_offer_change(in, handler);
            case 10:
                return _OB_op_remove_all_filters(in, handler);
            case 11:
                return _OB_op_remove_filter(in, handler);
            case 12:
                return _OB_op_resume_connection(in, handler);
            case 13:
                return _OB_op_set_qos(in, handler);
            case 14:
                return _OB_op_suspend_connection(in, handler);
            case 15:
                return _OB_op_validate_event_qos(in, handler);
            case 16:
                return _OB_op_validate_qos(in, handler);
        }
        throw new org.omg.CORBA.BAD_OPERATION();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,11981.java,750,808
default,94873.java,885,943
----------------------------------------
    private byte[] showAvailableThemes(HTTPurl urlData, HashMap<String, String> headers) throws Exception {
        StringBuffer out = new StringBuffer();
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "ShowThemes.html");
        String httpDir = store.getProperty("path.httproot");
        String themeDir = store.getProperty("path.theme");
        File themeDirs = new File(httpDir + File.separator + "themes");
        int count = 0;
        if (themeDirs.exists()) {
            File[] dirs = themeDirs.listFiles();
            for (int x = 0; x < dirs.length; x++) {
                if (dirs[x].isDirectory() && dirs[x].isHidden() == false) {
                    count++;
                    out.append("<option value=\"" + dirs[x].getName() + "\"");
                    if (dirs[x].getName().equalsIgnoreCase(themeDir)) out.append(" SELECTED ");
                    out.append(">" + dirs[x].getName() + "</option>\n");
                }
            }
        }
        if (count == 0) {
            out.append("<option value=\"none\">none available</option>\n");
        }
        template.replaceAll("$themeList", out.toString());
        String currentEPGTheme = store.getProperty("path.theme.epg");
        out = new StringBuffer();
        String xslDir = store.getProperty("path.xsl");
        count = 0;
        File xslDirs = new File(xslDir);
        if (xslDirs.exists()) {
            File[] xslFiles = xslDirs.listFiles();
            for (int x = 0; x < xslFiles.length; x++) {
                if (xslFiles[x].isDirectory() == false) {
                    if (xslFiles[x].getName().matches("epg-.*.xsl")) {
                        count++;
                        out.append("<option value=\"" + xslFiles[x].getName() + "\"");
                        if (xslFiles[x].getName().equalsIgnoreCase(currentEPGTheme)) out.append(" SELECTED ");
                        String name = xslFiles[x].getName().substring(4, xslFiles[x].getName().length() - 4);
                        out.append(">" + name + "</option>\n");
                    }
                }
            }
        }
        if (count == 0) {
            out.append("<option value=\"none\">none available</option>\n");
        }
        template.replaceAll("$epg_themeList", out.toString());
        out = new StringBuffer();
        String[] agentList = store.getAgentMappingList();
        for (int x = 0; x < agentList.length; x++) {
            String themeForAgent = store.getThemeForAgent(agentList[x]);
            out.append("<tr>");
            out.append("<td>" + agentList[x] + "</td>");
            out.append("<td>" + themeForAgent + "</td>");
            out.append("<td><a href='/servlet/SystemDataRes?action=37&agent=" + URLEncoder.encode(agentList[x], "UTF-8") + "'><img src='/images/delete.png' alt='Delete Mapping' align='absmiddle' border='0' height='24' width='24'></a></td>");
            out.append("</tr>\n");
        }
        template.replaceAll("$themeMappings", out.toString());
        template.replaceAll("$agentString", headers.get("User-Agent"));
        return template.getPageBytes();
    }
----------------------------------------
    private byte[] showAvailableThemes(HTTPurl urlData, HashMap<String, String> headers) throws Exception {
        StringBuffer out = new StringBuffer();
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "ShowThemes.html");
        String httpDir = store.getProperty("path.httproot");
        String themeDir = store.getProperty("path.theme");
        File themeDirs = new File(httpDir + File.separator + "themes");
        int count = 0;
        if (themeDirs.exists()) {
            File[] dirs = themeDirs.listFiles();
            for (int x = 0; x < dirs.length; x++) {
                if (dirs[x].isDirectory() && dirs[x].isHidden() == false) {
                    count++;
                    out.append("<option value=\"" + dirs[x].getName() + "\"");
                    if (dirs[x].getName().equalsIgnoreCase(themeDir)) out.append(" SELECTED ");
                    out.append(">" + dirs[x].getName() + "</option>\n");
                }
            }
        }
        if (count == 0) {
            out.append("<option value=\"none\">none available</option>\n");
        }
        template.replaceAll("$themeList", out.toString());
        String currentEPGTheme = store.getProperty("path.theme.epg");
        out = new StringBuffer();
        String xslDir = store.getProperty("path.xsl");
        count = 0;
        File xslDirs = new File(xslDir);
        if (xslDirs.exists()) {
            File[] xslFiles = xslDirs.listFiles();
            for (int x = 0; x < xslFiles.length; x++) {
                if (xslFiles[x].isDirectory() == false) {
                    if (xslFiles[x].getName().matches("epg-.*.xsl")) {
                        count++;
                        out.append("<option value=\"" + xslFiles[x].getName() + "\"");
                        if (xslFiles[x].getName().equalsIgnoreCase(currentEPGTheme)) out.append(" SELECTED ");
                        String name = xslFiles[x].getName().substring(4, xslFiles[x].getName().length() - 4);
                        out.append(">" + name + "</option>\n");
                    }
                }
            }
        }
        if (count == 0) {
            out.append("<option value=\"none\">none available</option>\n");
        }
        template.replaceAll("$epg_themeList", out.toString());
        out = new StringBuffer();
        String[] agentList = store.getAgentMappingList();
        for (int x = 0; x < agentList.length; x++) {
            String themeForAgent = store.getThemeForAgent(agentList[x]);
            out.append("<tr>");
            out.append("<td>" + agentList[x] + "</td>");
            out.append("<td>" + themeForAgent + "</td>");
            out.append("<td><a href='/servlet/SystemDataRes?action=37&agent=" + URLEncoder.encode(agentList[x], "UTF-8") + "'><img src='/images/delete.png' alt='Delete Mapping' align='absmiddle' border='0' height='24' width='24'></a></td>");
            out.append("</tr>\n");
        }
        template.replaceAll("$themeMappings", out.toString());
        template.replaceAll("$agentString", headers.get("User-Agent"));
        return template.getPageBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53817.java,1089,1146
default,122111.java,1089,1146
----------------------------------------
    private byte[] showChannelMapping(HTTPurl urlData) throws Exception {
        GuideStore guide = GuideStore.getInstance();
        StringBuffer buff = new StringBuffer();
        StringBuffer warnings = new StringBuffer();
        Vector chanMap = guide.getChannelMap();
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "epg-mapping.html");
        Set<String> wsChanSet = store.getChannels().keySet();
        String[] wsChannels = (String[]) wsChanSet.toArray(new String[0]);
        for (int x = 0; x < chanMap.size(); x++) {
            int problem = 0;
            String[] map = (String[]) chanMap.get(x);
            GuideItem[] items = guide.getProgramsForChannel(map[1]);
            if (!wsChanSet.contains(map[0])) {
                warnings.append("TV Scheduler Pro Channel (" + map[0] + ") does not exist!<br>\n");
                problem = 1;
            }
            if (items.length == 0) {
                warnings.append("There is currently no data for EPG channel (" + map[1] + ")<br>\n");
                problem += 2;
            }
            buff.append("<tr>");
            buff.append("<td>");
            if (problem == 1 || problem == 3) {
                buff.append("<img align='absmiddle' src='/images/exclaim24.png' border='0' alt='Error' width='22' height='24'>");
            }
            buff.append(map[0] + "</td><td>");
            if (problem == 2 || problem == 3) {
                buff.append("<img align='absmiddle' src='/images/exclaim24.png' border='0' alt='Error' width='22' height='24'>");
            }
            buff.append(map[1] + "</td>\n");
            buff.append("<td>");
            buff.append("<a href='/servlet/EpgDataRes?action=07&id=" + x + "'><img align='absmiddle' border='0' alt='Delete' src='/images/delete.png' width='24' height='24'></a>\n");
            buff.append("<a href='/servlet/EpgDataRes?action=24&id=" + x + "&dir=0'><img align='absmiddle' border='0' alt='Up' src='/images/up01.png' width='7' height='7'></a>\n");
            buff.append("<a href='/servlet/EpgDataRes?action=24&id=" + x + "&dir=1'><img align='absmiddle' border='0' alt='Down' src='/images/down01.png' width='7' height='7'></a>\n");
            buff.append("</td>\n");
            buff.append("</tr>\n");
        }
        template.replaceAll("$channelmap", buff.toString());
        Arrays.sort(wsChannels, String.CASE_INSENSITIVE_ORDER);
        buff = new StringBuffer();
        for (int x = 0; x < wsChannels.length; x++) {
            buff.append("<OPTION VALUE=\"" + wsChannels[x] + "\"> " + wsChannels[x] + "\n");
        }
        template.replaceAll("$wsChannels", buff.toString());
        String[] epgChannels = (String[]) guide.getChannelList();
        Arrays.sort(epgChannels, String.CASE_INSENSITIVE_ORDER);
        buff = new StringBuffer();
        for (int x = 0; x < epgChannels.length; x++) {
            buff.append("<OPTION VALUE=\"" + epgChannels[x] + "\"> " + epgChannels[x] + "\n");
        }
        template.replaceAll("$epgChannels", buff.toString());
        if (warnings.length() > 0) {
            String warningText = "<table><tr><td style='border: 1px solid #FFFFFF;'>" + "<img align='absmiddle' src='/images/exclaim24.png' border='0' alt='Error' width='22' height='24'><b>Warnings</b>" + "</td></tr><tr><td>";
            warningText += warnings.toString() + "</td></tr></table>";
            template.replaceAll("$warning", warningText);
        } else template.replaceAll("$warning", "");
        return template.getPageBytes();
    }
----------------------------------------
    private byte[] showChannelMapping(HTTPurl urlData) throws Exception {
        GuideStore guide = GuideStore.getInstance();
        StringBuffer buff = new StringBuffer();
        StringBuffer warnings = new StringBuffer();
        Vector chanMap = guide.getChannelMap();
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "epg-mapping.html");
        Set<String> wsChanSet = store.getChannels().keySet();
        String[] wsChannels = (String[]) wsChanSet.toArray(new String[0]);
        for (int x = 0; x < chanMap.size(); x++) {
            int problem = 0;
            String[] map = (String[]) chanMap.get(x);
            GuideItem[] items = guide.getProgramsForChannel(map[1]);
            if (!wsChanSet.contains(map[0])) {
                warnings.append("TV Scheduler Pro Channel (" + map[0] + ") does not exist!<br>\n");
                problem = 1;
            }
            if (items.length == 0) {
                warnings.append("There is currently no data for EPG channel (" + map[1] + ")<br>\n");
                problem += 2;
            }
            buff.append("<tr>");
            buff.append("<td>");
            if (problem == 1 || problem == 3) {
                buff.append("<img align='absmiddle' src='/images/exclaim24.png' border='0' alt='Error' width='22' height='24'>");
            }
            buff.append(map[0] + "</td><td>");
            if (problem == 2 || problem == 3) {
                buff.append("<img align='absmiddle' src='/images/exclaim24.png' border='0' alt='Error' width='22' height='24'>");
            }
            buff.append(map[1] + "</td>\n");
            buff.append("<td>");
            buff.append("<a href='/servlet/EpgDataRes?action=07&id=" + x + "'><img align='absmiddle' border='0' alt='Delete' src='/images/delete.png' width='24' height='24'></a>\n");
            buff.append("<a href='/servlet/EpgDataRes?action=24&id=" + x + "&dir=0'><img align='absmiddle' border='0' alt='Up' src='/images/up01.png' width='7' height='7'></a>\n");
            buff.append("<a href='/servlet/EpgDataRes?action=24&id=" + x + "&dir=1'><img align='absmiddle' border='0' alt='Down' src='/images/down01.png' width='7' height='7'></a>\n");
            buff.append("</td>\n");
            buff.append("</tr>\n");
        }
        template.replaceAll("$channelmap", buff.toString());
        Arrays.sort(wsChannels, String.CASE_INSENSITIVE_ORDER);
        buff = new StringBuffer();
        for (int x = 0; x < wsChannels.length; x++) {
            buff.append("<OPTION VALUE=\"" + wsChannels[x] + "\"> " + wsChannels[x] + "\n");
        }
        template.replaceAll("$wsChannels", buff.toString());
        String[] epgChannels = (String[]) guide.getChannelList();
        Arrays.sort(epgChannels, String.CASE_INSENSITIVE_ORDER);
        buff = new StringBuffer();
        for (int x = 0; x < epgChannels.length; x++) {
            buff.append("<OPTION VALUE=\"" + epgChannels[x] + "\"> " + epgChannels[x] + "\n");
        }
        template.replaceAll("$epgChannels", buff.toString());
        if (warnings.length() > 0) {
            String warningText = "<table><tr><td style='border: 1px solid #FFFFFF;'>" + "<img align='absmiddle' src='/images/exclaim24.png' border='0' alt='Error' width='22' height='24'><b>Warnings</b>" + "</td></tr><tr><td>";
            warningText += warnings.toString() + "</td></tr></table>";
            template.replaceAll("$warning", warningText);
        } else template.replaceAll("$warning", "");
        return template.getPageBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1802351.java,983,1041
selected,2215261.java,983,1041
----------------------------------------
        public int read() throws java.io.IOException {
            if (position < 0) {
                if (encode) {
                    byte[] b3 = new byte[3];
                    int numBinaryBytes = 0;
                    for (int i = 0; i < 3; i++) {
                        try {
                            int b = in.read();
                            if (b >= 0) {
                                b3[i] = (byte) b;
                                numBinaryBytes++;
                            }
                        } catch (java.io.IOException e) {
                            if (i == 0) throw e;
                        }
                    }
                    if (numBinaryBytes > 0) {
                        encode3to4(b3, 0, numBinaryBytes, buffer, 0, options);
                        position = 0;
                        numSigBytes = 4;
                    } else {
                        return -1;
                    }
                } else {
                    byte[] b4 = new byte[4];
                    int i = 0;
                    for (i = 0; i < 4; i++) {
                        int b = 0;
                        do {
                            b = in.read();
                        } while (b >= 0 && decodabet[b & 0x7f] <= WHITE_SPACE_ENC);
                        if (b < 0) break;
                        b4[i] = (byte) b;
                    }
                    if (i == 4) {
                        numSigBytes = decode4to3(b4, 0, buffer, 0, options);
                        position = 0;
                    } else if (i == 0) {
                        return -1;
                    } else {
                        throw new java.io.IOException("Improperly padded Base64 input.");
                    }
                }
            }
            if (position >= 0) {
                if (position >= numSigBytes) return -1;
                if (encode && breakLines && lineLength >= MAX_LINE_LENGTH) {
                    lineLength = 0;
                    return '\n';
                } else {
                    lineLength++;
                    int b = buffer[position++];
                    if (position >= bufferLength) position = -1;
                    return b & 0xFF;
                }
            } else {
                throw new java.io.IOException("Error in Base64 code reading stream.");
            }
        }
----------------------------------------
        public int read() throws java.io.IOException {
            if (position < 0) {
                if (encode) {
                    byte[] b3 = new byte[3];
                    int numBinaryBytes = 0;
                    for (int i = 0; i < 3; i++) {
                        try {
                            int b = in.read();
                            if (b >= 0) {
                                b3[i] = (byte) b;
                                numBinaryBytes++;
                            }
                        } catch (java.io.IOException e) {
                            if (i == 0) throw e;
                        }
                    }
                    if (numBinaryBytes > 0) {
                        encode3to4(b3, 0, numBinaryBytes, buffer, 0, options);
                        position = 0;
                        numSigBytes = 4;
                    } else {
                        return -1;
                    }
                } else {
                    byte[] b4 = new byte[4];
                    int i = 0;
                    for (i = 0; i < 4; i++) {
                        int b = 0;
                        do {
                            b = in.read();
                        } while (b >= 0 && decodabet[b & 0x7f] <= WHITE_SPACE_ENC);
                        if (b < 0) break;
                        b4[i] = (byte) b;
                    }
                    if (i == 4) {
                        numSigBytes = decode4to3(b4, 0, buffer, 0, options);
                        position = 0;
                    } else if (i == 0) {
                        return -1;
                    } else {
                        throw new java.io.IOException("Improperly padded Base64 input.");
                    }
                }
            }
            if (position >= 0) {
                if (position >= numSigBytes) return -1;
                if (encode && breakLines && lineLength >= MAX_LINE_LENGTH) {
                    lineLength = 0;
                    return '\n';
                } else {
                    lineLength++;
                    int b = buffer[position++];
                    if (position >= bufferLength) position = -1;
                    return b & 0xFF;
                }
            } else {
                throw new java.io.IOException("Error in Base64 code reading stream.");
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16384.java,41,100
default,63582.java,41,100
----------------------------------------
    public void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        HttpSession ssn = req.getSession(true);
        String send = req.getParameter("send");
        String host = req.getParameter("hostname");
        String user = req.getParameter("username");
        String passwd = req.getParameter("password");
        URLName url = new URLName(protocol, host, -1, mbox, user, passwd);
        ServletOutputStream out = res.getOutputStream();
        res.setContentType("text/html");
        out.println("<html><body bgcolor=\"#CCCCFF\">");
        if (send != null) {
            send(req, res, out, ssn);
        } else {
            MailUserData mud = new MailUserData(url);
            ssn.putValue("javamailservlet", mud);
            try {
                Properties props = System.getProperties();
                props.put("mail.smtp.host", host);
                Session session = Session.getDefaultInstance(props, null);
                session.setDebug(false);
                Store store = session.getStore(url);
                store.connect();
                Folder folder = store.getDefaultFolder();
                if (folder == null) throw new MessagingException("No default folder");
                folder = folder.getFolder(mbox);
                if (folder == null) throw new MessagingException("Invalid folder");
                folder.open(Folder.READ_WRITE);
                int totalMessages = folder.getMessageCount();
                Message[] msgs = folder.getMessages();
                FetchProfile fp = new FetchProfile();
                fp.add(FetchProfile.Item.ENVELOPE);
                folder.fetch(msgs, fp);
                System.out.println("Login from: " + store.getURLName());
                mud.setSession(session);
                mud.setStore(store);
                mud.setFolder(folder);
                out.print("<center>");
                out.print("<font face=\"Arial,Helvetica\" font size=+3>");
                out.println("<b>Welcome to JavaMail!</b></font></center><p>");
                out.println("<table width=\"50%\" border=0 align=center>");
                out.print("<tr><td width=\"75%\" bgcolor=\"#ffffcc\">");
                out.print("<font face=\"Arial,Helvetica\" font size=-1>");
                out.println("<b>FolderName</b></font></td><br>");
                out.print("<td width=\"25%\" bgcolor=\"#ffffcc\">");
                out.print("<font face=\"Arial,Helvetica\" font size=-1>");
                out.println("<b>Messages</b></font></td><br>");
                out.println("</tr>");
                out.print("<tr><td width=\"75%\" bgcolor=\"#ffffff\">");
                out.print("<a href=\"" + HttpUtils.getRequestURL(req) + "\">" + "Inbox" + "</a></td><br>");
                out.println("<td width=\"25%\" bgcolor=\"#ffffff\">" + totalMessages + "</td>");
                out.println("</tr>");
                out.println("</table");
            } catch (Exception ex) {
                out.println(ex.toString());
            } finally {
                out.println("</body></html>");
                out.close();
            }
        }
    }
----------------------------------------
    public void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        HttpSession ssn = req.getSession(true);
        String send = req.getParameter("send");
        String host = req.getParameter("hostname");
        String user = req.getParameter("username");
        String passwd = req.getParameter("password");
        URLName url = new URLName(protocol, host, -1, mbox, user, passwd);
        ServletOutputStream out = res.getOutputStream();
        res.setContentType("text/html");
        out.println("<html><body bgcolor=\"#CCCCFF\">");
        if (send != null) {
            send(req, res, out, ssn);
        } else {
            MailUserData mud = new MailUserData(url);
            ssn.putValue("javamailservlet", mud);
            try {
                Properties props = System.getProperties();
                props.put("mail.smtp.host", host);
                Session session = Session.getDefaultInstance(props, null);
                session.setDebug(false);
                Store store = session.getStore(url);
                store.connect();
                Folder folder = store.getDefaultFolder();
                if (folder == null) throw new MessagingException("No default folder");
                folder = folder.getFolder(mbox);
                if (folder == null) throw new MessagingException("Invalid folder");
                folder.open(Folder.READ_WRITE);
                int totalMessages = folder.getMessageCount();
                Message[] msgs = folder.getMessages();
                FetchProfile fp = new FetchProfile();
                fp.add(FetchProfile.Item.ENVELOPE);
                folder.fetch(msgs, fp);
                System.out.println("Login from: " + store.getURLName());
                mud.setSession(session);
                mud.setStore(store);
                mud.setFolder(folder);
                out.print("<center>");
                out.print("<font face=\"Arial,Helvetica\" font size=+3>");
                out.println("<b>Welcome to JavaMail!</b></font></center><p>");
                out.println("<table width=\"50%\" border=0 align=center>");
                out.print("<tr><td width=\"75%\" bgcolor=\"#ffffcc\">");
                out.print("<font face=\"Arial,Helvetica\" font size=-1>");
                out.println("<b>FolderName</b></font></td><br>");
                out.print("<td width=\"25%\" bgcolor=\"#ffffcc\">");
                out.print("<font face=\"Arial,Helvetica\" font size=-1>");
                out.println("<b>Messages</b></font></td><br>");
                out.println("</tr>");
                out.print("<tr><td width=\"75%\" bgcolor=\"#ffffff\">");
                out.print("<a href=\"" + HttpUtils.getRequestURL(req) + "\">" + "Inbox" + "</a></td><br>");
                out.println("<td width=\"25%\" bgcolor=\"#ffffff\">" + totalMessages + "</td>");
                out.println("</tr>");
                out.println("</table");
            } catch (Exception ex) {
                out.println(ex.toString());
            } finally {
                out.println("</body></html>");
                out.close();
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,85394.java,981,1039
selected,1511595.java,979,1037
----------------------------------------
        public int read() throws java.io.IOException {
            if (position < 0) {
                if (encode) {
                    byte[] b3 = new byte[3];
                    int numBinaryBytes = 0;
                    for (int i = 0; i < 3; i++) {
                        try {
                            int b = in.read();
                            if (b >= 0) {
                                b3[i] = (byte) b;
                                numBinaryBytes++;
                            }
                        } catch (java.io.IOException e) {
                            if (i == 0) throw e;
                        }
                    }
                    if (numBinaryBytes > 0) {
                        encode3to4(b3, 0, numBinaryBytes, buffer, 0, options);
                        position = 0;
                        numSigBytes = 4;
                    } else {
                        return -1;
                    }
                } else {
                    byte[] b4 = new byte[4];
                    int i = 0;
                    for (i = 0; i < 4; i++) {
                        int b = 0;
                        do {
                            b = in.read();
                        } while (b >= 0 && decodabet[b & 0x7f] <= WHITE_SPACE_ENC);
                        if (b < 0) break;
                        b4[i] = (byte) b;
                    }
                    if (i == 4) {
                        numSigBytes = decode4to3(b4, 0, buffer, 0, options);
                        position = 0;
                    } else if (i == 0) {
                        return -1;
                    } else {
                        throw new java.io.IOException("Improperly padded Base64 input.");
                    }
                }
            }
            if (position >= 0) {
                if (position >= numSigBytes) return -1;
                if (encode && breakLines && lineLength >= MAX_LINE_LENGTH) {
                    lineLength = 0;
                    return '\n';
                } else {
                    lineLength++;
                    int b = buffer[position++];
                    if (position >= bufferLength) position = -1;
                    return b & 0xFF;
                }
            } else {
                throw new java.io.IOException("Error in Base64 code reading stream.");
            }
        }
----------------------------------------
        public int read() throws java.io.IOException {
            if (position < 0) {
                if (encode) {
                    byte[] b3 = new byte[3];
                    int numBinaryBytes = 0;
                    for (int i = 0; i < 3; i++) {
                        try {
                            int b = in.read();
                            if (b >= 0) {
                                b3[i] = (byte) b;
                                numBinaryBytes++;
                            }
                        } catch (java.io.IOException e) {
                            if (i == 0) throw e;
                        }
                    }
                    if (numBinaryBytes > 0) {
                        encode3to4(b3, 0, numBinaryBytes, buffer, 0, options);
                        position = 0;
                        numSigBytes = 4;
                    } else {
                        return -1;
                    }
                } else {
                    byte[] b4 = new byte[4];
                    int i = 0;
                    for (i = 0; i < 4; i++) {
                        int b = 0;
                        do {
                            b = in.read();
                        } while (b >= 0 && decodabet[b & 0x7f] <= WHITE_SPACE_ENC);
                        if (b < 0) break;
                        b4[i] = (byte) b;
                    }
                    if (i == 4) {
                        numSigBytes = decode4to3(b4, 0, buffer, 0, options);
                        position = 0;
                    } else if (i == 0) {
                        return -1;
                    } else {
                        throw new java.io.IOException("Improperly padded Base64 input.");
                    }
                }
            }
            if (position >= 0) {
                if (position >= numSigBytes) return -1;
                if (encode && breakLines && lineLength >= MAX_LINE_LENGTH) {
                    lineLength = 0;
                    return '\n';
                } else {
                    lineLength++;
                    int b = buffer[position++];
                    if (position >= bufferLength) position = -1;
                    return b & 0xFF;
                }
            } else {
                throw new java.io.IOException("Error in Base64 code reading stream.");
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,931640.java,360,413
selected,3127.java,360,413
----------------------------------------
    public RestServiceResult listUserWithoutExerciseGroup(RestServiceResult serviceResult, Long nExerciseId) {
        List<MaUser> listUserWithoutGroup = new ArrayList<MaUser>();
        List<MaUser> listUserCourse = new ArrayList<MaUser>();
        Vector<Long> vecUserId = new Vector<Long>();
        try {
            CoQuestion coQuestion = new CoQuestionDAO().findById(nExerciseId);
            EntityManagerHelper.refresh(coQuestion);
            CoCourse courseOnlyActivity = null;
            if (courseOnlyActivity == null) {
                CoCourse coCourse = coQuestion.getCoTest().getCoSequence().getCoUnit().getCoCourse();
                List<CoCourseUser> list = new ArrayList<CoCourseUser>(coCourse.getCoCourseUsers());
                for (Iterator iterator = list.iterator(); iterator.hasNext(); ) {
                    CoCourseUser coCourseUser = (CoCourseUser) iterator.next();
                    listUserCourse.add(coCourseUser.getMaUser());
                }
            } else {
                List<CoCourseUser> list = new ArrayList<CoCourseUser>(courseOnlyActivity.getCoCourseUsers());
                for (Iterator iterator = list.iterator(); iterator.hasNext(); ) {
                    CoCourseUser coCourseUser = (CoCourseUser) iterator.next();
                    listUserCourse.add(coCourseUser.getMaUser());
                }
            }
            List<ToQuestionGroup> listExerciseGroup = new ArrayList<ToQuestionGroup>();
            listExerciseGroup.addAll(coQuestion.getToQuestionGroups());
            for (Iterator<ToQuestionGroup> iterator = listExerciseGroup.iterator(); iterator.hasNext(); ) {
                ToQuestionGroup toQuestionGroup = iterator.next();
                for (Iterator<CoUserQuestionGroup> iterator2 = toQuestionGroup.getCoUserQuestionGroups().iterator(); iterator2.hasNext(); ) {
                    CoUserQuestionGroup coUserQuestionGroup = iterator2.next();
                    if (coUserQuestionGroup.getFlagDeleted().equals("N")) vecUserId.add(coUserQuestionGroup.getMaUser().getUserId());
                }
            }
            for (Iterator<MaUser> iterator = listUserCourse.iterator(); iterator.hasNext(); ) {
                MaUser maUser = iterator.next();
                if (vecUserId.contains(maUser.getUserId())) {
                    continue;
                } else {
                    listUserWithoutGroup.add(maUser);
                }
            }
            if (listUserWithoutGroup.size() == 0) {
                serviceResult.setError(true);
                serviceResult.setMessage(bundle.getString("user.list.notFound"));
            } else {
                Object[] arrayParam = { listUserWithoutGroup.size() };
                serviceResult.setMessage(MessageFormat.format(bundle.getString("user.list.success"), arrayParam));
                serviceResult.setObjResult(listUserWithoutGroup);
            }
        } catch (Exception e) {
            serviceResult.setError(true);
            log.info("Error buscando usuarios sin grupo ");
            e.printStackTrace();
        }
        return serviceResult;
    }
----------------------------------------
    public RestServiceResult listUserWithoutExerciseGroup(RestServiceResult serviceResult, Long nExerciseId) {
        List<MaUser> listUserWithoutGroup = new ArrayList<MaUser>();
        List<MaUser> listUserCourse = new ArrayList<MaUser>();
        Vector<Long> vecUserId = new Vector<Long>();
        try {
            CoExercises1 coExercises1 = new CoExercises1DAO().findById(nExerciseId);
            EntityManagerHelper.refresh(coExercises1);
            CoCourse courseOnlyActivity = coExercises1.getCoActivity().getCoCourse();
            if (courseOnlyActivity == null) {
                CoCourse coCourse = coExercises1.getCoActivity().getCoSequence().getCoUnit().getCoCourse();
                List<CoCourseUser> list = new ArrayList<CoCourseUser>(coCourse.getCoCourseUsers());
                for (Iterator iterator = list.iterator(); iterator.hasNext(); ) {
                    CoCourseUser coCourseUser = (CoCourseUser) iterator.next();
                    listUserCourse.add(coCourseUser.getMaUser());
                }
            } else {
                List<CoCourseUser> list = new ArrayList<CoCourseUser>(courseOnlyActivity.getCoCourseUsers());
                for (Iterator iterator = list.iterator(); iterator.hasNext(); ) {
                    CoCourseUser coCourseUser = (CoCourseUser) iterator.next();
                    listUserCourse.add(coCourseUser.getMaUser());
                }
            }
            List<ToExercise1Group> listExerciseGroup = new ArrayList<ToExercise1Group>();
            listExerciseGroup.addAll(coExercises1.getToExercise1Groups());
            for (Iterator<ToExercise1Group> iterator = listExerciseGroup.iterator(); iterator.hasNext(); ) {
                ToExercise1Group toExercise1Group = iterator.next();
                for (Iterator<CoUserExer1Group> iterator2 = toExercise1Group.getCoUserExer1Groups().iterator(); iterator2.hasNext(); ) {
                    CoUserExer1Group coUserExer1Group = iterator2.next();
                    if (coUserExer1Group.getFlagDeleted().equals("N")) vecUserId.add(coUserExer1Group.getMaUser().getUserId());
                }
            }
            for (Iterator<MaUser> iterator = listUserCourse.iterator(); iterator.hasNext(); ) {
                MaUser maUser = iterator.next();
                if (vecUserId.contains(maUser.getUserId())) {
                    continue;
                } else {
                    listUserWithoutGroup.add(maUser);
                }
            }
            if (listUserWithoutGroup.size() == 0) {
                serviceResult.setError(true);
                serviceResult.setMessage(bundle.getString("user.list.notFound"));
            } else {
                Object[] arrayParam = { listUserWithoutGroup.size() };
                serviceResult.setMessage(MessageFormat.format(bundle.getString("user.list.success"), arrayParam));
                serviceResult.setObjResult(listUserWithoutGroup);
            }
        } catch (Exception e) {
            serviceResult.setError(true);
            log.info("Error buscando usuarios sin grupo ");
            e.printStackTrace();
        }
        return serviceResult;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63608.java,298,353
default,19250.java,298,353
----------------------------------------
    private void compareFile(File fileA, File fileB, boolean skipIdentical, String basePath) {
        String filename = null;
        if (fileB != null) filename = fileB.getPath(); else if (fileA != null) filename = fileA.getPath();
        if (filename != null && basePath != null && filename.startsWith(basePath)) {
            filename = filename.substring(basePath.length());
            if (filename.startsWith(File.separator)) filename = filename.substring(1);
        }
        updateProgress(filename);
        if (!isFile(fileA)) fileA = null;
        if (!isFile(fileB)) fileB = null;
        examineFiles(fileA, fileB);
        if (skipIdentical && filesAreIdentical) return;
        StringBuffer fileTable;
        String label, htmlName;
        if (fileA == null) {
            fileTable = addedTable;
            label = "Added";
        } else if (fileB == null) {
            fileTable = deletedTable;
            label = "Deleted";
        } else {
            fileTable = modifiedTable;
            label = "Modified";
        }
        htmlName = HTMLUtils.escapeEntities(filename);
        if (filesAreBinary) {
            fileTable.append("<tr><td nowrap>").append(htmlName);
            if (fileTable == modifiedTable) fileTable.append("</td><td></td><td></td><td></td><td>");
            fileTable.append("</td><td></td><td>Binary</td></tr>\n");
            return;
        }
        String contentsA = getContents(fileA);
        String contentsB = getContents(fileB);
        PSPDiff diff = new PSPDiff(webServer, contentsA, contentsB, filename, null);
        if (skipIdentical && (diff.getDeleted() + diff.getAdded() + diff.getModified() == 0)) return;
        base += diff.getBase();
        deleted += diff.getDeleted();
        added += diff.getAdded();
        modified += diff.getModified();
        total += diff.getTotal();
        fileTable.append("<tr><td nowrap><a href='#file").append(counter).append("'>").append(htmlName).append("</a>");
        if (fileTable == deletedTable) fileTable.append("</td><td>").append(diff.getBase()); else if (fileTable == modifiedTable) fileTable.append("</td><td>").append(diff.getBase()).append("</td><td>").append(diff.getDeleted()).append("</td><td>").append(diff.getModified()).append("</td><td>").append(diff.getAdded());
        fileTable.append("</td><td>").append(diff.getTotal()).append("</td><td>").append(AbstractLanguageFilter.getFilterName(diff.getFilter())).append("</td></tr>\n");
        redlinesOut.print("<hr><DIV onMouseOver=\"window.defaultStatus='");
        redlinesOut.print(EscapeString.escape(htmlName, '\\', "\""));
        redlinesOut.print("'\"><h1>");
        redlinesOut.print(label);
        redlinesOut.print(": <a name='file");
        redlinesOut.print(counter++);
        redlinesOut.print("'>");
        redlinesOut.print(htmlName);
        redlinesOut.print("</a></h1>");
        diff.displayHTMLRedlines(redlinesOut);
        redlinesOut.print("</DIV>\n\n\n");
        diff.dispose();
    }
----------------------------------------
    private void compareFile(File fileA, File fileB, boolean skipIdentical, String basePath) {
        String filename = null;
        if (fileB != null) filename = fileB.getPath(); else if (fileA != null) filename = fileA.getPath();
        if (filename != null && basePath != null && filename.startsWith(basePath)) {
            filename = filename.substring(basePath.length());
            if (filename.startsWith(File.separator)) filename = filename.substring(1);
        }
        updateProgress(filename);
        if (!isFile(fileA)) fileA = null;
        if (!isFile(fileB)) fileB = null;
        examineFiles(fileA, fileB);
        if (skipIdentical && filesAreIdentical) return;
        StringBuffer fileTable;
        String label, htmlName;
        if (fileA == null) {
            fileTable = addedTable;
            label = "Added";
        } else if (fileB == null) {
            fileTable = deletedTable;
            label = "Deleted";
        } else {
            fileTable = modifiedTable;
            label = "Modified";
        }
        htmlName = HTMLUtils.escapeEntities(filename);
        if (filesAreBinary) {
            fileTable.append("<tr><td nowrap>").append(htmlName);
            if (fileTable == modifiedTable) fileTable.append("</td><td></td><td></td><td></td><td>");
            fileTable.append("</td><td></td><td>Binary</td></tr>\n");
            return;
        }
        String contentsA = getContents(fileA);
        String contentsB = getContents(fileB);
        PSPDiff diff = new PSPDiff(webServer, contentsA, contentsB, filename, null);
        if (skipIdentical && (diff.getDeleted() + diff.getAdded() + diff.getModified() == 0)) return;
        base += diff.getBase();
        deleted += diff.getDeleted();
        added += diff.getAdded();
        modified += diff.getModified();
        total += diff.getTotal();
        fileTable.append("<tr><td nowrap><a href='#file").append(counter).append("'>").append(htmlName).append("</a>");
        if (fileTable == deletedTable) fileTable.append("</td><td>").append(diff.getBase()); else if (fileTable == modifiedTable) fileTable.append("</td><td>").append(diff.getBase()).append("</td><td>").append(diff.getDeleted()).append("</td><td>").append(diff.getModified()).append("</td><td>").append(diff.getAdded());
        fileTable.append("</td><td>").append(diff.getTotal()).append("</td><td>").append(AbstractLanguageFilter.getFilterName(diff.getFilter())).append("</td></tr>\n");
        redlinesOut.print("<hr><DIV onMouseOver=\"window.defaultStatus='");
        redlinesOut.print(EscapeString.escape(htmlName, '\\', "\""));
        redlinesOut.print("'\"><h1>");
        redlinesOut.print(label);
        redlinesOut.print(": <a name='file");
        redlinesOut.print(counter++);
        redlinesOut.print("'>");
        redlinesOut.print(htmlName);
        redlinesOut.print("</a></h1>");
        diff.displayHTMLRedlines(redlinesOut);
        redlinesOut.print("</DIV>\n\n\n");
        diff.dispose();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80614.java,298,353
default,85302.java,298,353
----------------------------------------
    private void compareFile(File fileA, File fileB, boolean skipIdentical, String basePath) {
        String filename = null;
        if (fileB != null) filename = fileB.getPath(); else if (fileA != null) filename = fileA.getPath();
        if (filename != null && basePath != null && filename.startsWith(basePath)) {
            filename = filename.substring(basePath.length());
            if (filename.startsWith(File.separator)) filename = filename.substring(1);
        }
        updateProgress(filename);
        if (!isFile(fileA)) fileA = null;
        if (!isFile(fileB)) fileB = null;
        examineFiles(fileA, fileB);
        if (skipIdentical && filesAreIdentical) return;
        StringBuffer fileTable;
        String label, htmlName;
        if (fileA == null) {
            fileTable = addedTable;
            label = "Added";
        } else if (fileB == null) {
            fileTable = deletedTable;
            label = "Deleted";
        } else {
            fileTable = modifiedTable;
            label = "Modified";
        }
        htmlName = HTMLUtils.escapeEntities(filename);
        if (filesAreBinary) {
            fileTable.append("<tr><td nowrap>").append(htmlName);
            if (fileTable == modifiedTable) fileTable.append("</td><td></td><td></td><td></td><td>");
            fileTable.append("</td><td></td><td>Binary</td></tr>\n");
            return;
        }
        String contentsA = getContents(fileA);
        String contentsB = getContents(fileB);
        PSPDiff diff = new PSPDiff(webServer, contentsA, contentsB, filename, null);
        if (skipIdentical && (diff.getDeleted() + diff.getAdded() + diff.getModified() == 0)) return;
        base += diff.getBase();
        deleted += diff.getDeleted();
        added += diff.getAdded();
        modified += diff.getModified();
        total += diff.getTotal();
        fileTable.append("<tr><td nowrap><a href='#file").append(counter).append("'>").append(htmlName).append("</a>");
        if (fileTable == deletedTable) fileTable.append("</td><td>").append(diff.getBase()); else if (fileTable == modifiedTable) fileTable.append("</td><td>").append(diff.getBase()).append("</td><td>").append(diff.getDeleted()).append("</td><td>").append(diff.getModified()).append("</td><td>").append(diff.getAdded());
        fileTable.append("</td><td>").append(diff.getTotal()).append("</td><td>").append(AbstractLanguageFilter.getFilterName(diff.getFilter())).append("</td></tr>\n");
        redlinesOut.print("<hr><DIV onMouseOver=\"window.defaultStatus='");
        redlinesOut.print(EscapeString.escape(htmlName, '\\', "\""));
        redlinesOut.print("'\"><h1>");
        redlinesOut.print(label);
        redlinesOut.print(": <a name='file");
        redlinesOut.print(counter++);
        redlinesOut.print("'>");
        redlinesOut.print(htmlName);
        redlinesOut.print("</a></h1>");
        diff.displayHTMLRedlines(redlinesOut);
        redlinesOut.print("</DIV>\n\n\n");
        diff.dispose();
    }
----------------------------------------
    private void compareFile(File fileA, File fileB, boolean skipIdentical, String basePath) {
        String filename = null;
        if (fileB != null) filename = fileB.getPath(); else if (fileA != null) filename = fileA.getPath();
        if (filename != null && basePath != null && filename.startsWith(basePath)) {
            filename = filename.substring(basePath.length());
            if (filename.startsWith(File.separator)) filename = filename.substring(1);
        }
        updateProgress(filename);
        if (!isFile(fileA)) fileA = null;
        if (!isFile(fileB)) fileB = null;
        examineFiles(fileA, fileB);
        if (skipIdentical && filesAreIdentical) return;
        StringBuffer fileTable;
        String label, htmlName;
        if (fileA == null) {
            fileTable = addedTable;
            label = "Added";
        } else if (fileB == null) {
            fileTable = deletedTable;
            label = "Deleted";
        } else {
            fileTable = modifiedTable;
            label = "Modified";
        }
        htmlName = HTMLUtils.escapeEntities(filename);
        if (filesAreBinary) {
            fileTable.append("<tr><td nowrap>").append(htmlName);
            if (fileTable == modifiedTable) fileTable.append("</td><td></td><td></td><td></td><td>");
            fileTable.append("</td><td></td><td>Binary</td></tr>\n");
            return;
        }
        String contentsA = getContents(fileA);
        String contentsB = getContents(fileB);
        PSPDiff diff = new PSPDiff(webServer, contentsA, contentsB, filename, null);
        if (skipIdentical && (diff.getDeleted() + diff.getAdded() + diff.getModified() == 0)) return;
        base += diff.getBase();
        deleted += diff.getDeleted();
        added += diff.getAdded();
        modified += diff.getModified();
        total += diff.getTotal();
        fileTable.append("<tr><td nowrap><a href='#file").append(counter).append("'>").append(htmlName).append("</a>");
        if (fileTable == deletedTable) fileTable.append("</td><td>").append(diff.getBase()); else if (fileTable == modifiedTable) fileTable.append("</td><td>").append(diff.getBase()).append("</td><td>").append(diff.getDeleted()).append("</td><td>").append(diff.getModified()).append("</td><td>").append(diff.getAdded());
        fileTable.append("</td><td>").append(diff.getTotal()).append("</td><td>").append(AbstractLanguageFilter.getFilterName(diff.getFilter())).append("</td></tr>\n");
        redlinesOut.print("<hr><DIV onMouseOver=\"window.defaultStatus='");
        redlinesOut.print(EscapeString.escape(htmlName, '\\', "\""));
        redlinesOut.print("'\"><h1>");
        redlinesOut.print(label);
        redlinesOut.print(": <a name='file");
        redlinesOut.print(counter++);
        redlinesOut.print("'>");
        redlinesOut.print(htmlName);
        redlinesOut.print("</a></h1>");
        diff.displayHTMLRedlines(redlinesOut);
        redlinesOut.print("</DIV>\n\n\n");
        diff.dispose();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2002839.java,207,262
selected,1909964.java,207,262
----------------------------------------
        public void run() {
            try {
                InputStream is = mySocket.getInputStream();
                if (is == null) return;
                BufferedReader in = new BufferedReader(new InputStreamReader(is));
                StringTokenizer st = new StringTokenizer(in.readLine());
                if (!st.hasMoreTokens()) sendError(HTTP_BADREQUEST, "BAD REQUEST: Syntax error. Usage: GET /example/file.html");
                String method = st.nextToken();
                if (!st.hasMoreTokens()) sendError(HTTP_BADREQUEST, "BAD REQUEST: Missing URI. Usage: GET /example/file.html");
                String uri = st.nextToken();
                Properties parms = new Properties();
                int qmi = uri.indexOf('?');
                if (qmi >= 0) {
                    decodeParms(uri.substring(qmi + 1), parms);
                    uri = decodePercent(uri.substring(0, qmi));
                } else uri = decodePercent(uri);
                Properties header = new Properties();
                if (st.hasMoreTokens()) {
                    String line = in.readLine();
                    while (line.trim().length() > 0) {
                        int p = line.indexOf(':');
                        header.put(line.substring(0, p).trim().toLowerCase(), line.substring(p + 1).trim());
                        line = in.readLine();
                    }
                }
                if (method.equalsIgnoreCase("POST")) {
                    long size = 0x7FFFFFFFFFFFFFFFl;
                    String contentLength = header.getProperty("content-length");
                    if (contentLength != null) {
                        try {
                            size = Integer.parseInt(contentLength);
                        } catch (NumberFormatException ex) {
                        }
                    }
                    String postLine = "";
                    char buf[] = new char[512];
                    int read = in.read(buf);
                    while (read >= 0 && size > 0 && !postLine.endsWith("\r\n")) {
                        size -= read;
                        postLine += String.valueOf(buf, 0, read);
                        if (size > 0) read = in.read(buf);
                    }
                    postLine = postLine.trim();
                    decodeParms(postLine, parms);
                }
                Response r = serve(uri, method, header, parms);
                if (r == null) sendError(HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: Serve() returned a null response."); else sendResponse(r.status, r.mimeType, r.header, r.data);
                in.close();
            } catch (IOException ioe) {
                try {
                    sendError(HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
                } catch (Throwable t) {
                }
            } catch (InterruptedException ie) {
            }
        }
----------------------------------------
        public void run() {
            try {
                InputStream is = mySocket.getInputStream();
                if (is == null) return;
                BufferedReader in = new BufferedReader(new InputStreamReader(is));
                StringTokenizer st = new StringTokenizer(in.readLine());
                if (!st.hasMoreTokens()) sendError(HTTP_BADREQUEST, "BAD REQUEST: Syntax error. Usage: GET /example/file.html");
                String method = st.nextToken();
                if (!st.hasMoreTokens()) sendError(HTTP_BADREQUEST, "BAD REQUEST: Missing URI. Usage: GET /example/file.html");
                String uri = st.nextToken();
                Properties parms = new Properties();
                int qmi = uri.indexOf('?');
                if (qmi >= 0) {
                    decodeParms(uri.substring(qmi + 1), parms);
                    uri = decodePercent(uri.substring(0, qmi));
                } else uri = decodePercent(uri);
                Properties header = new Properties();
                if (st.hasMoreTokens()) {
                    String line = in.readLine();
                    while (line.trim().length() > 0) {
                        int p = line.indexOf(':');
                        header.put(line.substring(0, p).trim().toLowerCase(), line.substring(p + 1).trim());
                        line = in.readLine();
                    }
                }
                if (method.equalsIgnoreCase("POST")) {
                    long size = 0x7FFFFFFFFFFFFFFFl;
                    String contentLength = header.getProperty("content-length");
                    if (contentLength != null) {
                        try {
                            size = Integer.parseInt(contentLength);
                        } catch (NumberFormatException ex) {
                        }
                    }
                    String postLine = "";
                    char buf[] = new char[512];
                    int read = in.read(buf);
                    while (read >= 0 && size > 0 && !postLine.endsWith("\r\n")) {
                        size -= read;
                        postLine += String.valueOf(buf, 0, read);
                        if (size > 0) read = in.read(buf);
                    }
                    postLine = postLine.trim();
                    decodeParms(postLine, parms);
                }
                Response r = serve(uri, method, header, parms);
                if (r == null) sendError(HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: Serve() returned a null response."); else sendResponse(r.status, r.mimeType, r.header, r.data);
                in.close();
            } catch (IOException ioe) {
                try {
                    sendError(HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
                } catch (Throwable t) {
                }
            } catch (InterruptedException ie) {
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1163823.java,693,743
selected,119809.java,693,743
----------------------------------------
    private Pool loadDensityFileBinary(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        Properties props = new Properties();
        int blockSize = 0;
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(DENSITY_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        int[] vectorLength = new int[numStreams];
        for (int i = 0; i < numStreams; i++) {
            vectorLength[i] = readInt(dis);
        }
        int rawLength = readInt(dis);
        logger.fine("Nstates " + numStates);
        logger.fine("Nstreams " + numStreams);
        logger.fine("NgaussiansPerState " + numGaussiansPerState);
        logger.fine("vectorLength " + vectorLength.length);
        logger.fine("rawLength " + rawLength);
        for (int i = 0; i < numStreams; i++) {
            blockSize += vectorLength[i];
        }
        assert rawLength == numGaussiansPerState * blockSize * numStates;
        assert numStreams == 1;
        Pool pool = new Pool(path);
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        int r = 0;
        for (int i = 0; i < numStates; i++) {
            for (int j = 0; j < numStreams; j++) {
                for (int k = 0; k < numGaussiansPerState; k++) {
                    float[] density = readFloatArray(dis, vectorLength[j]);
                    floorData(density, floor);
                    pool.put(i * numGaussiansPerState + k, density);
                }
            }
        }
        int checkSum = readInt(dis);
        dis.close();
        return pool;
    }
----------------------------------------
    private Pool loadDensityFileBinary(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        Properties props = new Properties();
        int blockSize = 0;
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(DENSITY_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        int[] vectorLength = new int[numStreams];
        for (int i = 0; i < numStreams; i++) {
            vectorLength[i] = readInt(dis);
        }
        int rawLength = readInt(dis);
        logger.fine("Nstates " + numStates);
        logger.fine("Nstreams " + numStreams);
        logger.fine("NgaussiansPerState " + numGaussiansPerState);
        logger.fine("vectorLength " + vectorLength.length);
        logger.fine("rawLength " + rawLength);
        for (int i = 0; i < numStreams; i++) {
            blockSize += vectorLength[i];
        }
        assert rawLength == numGaussiansPerState * blockSize * numStates;
        assert numStreams == 1;
        Pool pool = new Pool(path);
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        int r = 0;
        for (int i = 0; i < numStates; i++) {
            for (int j = 0; j < numStreams; j++) {
                for (int k = 0; k < numGaussiansPerState; k++) {
                    float[] density = readFloatArray(dis, vectorLength[j]);
                    floorData(density, floor);
                    pool.put(i * numGaussiansPerState + k, density);
                }
            }
        }
        int checkSum = readInt(dis);
        dis.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,186786.java,681,731
selected,1500609.java,681,731
----------------------------------------
    private Pool loadDensityFileBinary(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        Properties props = new Properties();
        int blockSize = 0;
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(DENSITY_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        int[] vectorLength = new int[numStreams];
        for (int i = 0; i < numStreams; i++) {
            vectorLength[i] = readInt(dis);
        }
        int rawLength = readInt(dis);
        logger.fine("Nstates " + numStates);
        logger.fine("Nstreams " + numStreams);
        logger.fine("NgaussiansPerState " + numGaussiansPerState);
        logger.fine("vectorLength " + vectorLength.length);
        logger.fine("rawLength " + rawLength);
        for (int i = 0; i < numStreams; i++) {
            blockSize += vectorLength[i];
        }
        assert rawLength == numGaussiansPerState * blockSize * numStates;
        assert numStreams == 1;
        Pool pool = new Pool(path);
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        int r = 0;
        for (int i = 0; i < numStates; i++) {
            for (int j = 0; j < numStreams; j++) {
                for (int k = 0; k < numGaussiansPerState; k++) {
                    float[] density = readFloatArray(dis, vectorLength[j]);
                    floorData(density, floor);
                    pool.put(i * numGaussiansPerState + k, density);
                }
            }
        }
        int checkSum = readInt(dis);
        dis.close();
        return pool;
    }
----------------------------------------
    private Pool loadDensityFileBinary(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        Properties props = new Properties();
        int blockSize = 0;
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(DENSITY_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        int[] vectorLength = new int[numStreams];
        for (int i = 0; i < numStreams; i++) {
            vectorLength[i] = readInt(dis);
        }
        int rawLength = readInt(dis);
        logger.fine("Nstates " + numStates);
        logger.fine("Nstreams " + numStreams);
        logger.fine("NgaussiansPerState " + numGaussiansPerState);
        logger.fine("vectorLength " + vectorLength.length);
        logger.fine("rawLength " + rawLength);
        for (int i = 0; i < numStreams; i++) {
            blockSize += vectorLength[i];
        }
        assert rawLength == numGaussiansPerState * blockSize * numStates;
        assert numStreams == 1;
        Pool pool = new Pool(path);
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        int r = 0;
        for (int i = 0; i < numStates; i++) {
            for (int j = 0; j < numStreams; j++) {
                for (int k = 0; k < numGaussiansPerState; k++) {
                    float[] density = readFloatArray(dis, vectorLength[j]);
                    floorData(density, floor);
                    pool.put(i * numGaussiansPerState + k, density);
                }
            }
        }
        int checkSum = readInt(dis);
        dis.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1087894.java,681,731
selected,1746689.java,693,743
----------------------------------------
    private Pool loadDensityFileBinary(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        Properties props = new Properties();
        int blockSize = 0;
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(DENSITY_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        int[] vectorLength = new int[numStreams];
        for (int i = 0; i < numStreams; i++) {
            vectorLength[i] = readInt(dis);
        }
        int rawLength = readInt(dis);
        logger.fine("Nstates " + numStates);
        logger.fine("Nstreams " + numStreams);
        logger.fine("NgaussiansPerState " + numGaussiansPerState);
        logger.fine("vectorLength " + vectorLength.length);
        logger.fine("rawLength " + rawLength);
        for (int i = 0; i < numStreams; i++) {
            blockSize += vectorLength[i];
        }
        assert rawLength == numGaussiansPerState * blockSize * numStates;
        assert numStreams == 1;
        Pool pool = new Pool(path);
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        int r = 0;
        for (int i = 0; i < numStates; i++) {
            for (int j = 0; j < numStreams; j++) {
                for (int k = 0; k < numGaussiansPerState; k++) {
                    float[] density = readFloatArray(dis, vectorLength[j]);
                    floorData(density, floor);
                    pool.put(i * numGaussiansPerState + k, density);
                }
            }
        }
        int checkSum = readInt(dis);
        dis.close();
        return pool;
    }
----------------------------------------
    private Pool loadDensityFileBinary(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        Properties props = new Properties();
        int blockSize = 0;
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(DENSITY_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        int[] vectorLength = new int[numStreams];
        for (int i = 0; i < numStreams; i++) {
            vectorLength[i] = readInt(dis);
        }
        int rawLength = readInt(dis);
        logger.fine("Nstates " + numStates);
        logger.fine("Nstreams " + numStreams);
        logger.fine("NgaussiansPerState " + numGaussiansPerState);
        logger.fine("vectorLength " + vectorLength.length);
        logger.fine("rawLength " + rawLength);
        for (int i = 0; i < numStreams; i++) {
            blockSize += vectorLength[i];
        }
        assert rawLength == numGaussiansPerState * blockSize * numStates;
        assert numStreams == 1;
        Pool pool = new Pool(path);
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        int r = 0;
        for (int i = 0; i < numStates; i++) {
            for (int j = 0; j < numStreams; j++) {
                for (int k = 0; k < numGaussiansPerState; k++) {
                    float[] density = readFloatArray(dis, vectorLength[j]);
                    floorData(density, floor);
                    pool.put(i * numGaussiansPerState + k, density);
                }
            }
        }
        int checkSum = readInt(dis);
        dis.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109003.java,135,189
default,94357.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        String mergeCfg = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'm':
                    mergeCfg = g.getOptarg();
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            if (mergeCfg != null) {
                mergeCfg(cfg, mergeCfg);
            }
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (Exception e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114488.java,139,193
default,2085.java,135,189
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        String mergeCfg = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'm':
                    mergeCfg = g.getOptarg();
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            if (mergeCfg != null) {
                mergeCfg(cfg, mergeCfg);
            }
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (Exception e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        String mergeCfg = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'm':
                    mergeCfg = g.getOptarg();
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            if (mergeCfg != null) {
                mergeCfg(cfg, mergeCfg);
            }
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (Exception e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,377953.java,881,937
selected,1196689.java,569,624
----------------------------------------
    public final fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.BooleanLiteralExp parse_fr_inria_uml4tst_papyrus_ocl4tst_ocl4tst_BooleanLiteralExp() throws RecognitionException {
        fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.BooleanLiteralExp element = null;
        int parse_fr_inria_uml4tst_papyrus_ocl4tst_ocl4tst_BooleanLiteralExp_StartIndex = input.index();
        Token a0 = null;
        try {
            if (state.backtracking > 0 && alreadyParsedRule(input, 6)) {
                return element;
            }
            {
                {
                    a0 = (Token) match(input, BOOLEAN_LITERAL, FOLLOW_BOOLEAN_LITERAL_in_parse_fr_inria_uml4tst_papyrus_ocl4tst_ocl4tst_BooleanLiteralExp396);
                    if (state.failed) return element;
                    if (state.backtracking == 0) {
                        if (terminateParsing) {
                            throw new fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.resource.ocl4tst.mopp.Ocl4tstTerminateParsingException();
                        }
                        if (element == null) {
                            element = fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.Ocl4tstFactory.eINSTANCE.createBooleanLiteralExp();
                            incompleteObjects.push(element);
                        }
                        if (a0 != null) {
                            fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.resource.ocl4tst.IOcl4tstTokenResolver tokenResolver = tokenResolverFactory.createTokenResolver("BOOLEAN_LITERAL");
                            tokenResolver.setOptions(getOptions());
                            fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.resource.ocl4tst.IOcl4tstTokenResolveResult result = getFreshTokenResolveResult();
                            tokenResolver.resolve(a0.getText(), element.eClass().getEStructuralFeature(fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.Ocl4tstPackage.BOOLEAN_LITERAL_EXP__VALUE), result);
                            Object resolvedObject = result.getResolvedToken();
                            if (resolvedObject == null) {
                                addErrorToResource(result.getErrorMessage(), ((org.antlr.runtime3_3_0.CommonToken) a0).getLine(), ((org.antlr.runtime3_3_0.CommonToken) a0).getCharPositionInLine(), ((org.antlr.runtime3_3_0.CommonToken) a0).getStartIndex(), ((org.antlr.runtime3_3_0.CommonToken) a0).getStopIndex());
                            }
                            java.lang.Boolean resolved = (java.lang.Boolean) resolvedObject;
                            if (resolved != null) {
                                Object value = resolved;
                                element.eSet(element.eClass().getEStructuralFeature(fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.Ocl4tstPackage.BOOLEAN_LITERAL_EXP__VALUE), value);
                                completedElement(value, false);
                            }
                            collectHiddenTokens(element);
                            retrieveLayoutInformation(element, fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.resource.ocl4tst.grammar.Ocl4tstGrammarInformationProvider.OCL4TST_5_0_0_0, resolved, true);
                            copyLocalizationInfos((org.antlr.runtime3_3_0.CommonToken) a0, element);
                        }
                    }
                }
                if (state.backtracking == 0) {
                    addExpectedElement(fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.resource.ocl4tst.grammar.Ocl4tstFollowSetProvider.TERMINAL_3, 10);
                    addExpectedElement(fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.resource.ocl4tst.grammar.Ocl4tstFollowSetProvider.TERMINAL_4, 10);
                    addExpectedElement(fr.inria.uml4tst.papyrus.ocl4tst.ocl4tst.resource.ocl4tst.grammar.Ocl4tstFollowSetProvider.TERMINAL_9, 10);
                }
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
        } finally {
            if (state.backtracking > 0) {
                memoize(input, 6, parse_fr_inria_uml4tst_papyrus_ocl4tst_ocl4tst_BooleanLiteralExp_StartIndex);
            }
        }
        return element;
    }
----------------------------------------
    public final fr.inria.papyrus.uml4tst.emftext.alf.Name parse_fr_inria_papyrus_uml4tst_emftext_alf_Name() throws RecognitionException {
        fr.inria.papyrus.uml4tst.emftext.alf.Name element = null;
        int parse_fr_inria_papyrus_uml4tst_emftext_alf_Name_StartIndex = input.index();
        Token a0 = null;
        try {
            if (state.backtracking > 0 && alreadyParsedRule(input, 2)) {
                return element;
            }
            {
                {
                    a0 = (Token) match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_parse_fr_inria_papyrus_uml4tst_emftext_alf_Name119);
                    if (state.failed) return element;
                    if (state.backtracking == 0) {
                        if (terminateParsing) {
                            throw new fr.inria.papyrus.uml4tst.emftext.alf.resource.alf.mopp.AlfTerminateParsingException();
                        }
                        if (element == null) {
                            element = fr.inria.papyrus.uml4tst.emftext.alf.AlfFactory.eINSTANCE.createName();
                            incompleteObjects.push(element);
                        }
                        if (a0 != null) {
                            fr.inria.papyrus.uml4tst.emftext.alf.resource.alf.IAlfTokenResolver tokenResolver = tokenResolverFactory.createTokenResolver("IDENTIFIER");
                            tokenResolver.setOptions(getOptions());
                            fr.inria.papyrus.uml4tst.emftext.alf.resource.alf.IAlfTokenResolveResult result = getFreshTokenResolveResult();
                            tokenResolver.resolve(a0.getText(), element.eClass().getEStructuralFeature(fr.inria.papyrus.uml4tst.emftext.alf.AlfPackage.NAME__NAME), result);
                            Object resolvedObject = result.getResolvedToken();
                            if (resolvedObject == null) {
                                addErrorToResource(result.getErrorMessage(), ((org.antlr.runtime3_3_0.CommonToken) a0).getLine(), ((org.antlr.runtime3_3_0.CommonToken) a0).getCharPositionInLine(), ((org.antlr.runtime3_3_0.CommonToken) a0).getStartIndex(), ((org.antlr.runtime3_3_0.CommonToken) a0).getStopIndex());
                            }
                            java.lang.String resolved = (java.lang.String) resolvedObject;
                            if (resolved != null) {
                                Object value = resolved;
                                element.eSet(element.eClass().getEStructuralFeature(fr.inria.papyrus.uml4tst.emftext.alf.AlfPackage.NAME__NAME), value);
                                completedElement(value, false);
                            }
                            collectHiddenTokens(element);
                            retrieveLayoutInformation(element, fr.inria.papyrus.uml4tst.emftext.alf.resource.alf.grammar.AlfGrammarInformationProvider.ALF_0_0_0_0, resolved, true);
                            copyLocalizationInfos((org.antlr.runtime3_3_0.CommonToken) a0, element);
                        }
                    }
                }
                if (state.backtracking == 0) {
                    addExpectedElement(fr.inria.papyrus.uml4tst.emftext.alf.resource.alf.grammar.AlfFollowSetProvider.TERMINAL_2, 1, fr.inria.papyrus.uml4tst.emftext.alf.resource.alf.grammar.AlfFollowSetProvider.FEATURE_0);
                    addExpectedElement(fr.inria.papyrus.uml4tst.emftext.alf.resource.alf.grammar.AlfFollowSetProvider.TERMINAL_3, 1, fr.inria.papyrus.uml4tst.emftext.alf.resource.alf.grammar.AlfFollowSetProvider.FEATURE_1);
                }
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
        } finally {
            if (state.backtracking > 0) {
                memoize(input, 2, parse_fr_inria_papyrus_uml4tst_emftext_alf_Name_StartIndex);
            }
        }
        return element;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,36934.java,139,193
default,85123.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        String mergeCfg = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'm':
                    mergeCfg = g.getOptarg();
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            if (mergeCfg != null) {
                mergeCfg(cfg, mergeCfg);
            }
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (Exception e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114488.java,139,193
default,99581.java,133,177
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        String mergeCfg = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'm':
                    mergeCfg = g.getOptarg();
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            if (mergeCfg != null) {
                mergeCfg(cfg, mergeCfg);
            }
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (Exception e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88095.java,135,182
default,18466.java,135,189
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        String mergeCfg = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'm':
                    mergeCfg = g.getOptarg();
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            if (mergeCfg != null) {
                mergeCfg(cfg, mergeCfg);
            }
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (Exception e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45048.java,139,193
default,33571.java,133,177
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        String mergeCfg = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'm':
                    mergeCfg = g.getOptarg();
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            if (mergeCfg != null) {
                mergeCfg(cfg, mergeCfg);
            }
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (Exception e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1933206.java,493,546
selected,1168103.java,385,431
----------------------------------------
    public Symbol debug_parse() throws java.lang.Exception {
        int act;
        Symbol lhs_sym = null;
        short handle_size, lhs_sym_num;
        production_tab = production_table();
        action_tab = action_table();
        reduce_tab = reduce_table();
        debug_message("# Initializing parser");
        init_actions();
        user_init();
        cur_token = scan();
        debug_message("# Current Symbol is #" + cur_token.sym);
        stack.removeAllElements();
        stack.push(new Symbol(0, start_state()));
        tos = 0;
        for (_done_parsing = false; !_done_parsing; ) {
            if (cur_token.used_by_parser) throw new Error("Symbol recycling detected (fix your scanner).");
            act = get_action(((Symbol) stack.peek()).parse_state, cur_token.sym);
            if (act > 0) {
                cur_token.parse_state = act - 1;
                cur_token.used_by_parser = true;
                debug_shift(cur_token);
                stack.push(cur_token);
                tos++;
                cur_token = scan();
                debug_message("# Current token is " + cur_token);
            } else if (act < 0) {
                lhs_sym = do_action((-act) - 1, this, stack, tos);
                lhs_sym_num = production_tab[(-act) - 1][0];
                handle_size = production_tab[(-act) - 1][1];
                debug_reduce((-act) - 1, lhs_sym_num, handle_size);
                for (int i = 0; i < handle_size; i++) {
                    stack.pop();
                    tos--;
                }
                act = get_reduce(((Symbol) stack.peek()).parse_state, lhs_sym_num);
                debug_message("# Reduce rule: top state " + ((Symbol) stack.peek()).parse_state + ", lhs sym " + lhs_sym_num + " -> state " + act);
                lhs_sym.parse_state = act;
                lhs_sym.used_by_parser = true;
                stack.push(lhs_sym);
                tos++;
                debug_message("# Goto state #" + act);
            } else if (act == 0) {
                syntax_error(cur_token);
                if (!error_recovery(true)) {
                    unrecovered_syntax_error(cur_token);
                    done_parsing();
                } else {
                    lhs_sym = (Symbol) stack.peek();
                }
            }
        }
        return lhs_sym;
    }
----------------------------------------
    public Symbol parse() throws java.lang.Exception {
        int act;
        Symbol lhs_sym = null;
        short handle_size, lhs_sym_num;
        production_tab = production_table();
        action_tab = action_table();
        reduce_tab = reduce_table();
        init_actions();
        user_init();
        cur_token = scan();
        stack.removeAllElements();
        stack.push(new Symbol(0, start_state()));
        tos = 0;
        for (_done_parsing = false; !_done_parsing; ) {
            if (cur_token.used_by_parser) throw new Error("Symbol recycling detected (fix your scanner).");
            act = get_action(((Symbol) stack.peek()).parse_state, cur_token.sym);
            if (act > 0) {
                cur_token.parse_state = act - 1;
                cur_token.used_by_parser = true;
                stack.push(cur_token);
                tos++;
                cur_token = scan();
            } else if (act < 0) {
                lhs_sym = do_action((-act) - 1, this, stack, tos);
                lhs_sym_num = production_tab[(-act) - 1][0];
                handle_size = production_tab[(-act) - 1][1];
                for (int i = 0; i < handle_size; i++) {
                    stack.pop();
                    tos--;
                }
                act = get_reduce(((Symbol) stack.peek()).parse_state, lhs_sym_num);
                lhs_sym.parse_state = act;
                lhs_sym.used_by_parser = true;
                stack.push(lhs_sym);
                tos++;
            } else if (act == 0) {
                syntax_error(cur_token);
                if (!error_recovery(false)) {
                    unrecovered_syntax_error(cur_token);
                    done_parsing();
                } else {
                    lhs_sym = (Symbol) stack.peek();
                }
            }
        }
        return lhs_sym;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,2286.java,142,195
default,46776.java,142,195
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("DcmGen", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmGen.class.getResource("dcmgen.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'r':
                    cfg.put("set-random", "true");
                    break;
                case 'c':
                    cfg.put("set-complete", "true");
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmGen DcmGen = new DcmGen(cfg, new DcmURL(args[optind]), argc);
            DcmGen.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("DcmGen", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmGen.class.getResource("dcmgen.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'r':
                    cfg.put("set-random", "true");
                    break;
                case 'c':
                    cfg.put("set-complete", "true");
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmGen DcmGen = new DcmGen(cfg, new DcmURL(args[optind]), argc);
            DcmGen.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33310.java,142,195
default,79290.java,133,177
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("DcmGen", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmGen.class.getResource("dcmgen.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'r':
                    cfg.put("set-random", "true");
                    break;
                case 'c':
                    cfg.put("set-complete", "true");
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmGen DcmGen = new DcmGen(cfg, new DcmURL(args[optind]), argc);
            DcmGen.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,92452.java,205,257
default,15697.java,318,370
----------------------------------------
    private byte[] showDelMatchList(HTTPurl urlData, HashMap<String, String> headers) throws Exception {
        int index = -1;
        try {
            index = Integer.parseInt(urlData.getParameter("index"));
        } catch (Exception e) {
        }
        EpgMatch item = (EpgMatch) store.getEpgMatchList().get(index);
        if (item == null) {
            String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass() + "\n\n";
            return out.getBytes();
        }
        String start = urlData.getParameter("start");
        if (start == null || start.length() == 0) start = "0";
        String show = urlData.getParameter("show");
        if (show == null || show.length() == 0) show = "10";
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        DOMImplementation di = db.getDOMImplementation();
        Document doc = di.createDocument("", "buttons", null);
        Element root = doc.getDocumentElement();
        root.setAttribute("start", start);
        root.setAttribute("show", show);
        root.setAttribute("back", "/servlet/" + urlData.getServletClass() + "?action=08&index=" + index);
        root.setAttribute("title", "Select a Match List to Delete it");
        Element button = null;
        Element elm = null;
        Text text = null;
        button = doc.createElement("mainurl");
        text = doc.createTextNode("/servlet/" + urlData.getServletClass() + "?action=10&index=" + index + "&");
        button.appendChild(text);
        root.appendChild(button);
        String[] keys = (String[]) item.getMatchListNames().toArray(new String[0]);
        Arrays.sort(keys, String.CASE_INSENSITIVE_ORDER);
        int total = 0;
        for (int x = 0; x < keys.length; x++) {
            String action = "/servlet/KBAutoAddRes?action=11&index=" + index + "&name=" + URLEncoder.encode(keys[x], "UTF-8");
            button = doc.createElement("button");
            button.setAttribute("name", keys[x]);
            elm = doc.createElement("url");
            text = doc.createTextNode(action);
            elm.appendChild(text);
            button.appendChild(elm);
            elm = doc.createElement("confirm");
            text = doc.createTextNode("true");
            elm.appendChild(text);
            button.appendChild(elm);
            root.appendChild(button);
            total++;
        }
        root.setAttribute("total", new Integer(total).toString());
        XSL transformer = new XSL(doc, "kb-list.xsl", urlData, headers);
        return transformer.doTransform();
    }
----------------------------------------
    private byte[] showMatchListMenu(HTTPurl urlData, HashMap<String, String> headers) throws Exception {
        int index = -1;
        try {
            index = Integer.parseInt(urlData.getParameter("index"));
        } catch (Exception e) {
        }
        EpgMatch item = (EpgMatch) store.getEpgMatchList().get(index);
        if (item == null) {
            String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass() + "\n\n";
            return out.getBytes();
        }
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        DOMImplementation di = db.getDOMImplementation();
        Document doc = di.createDocument("", "buttons", null);
        Element root = doc.getDocumentElement();
        root.setAttribute("back", "/servlet/" + urlData.getServletClass() + "?action=02&index=" + index);
        root.setAttribute("title", "Auto-Add Match List Menu");
        Element button = null;
        Element elm = null;
        Text text = null;
        String actionURL = "";
        button = doc.createElement("button");
        button.setAttribute("name", "Back");
        elm = doc.createElement("url");
        actionURL = "/servlet/" + urlData.getServletClass() + "?action=02&index=" + index;
        text = doc.createTextNode(actionURL);
        elm.appendChild(text);
        button.appendChild(elm);
        root.appendChild(button);
        if (item.getMatchListNames().size() > 0) {
            button = doc.createElement("button");
            button.setAttribute("name", "Show Current");
            elm = doc.createElement("url");
            actionURL = "/servlet/" + urlData.getServletClass() + "?action=10&index=" + index;
            text = doc.createTextNode(actionURL);
            elm.appendChild(text);
            button.appendChild(elm);
            root.appendChild(button);
        }
        if (store.getMatchLists().size() > 0) {
            button = doc.createElement("button");
            button.setAttribute("name", "Add");
            elm = doc.createElement("url");
            actionURL = "/servlet/" + urlData.getServletClass() + "?action=09&index=" + index;
            text = doc.createTextNode(actionURL);
            elm.appendChild(text);
            button.appendChild(elm);
            root.appendChild(button);
        }
        XSL transformer = new XSL(doc, "kb-buttons.xsl", urlData, headers);
        return transformer.doTransform();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,130721.java,290,339
default,66239.java,294,341
----------------------------------------
    Message generateReply(Message query, byte[] in, Socket s) {
        boolean badversion;
        int maxLength;
        boolean sigonly;
        SetResponse sr;
        int flags = 0;
        if (query.getHeader().getOpcode() != Opcode.QUERY) return errorMessage(query, Rcode.NOTIMPL);
        Record queryRecord = query.getQuestion();
        TSIGRecord queryTSIG = query.getTSIG();
        TSIG tsig = null;
        if (queryTSIG != null) {
            tsig = findTSIG(queryTSIG.getName());
            if (tsig.verify(query, in, null) != Rcode.NOERROR) return formerrMessage(in);
        }
        OPTRecord queryOPT = query.getOPT();
        if (queryOPT != null && queryOPT.getVersion() > 0) badversion = true;
        if (s != null) maxLength = 65535; else if (queryOPT != null) maxLength = queryOPT.getPayloadSize(); else maxLength = 512;
        if (queryOPT != null && (queryOPT.getFlags() & Flags.DO) != 0) flags = FLAG_DNSSECOK;
        Message response = new Message();
        response.getHeader().setID(query.getHeader().getID());
        response.getHeader().setFlag(Flags.QR);
        if (query.getHeader().getFlag(Flags.RD)) ;
        response.getHeader().setFlag(Flags.RD);
        response.addRecord(queryRecord, Section.QUESTION);
        Name name = queryRecord.getName();
        short type = queryRecord.getType();
        short dclass = queryRecord.getDClass();
        if (type == Type.AXFR && s != null) return doAXFR(name, query, s);
        if (!Type.isRR(type) && type != Type.ANY) return errorMessage(query, Rcode.NOTIMPL);
        byte rcode = addAnswer(response, name, type, dclass, 0, flags);
        if (rcode != Rcode.NOERROR && rcode != Rcode.NXDOMAIN) return errorMessage(query, rcode);
        addAdditional(response, flags);
        if (queryTSIG != null) {
            try {
                if (tsig != null) tsig.apply(response, queryTSIG);
            } catch (IOException e) {
            }
        }
        try {
            response.freeze();
            byte[] out = response.toWire();
            if (out.length > maxLength) {
                response.thaw();
                truncate(response, out.length, maxLength);
                if (tsig != null) tsig.apply(response, queryTSIG);
            }
        } catch (IOException e) {
        }
        return response;
    }
----------------------------------------
    Message generateReply(Message query, byte[] in, Socket s) {
        boolean badversion;
        int maxLength;
        boolean sigonly;
        SetResponse sr;
        if (query.getHeader().getOpcode() != Opcode.QUERY) return errorMessage(query, Rcode.NOTIMPL);
        Record queryRecord = query.getQuestion();
        TSIGRecord queryTSIG = query.getTSIG();
        TSIG tsig = null;
        if (queryTSIG != null) {
            tsig = findTSIG(queryTSIG.getName());
            if (!tsig.verify(query, in, null)) return formerrMessage(in);
        }
        OPTRecord queryOPT = query.getOPT();
        if (queryOPT != null && queryOPT.getVersion() > 0) badversion = true;
        if (s != null) maxLength = 65535; else if (queryOPT != null) maxLength = queryOPT.getPayloadSize(); else maxLength = 512;
        Message response = new Message();
        response.getHeader().setID(query.getHeader().getID());
        response.getHeader().setFlag(Flags.QR);
        if (query.getHeader().getFlag(Flags.RD)) ;
        response.getHeader().setFlag(Flags.RD);
        response.addRecord(queryRecord, Section.QUESTION);
        Name name = queryRecord.getName();
        short type = queryRecord.getType();
        short dclass = queryRecord.getDClass();
        if (type == Type.AXFR && s != null) return doAXFR(name, query, s);
        if (!Type.isRR(type) && type != Type.ANY) return errorMessage(query, Rcode.NOTIMPL);
        byte rcode = addAnswer(response, name, type, dclass, 0);
        if (rcode != Rcode.NOERROR && rcode != Rcode.NXDOMAIN) return errorMessage(query, rcode);
        addAdditional(response);
        if (queryTSIG != null) {
            try {
                if (tsig != null) tsig.apply(response, queryTSIG);
            } catch (IOException e) {
            }
        }
        try {
            response.freeze();
            byte[] out = response.toWire();
            if (out.length > maxLength) {
                response.thaw();
                truncate(response, out.length, maxLength);
                if (tsig != null) tsig.apply(response, queryTSIG);
            }
        } catch (IOException e) {
        }
        return response;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,93071.java,1194,1236
selected,2049331.java,318,368
----------------------------------------
    private static void multiclass_probability(int k, double[][] r, double[] p) {
        int t, j;
        int iter = 0, max_iter = Math.max(100, k);
        double[][] Q = new double[k][k];
        double[] Qp = new double[k];
        double pQp, eps = 0.005 / k;
        for (t = 0; t < k; t++) {
            p[t] = 1.0 / k;
            Q[t][t] = 0;
            for (j = 0; j < t; j++) {
                Q[t][t] += r[j][t] * r[j][t];
                Q[t][j] = Q[j][t];
            }
            for (j = t + 1; j < k; j++) {
                Q[t][t] += r[j][t] * r[j][t];
                Q[t][j] = -r[j][t] * r[t][j];
            }
        }
        for (iter = 0; iter < max_iter; iter++) {
            pQp = 0;
            for (t = 0; t < k; t++) {
                Qp[t] = 0;
                for (j = 0; j < k; j++) Qp[t] += Q[t][j] * p[j];
                pQp += p[t] * Qp[t];
            }
            double max_error = 0;
            for (t = 0; t < k; t++) {
                double error = Math.abs(Qp[t] - pQp);
                if (error > max_error) max_error = error;
            }
            if (max_error < eps) break;
            for (t = 0; t < k; t++) {
                double diff = (-Qp[t] + pQp) / Q[t][t];
                p[t] += diff;
                pQp = (pQp + diff * (diff * Q[t][t] + 2 * Qp[t])) / (1 + diff) / (1 + diff);
                for (j = 0; j < k; j++) {
                    Qp[j] = (Qp[j] + diff * Q[t][j]) / (1 + diff);
                    p[j] /= (1 + diff);
                }
            }
        }
        if (iter >= max_iter) System.err.print("Exceeds max_iter in multiclass_prob\n");
    }
----------------------------------------
    private static void multiclass_probability(int k, double[][] r, double[] p) {
        int t, j;
        int iter = 0, max_iter = Math.max(100, k);
        double[][] Q = new double[k][k];
        double[] Qp = new double[k];
        double pQp, eps = 0.005 / k;
        for (t = 0; t < k; t++) {
            p[t] = 1.0 / k;
            Q[t][t] = 0;
            for (j = 0; j < t; j++) {
                Q[t][t] += r[j][t] * r[j][t];
                Q[t][j] = Q[j][t];
            }
            for (j = t + 1; j < k; j++) {
                Q[t][t] += r[j][t] * r[j][t];
                Q[t][j] = -r[j][t] * r[t][j];
            }
        }
        for (iter = 0; iter < max_iter; iter++) {
            pQp = 0;
            for (t = 0; t < k; t++) {
                Qp[t] = 0;
                for (j = 0; j < k; j++) {
                    Qp[t] += Q[t][j] * p[j];
                }
                pQp += p[t] * Qp[t];
            }
            double max_error = 0;
            for (t = 0; t < k; t++) {
                double error = Math.abs(Qp[t] - pQp);
                if (error > max_error) {
                    max_error = error;
                }
            }
            if (max_error < eps) {
                break;
            }
            for (t = 0; t < k; t++) {
                double diff = (-Qp[t] + pQp) / Q[t][t];
                p[t] += diff;
                pQp = (pQp + diff * (diff * Q[t][t] + 2 * Qp[t])) / (1 + diff) / (1 + diff);
                for (j = 0; j < k; j++) {
                    Qp[j] = (Qp[j] + diff * Q[t][j]) / (1 + diff);
                    p[j] /= (1 + diff);
                }
            }
        }
        if (iter >= max_iter) {
            log(0, "Exceeds max_iter in multiclass_prob\n");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,119321.java,375,424
default,24183.java,375,424
----------------------------------------
    private static boolean importFromJar(Project proj, String path, boolean overWrite, String srcFolder) {
        boolean hasErrors = false;
        FileInputStream fis;
        try {
            FileOutputStream fo;
            PrintStream ps;
            fis = new FileInputStream(path);
            JarInputStream jis = new JarInputStream(new BufferedInputStream(fis));
            JarEntry entry;
            while ((entry = (JarEntry) jis.getNextEntry()) != null) {
                if (!entry.getName().equals("config.prj") && proj.getIncludes().containsKey(entry.getName())) {
                    ProjectInclude include = proj.getIncludes().get(entry.getName()).clone();
                    include.path = include.path.replace("$SRC$", srcFolder);
                    File refFile = new File(include.path);
                    int result = checkExisting(include);
                    if (result == -1) {
                        return false;
                    } else if (result == 0) {
                        continue;
                    } else {
                        try {
                            System.out.println("Extracting: " + entry + " to " + include.path);
                            File dirs = refFile.getParentFile();
                            if (!dirs.exists()) dirs.mkdirs();
                            BufferedReader br = new BufferedReader(new InputStreamReader(jis));
                            fo = new FileOutputStream(refFile);
                            ps = new PrintStream(fo);
                            String line = "";
                            while ((line = br.readLine()) != null) {
                                if (!line.equals("null")) ps.println(line);
                            }
                            ps.close();
                            fo.close();
                        } catch (Exception e) {
                            hasErrors = true;
                            System.err.println("Read error: " + e.getMessage());
                        }
                    }
                }
            }
            jis.close();
            fis.close();
            return hasErrors;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return true;
    }
----------------------------------------
    private static boolean importFromJar(Project proj, String path, boolean overWrite, String srcFolder) {
        boolean hasErrors = false;
        FileInputStream fis;
        try {
            FileOutputStream fo;
            PrintStream ps;
            fis = new FileInputStream(path);
            JarInputStream jis = new JarInputStream(new BufferedInputStream(fis));
            JarEntry entry;
            while ((entry = (JarEntry) jis.getNextEntry()) != null) {
                if (!entry.getName().equals("config.prj") && proj.getIncludes().containsKey(entry.getName())) {
                    ProjectInclude include = proj.getIncludes().get(entry.getName()).clone();
                    include.path = include.path.replace("$SRC$", srcFolder);
                    File refFile = new File(include.path);
                    int result = checkExisting(include);
                    if (result == -1) {
                        return false;
                    } else if (result == 0) {
                        continue;
                    } else {
                        try {
                            System.out.println("Extracting: " + entry + " to " + include.path);
                            File dirs = refFile.getParentFile();
                            if (!dirs.exists()) dirs.mkdirs();
                            BufferedReader br = new BufferedReader(new InputStreamReader(jis));
                            fo = new FileOutputStream(refFile);
                            ps = new PrintStream(fo);
                            String line = "";
                            while ((line = br.readLine()) != null) {
                                if (!line.equals("null")) ps.println(line);
                            }
                            ps.close();
                            fo.close();
                        } catch (Exception e) {
                            hasErrors = true;
                            System.err.println("Read error: " + e.getMessage());
                        }
                    }
                }
            }
            jis.close();
            fis.close();
            return hasErrors;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,8528.java,107,143
default,2909.java,109,153
----------------------------------------
    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
            return;
        }
        int argc = args.length;
        if (args[0].equals("-debug")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println("in:" + args[0] + "\nout:" + args[1]);
        try {
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf("=");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + " = " + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
----------------------------------------
    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
            return;
        }
        int argc = args.length;
        if (args[0].equals("-debug")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf("=") < 0) args[argc - 1] = args[argc - 1] + " " + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println("in:" + args[0] + "\nout:" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = "";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf("=");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + " = " + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,30906.java,311,358
default,89288.java,311,358
----------------------------------------
    public void ReadSeriesFile() {
        xmlSeriesInfo = new ArrayList<XMLShowInfo>();
        try {
            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
            Document doc = docBuilder.parse(new File("JavaNZB.series"));
            doc.getDocumentElement().normalize();
            NodeList listOfShowInfo = doc.getElementsByTagName("Show");
            ArrayList<String> elementNames = new ArrayList<String>();
            elementNames.add("Name");
            elementNames.add("SearchBy");
            elementNames.add("Episode");
            elementNames.add("Format");
            elementNames.add("Language");
            elementNames.add("Next");
            elementNames.add("Season");
            for (int s = 0; s < listOfShowInfo.getLength(); s++) {
                Node showNode = listOfShowInfo.item(s);
                XMLShowInfo xmlShowInfo = new XMLShowInfo();
                if (showNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element firstPersonElement = (Element) showNode;
                    for (String CurElementName : elementNames) {
                        NodeList NameList = firstPersonElement.getElementsByTagName(CurElementName);
                        Element NameElement = (Element) NameList.item(0);
                        NodeList textFNList = NameElement.getChildNodes();
                        if (textFNList.getLength() > 0) {
                            if (CurElementName.equals("Name")) xmlShowInfo.showName = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("SearchBy")) xmlShowInfo.searchBy = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Episode")) xmlShowInfo.episode = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Format")) xmlShowInfo.format = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Language")) xmlShowInfo.language = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Next")) xmlShowInfo.next = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Season")) xmlShowInfo.season = ((Node) textFNList.item(0)).getNodeValue().trim();
                        }
                    }
                    xmlSeriesInfo.add(xmlShowInfo);
                }
            }
        } catch (SAXParseException err) {
            System.out.println("** Parsing error" + ", line " + err.getLineNumber() + ", uri " + err.getSystemId());
            System.out.println(" " + err.getMessage());
        } catch (SAXException e) {
            Exception x = e.getException();
            ((x == null) ? e : x).printStackTrace();
        } catch (Throwable t) {
            t.printStackTrace();
        }
    }
----------------------------------------
    public void ReadSeriesFile() {
        xmlSeriesInfo = new ArrayList<XMLShowInfo>();
        try {
            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
            Document doc = docBuilder.parse(new File("JavaNZB.series"));
            doc.getDocumentElement().normalize();
            NodeList listOfShowInfo = doc.getElementsByTagName("Show");
            ArrayList<String> elementNames = new ArrayList<String>();
            elementNames.add("Name");
            elementNames.add("SearchBy");
            elementNames.add("Episode");
            elementNames.add("Format");
            elementNames.add("Language");
            elementNames.add("Next");
            elementNames.add("Season");
            for (int s = 0; s < listOfShowInfo.getLength(); s++) {
                Node showNode = listOfShowInfo.item(s);
                XMLShowInfo xmlShowInfo = new XMLShowInfo();
                if (showNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element firstPersonElement = (Element) showNode;
                    for (String CurElementName : elementNames) {
                        NodeList NameList = firstPersonElement.getElementsByTagName(CurElementName);
                        Element NameElement = (Element) NameList.item(0);
                        NodeList textFNList = NameElement.getChildNodes();
                        if (textFNList.getLength() > 0) {
                            if (CurElementName.equals("Name")) xmlShowInfo.showName = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("SearchBy")) xmlShowInfo.searchBy = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Episode")) xmlShowInfo.episode = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Format")) xmlShowInfo.format = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Language")) xmlShowInfo.language = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Next")) xmlShowInfo.next = ((Node) textFNList.item(0)).getNodeValue().trim();
                            if (CurElementName.equals("Season")) xmlShowInfo.season = ((Node) textFNList.item(0)).getNodeValue().trim();
                        }
                    }
                    xmlSeriesInfo.add(xmlShowInfo);
                }
            }
        } catch (SAXParseException err) {
            System.out.println("** Parsing error" + ", line " + err.getLineNumber() + ", uri " + err.getSystemId());
            System.out.println(" " + err.getMessage());
        } catch (SAXException e) {
            Exception x = e.getException();
            ((x == null) ? e : x).printStackTrace();
        } catch (Throwable t) {
            t.printStackTrace();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,31047.java,291,338
default,126294.java,291,338
----------------------------------------
    private void displayHeaders(MailUserData mud, HttpServletRequest req, ServletOutputStream out) throws IOException {
        SimpleDateFormat df = new SimpleDateFormat("EE M/d/yy");
        out.println("<html>");
        out.println("<HEAD><TITLE>JavaMail Servlet</TITLE></HEAD>");
        out.println("<BODY bgcolor=\"#ccccff\"><hr>");
        out.print("<center><font face=\"Arial,Helvetica\" font size=\"+3\">");
        out.println("<b>Folder " + mud.getStore().getURLName() + "/INBOX</b></font></center><p>");
        out.println("<font face=\"Arial,Helvetica\" font size=\"+3\"><b>");
        out.println("<a href=\"" + HttpUtils.getRequestURL(req) + "?logout=true\">Logout</a>");
        out.println("<a href=\"" + HttpUtils.getRequestURL(req) + "?compose=true\" target=\"compose\">Compose</a>");
        out.println("</b></font>");
        out.println("<hr>");
        out.print("<table cellpadding=1 cellspacing=1 ");
        out.println("width=\"100%\" border=1>");
        out.println("<tr><td width=\"25%\" bgcolor=\"ffffcc\">");
        out.println("<font face=\"Arial,Helvetica\" font size=\"+1\">");
        out.println("<b>Sender</b></font></td>");
        out.println("<td width=\"15%\" bgcolor=\"ffffcc\">");
        out.println("<font face=\"Arial,Helvetica\" font size=\"+1\">");
        out.println("<b>Date</b></font></td>");
        out.println("<td bgcolor=\"ffffcc\">");
        out.println("<font face=\"Arial,Helvetica\" font size=\"+1\">");
        out.println("<b>Subject</b></font></td></tr>");
        try {
            Folder f = mud.getFolder();
            int msgCount = f.getMessageCount();
            Message m = null;
            for (int i = 1; i <= msgCount; i++) {
                m = f.getMessage(i);
                if (m.isSet(Flags.Flag.DELETED)) continue;
                out.println("<tr valigh=middle>");
                out.print("<td width=\"25%\" bgcolor=\"ffffff\">");
                out.println("<font face=\"Arial,Helvetica\">" + ((m.getFrom() != null) ? m.getFrom()[0].toString() : "") + "</font></td>");
                out.print("<td nowrap width=\"15%\" bgcolor=\"ffffff\">");
                out.println("<font face=\"Arial,Helvetica\">" + df.format((m.getSentDate() != null) ? m.getSentDate() : m.getReceivedDate()) + "</font></td>");
                out.print("<td bgcolor=\"ffffff\">");
                out.println("<font face=\"Arial,Helvetica\">" + "<a href=\"" + HttpUtils.getRequestURL(req) + "?message=" + i + "\">" + ((m.getSubject() != null) ? m.getSubject() : "<i>No Subject</i>") + "</a>" + "</font></td>");
                out.println("</tr>");
            }
        } catch (MessagingException mex) {
            out.println("<tr><td>" + mex.toString() + "</td></tr>");
            mex.printStackTrace();
        }
        out.println("</table>");
        out.println("</BODY></html>");
        out.flush();
        out.close();
    }
----------------------------------------
    private void displayHeaders(MailUserData mud, HttpServletRequest req, ServletOutputStream out) throws IOException {
        SimpleDateFormat df = new SimpleDateFormat("EE M/d/yy");
        out.println("<html>");
        out.println("<HEAD><TITLE>JavaMail Servlet</TITLE></HEAD>");
        out.println("<BODY bgcolor=\"#ccccff\"><hr>");
        out.print("<center><font face=\"Arial,Helvetica\" font size=\"+3\">");
        out.println("<b>Folder " + mud.getStore().getURLName() + "/INBOX</b></font></center><p>");
        out.println("<font face=\"Arial,Helvetica\" font size=\"+3\"><b>");
        out.println("<a href=\"" + HttpUtils.getRequestURL(req) + "?logout=true\">Logout</a>");
        out.println("<a href=\"" + HttpUtils.getRequestURL(req) + "?compose=true\" target=\"compose\">Compose</a>");
        out.println("</b></font>");
        out.println("<hr>");
        out.print("<table cellpadding=1 cellspacing=1 ");
        out.println("width=\"100%\" border=1>");
        out.println("<tr><td width=\"25%\" bgcolor=\"ffffcc\">");
        out.println("<font face=\"Arial,Helvetica\" font size=\"+1\">");
        out.println("<b>Sender</b></font></td>");
        out.println("<td width=\"15%\" bgcolor=\"ffffcc\">");
        out.println("<font face=\"Arial,Helvetica\" font size=\"+1\">");
        out.println("<b>Date</b></font></td>");
        out.println("<td bgcolor=\"ffffcc\">");
        out.println("<font face=\"Arial,Helvetica\" font size=\"+1\">");
        out.println("<b>Subject</b></font></td></tr>");
        try {
            Folder f = mud.getFolder();
            int msgCount = f.getMessageCount();
            Message m = null;
            for (int i = 1; i <= msgCount; i++) {
                m = f.getMessage(i);
                if (m.isSet(Flags.Flag.DELETED)) continue;
                out.println("<tr valigh=middle>");
                out.print("<td width=\"25%\" bgcolor=\"ffffff\">");
                out.println("<font face=\"Arial,Helvetica\">" + ((m.getFrom() != null) ? m.getFrom()[0].toString() : "") + "</font></td>");
                out.print("<td nowrap width=\"15%\" bgcolor=\"ffffff\">");
                out.println("<font face=\"Arial,Helvetica\">" + df.format((m.getSentDate() != null) ? m.getSentDate() : m.getReceivedDate()) + "</font></td>");
                out.print("<td bgcolor=\"ffffff\">");
                out.println("<font face=\"Arial,Helvetica\">" + "<a href=\"" + HttpUtils.getRequestURL(req) + "?message=" + i + "\">" + ((m.getSubject() != null) ? m.getSubject() : "<i>No Subject</i>") + "</a>" + "</font></td>");
                out.println("</tr>");
            }
        } catch (MessagingException mex) {
            out.println("<tr><td>" + mex.toString() + "</td></tr>");
            mex.printStackTrace();
        }
        out.println("</table>");
        out.println("</BODY></html>");
        out.flush();
        out.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88095.java,135,182
default,53210.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,2624.java,367,414
default,50941.java,367,414
----------------------------------------
    private void displayDiffResults() throws IOException {
        File outFile = File.createTempFile("diff", ".htm");
        outFile.deleteOnExit();
        FileOutputStream outStream = new FileOutputStream(outFile);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));
        out.write("<html><head><title>LOC Differences</title>\n" + SCRIPT + "</head>\n" + "<body bgcolor='#ffffff'>\n" + "<div onMouseOver=\"window.defaultStatus='Metrics'\">\n");
        if (addedTable.length() > 0) {
            out.write("<table border><tr><th>Files Added:</th>" + "<th>Add</th><th>Type</th></tr>");
            out.write(addedTable.toString());
            out.write("</table><br><br>");
        }
        if (modifiedTable.length() > 0) {
            out.write("<table border><tr><th>Files Modified:</th>" + "<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>" + "<th>Total</th><th>Type</th></tr>");
            out.write(modifiedTable.toString());
            out.write("</table><br><br>");
        }
        if (deletedTable.length() > 0) {
            out.write("<table border><tr><th>Files Deleted:</th>" + "<th>Del</th><th>Type</th></tr>");
            out.write(deletedTable.toString());
            out.write("</table><br><br>");
        }
        out.write("<table name=METRICS BORDER>\n");
        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {
            out.write("<tr><td>Base:&nbsp;</td><td>");
            out.write(Long.toString(base));
            out.write("</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>");
            out.write(Long.toString(deleted));
            out.write("</td></tr>\n<tr><td>Modified:&nbsp;</td><td>");
            out.write(Long.toString(modified));
            out.write("</td></tr>\n<tr><td>Added:&nbsp;</td><td>");
            out.write(Long.toString(added));
            out.write("</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>");
            out.write(Long.toString(added + modified));
            out.write("</td></tr>\n");
        }
        out.write("<tr><td>Total:&nbsp;</td><td>");
        out.write(Long.toString(total));
        out.write("</td></tr>\n</table></div>");
        redlinesOut.close();
        out.flush();
        InputStream redlines = new FileInputStream(redlinesTempFile);
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);
        outStream.write("</BODY></HTML>".getBytes());
        outStream.close();
        Browser.launch(outFile.toURL().toString());
    }
----------------------------------------
    private void displayDiffResults() throws IOException {
        File outFile = File.createTempFile("diff", ".htm");
        outFile.deleteOnExit();
        FileOutputStream outStream = new FileOutputStream(outFile);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));
        out.write("<html><head><title>LOC Differences</title>\n" + SCRIPT + "</head>\n" + "<body bgcolor='#ffffff'>\n" + "<div onMouseOver=\"window.defaultStatus='Metrics'\">\n");
        if (addedTable.length() > 0) {
            out.write("<table border><tr><th>Files Added:</th>" + "<th>Add</th><th>Type</th></tr>");
            out.write(addedTable.toString());
            out.write("</table><br><br>");
        }
        if (modifiedTable.length() > 0) {
            out.write("<table border><tr><th>Files Modified:</th>" + "<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>" + "<th>Total</th><th>Type</th></tr>");
            out.write(modifiedTable.toString());
            out.write("</table><br><br>");
        }
        if (deletedTable.length() > 0) {
            out.write("<table border><tr><th>Files Deleted:</th>" + "<th>Del</th><th>Type</th></tr>");
            out.write(deletedTable.toString());
            out.write("</table><br><br>");
        }
        out.write("<table name=METRICS BORDER>\n");
        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {
            out.write("<tr><td>Base:&nbsp;</td><td>");
            out.write(Long.toString(base));
            out.write("</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>");
            out.write(Long.toString(deleted));
            out.write("</td></tr>\n<tr><td>Modified:&nbsp;</td><td>");
            out.write(Long.toString(modified));
            out.write("</td></tr>\n<tr><td>Added:&nbsp;</td><td>");
            out.write(Long.toString(added));
            out.write("</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>");
            out.write(Long.toString(added + modified));
            out.write("</td></tr>\n");
        }
        out.write("<tr><td>Total:&nbsp;</td><td>");
        out.write(Long.toString(total));
        out.write("</td></tr>\n</table></div>");
        redlinesOut.close();
        out.flush();
        InputStream redlines = new FileInputStream(redlinesTempFile);
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);
        outStream.write("</BODY></HTML>".getBytes());
        outStream.close();
        Browser.launch(outFile.toURL().toString());
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,74245.java,135,182
default,132272.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,71559.java,135,182
default,128156.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126614.java,135,182
default,94357.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,137408.java,135,182
default,79079.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,11974.java,135,182
default,101032.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126614.java,135,182
default,79290.java,133,177
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2120512.java,406,452
selected,1577394.java,419,465
----------------------------------------
    public static int rectCrossingsForCubic(int crossings, double rxmin, double rymin, double rxmax, double rymax, double x0, double y0, double xc0, double yc0, double xc1, double yc1, double x1, double y1, int level) {
        if (y0 >= rymax && yc0 >= rymax && yc1 >= rymax && y1 >= rymax) {
            return crossings;
        }
        if (y0 <= rymin && yc0 <= rymin && yc1 <= rymin && y1 <= rymin) {
            return crossings;
        }
        if (x0 <= rxmin && xc0 <= rxmin && xc1 <= rxmin && x1 <= rxmin) {
            return crossings;
        }
        if (x0 >= rxmax && xc0 >= rxmax && xc1 >= rxmax && x1 >= rxmax) {
            if (y0 < y1) {
                if (y0 <= rymin && y1 > rymin) crossings++;
                if (y0 < rymax && y1 >= rymax) crossings++;
            } else if (y1 < y0) {
                if (y1 <= rymin && y0 > rymin) crossings--;
                if (y1 < rymax && y0 >= rymax) crossings--;
            }
            return crossings;
        }
        if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
            return RECT_INTERSECTS;
        }
        if (level > 52) {
            return rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
        }
        double xmid = (xc0 + xc1) / 2;
        double ymid = (yc0 + yc1) / 2;
        xc0 = (x0 + xc0) / 2;
        yc0 = (y0 + yc0) / 2;
        xc1 = (xc1 + x1) / 2;
        yc1 = (yc1 + y1) / 2;
        double xc0m = (xc0 + xmid) / 2;
        double yc0m = (yc0 + ymid) / 2;
        double xmc1 = (xmid + xc1) / 2;
        double ymc1 = (ymid + yc1) / 2;
        xmid = (xc0m + xmc1) / 2;
        ymid = (yc0m + ymc1) / 2;
        if (Double.isNaN(xmid) || Double.isNaN(ymid)) {
            return 0;
        }
        crossings = rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1);
        if (crossings != RECT_INTERSECTS) {
            crossings = rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1);
        }
        return crossings;
    }
----------------------------------------
    public static int rectCrossingsForCubic(int crossings, double rxmin, double rymin, double rxmax, double rymax, double x0, double y0, double xc0, double yc0, double xc1, double yc1, double x1, double y1, int level) {
        if (y0 >= rymax && yc0 >= rymax && yc1 >= rymax && y1 >= rymax) {
            return crossings;
        }
        if (y0 <= rymin && yc0 <= rymin && yc1 <= rymin && y1 <= rymin) {
            return crossings;
        }
        if (x0 <= rxmin && xc0 <= rxmin && xc1 <= rxmin && x1 <= rxmin) {
            return crossings;
        }
        if (x0 >= rxmax && xc0 >= rxmax && xc1 >= rxmax && x1 >= rxmax) {
            if (y0 < y1) {
                if (y0 <= rymin && y1 > rymin) crossings++;
                if (y0 < rymax && y1 >= rymax) crossings++;
            } else if (y1 < y0) {
                if (y1 <= rymin && y0 > rymin) crossings--;
                if (y1 < rymax && y0 >= rymax) crossings--;
            }
            return crossings;
        }
        if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
            return RECT_INTERSECTS;
        }
        if (level > 52) {
            return rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
        }
        double xmid = (xc0 + xc1) / 2;
        double ymid = (yc0 + yc1) / 2;
        xc0 = (x0 + xc0) / 2;
        yc0 = (y0 + yc0) / 2;
        xc1 = (xc1 + x1) / 2;
        yc1 = (yc1 + y1) / 2;
        double xc0m = (xc0 + xmid) / 2;
        double yc0m = (yc0 + ymid) / 2;
        double xmc1 = (xmid + xc1) / 2;
        double ymc1 = (ymid + yc1) / 2;
        xmid = (xc0m + xmc1) / 2;
        ymid = (yc0m + ymc1) / 2;
        if (Double.isNaN(xmid) || Double.isNaN(ymid)) {
            return 0;
        }
        crossings = rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1);
        if (crossings != RECT_INTERSECTS) {
            crossings = rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1);
        }
        return crossings;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5224.java,450,492
default,43540.java,443,485
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,67537.java,450,492
default,48666.java,450,492
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33310.java,450,492
default,85514.java,443,485
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,91707.java,459,501
default,28899.java,450,492
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,137408.java,443,485
default,74368.java,443,485
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2190287.java,627,669
selected,974838.java,852,897
----------------------------------------
    public static byte[] decode(String s, int options) {
        byte[] bytes;
        try {
            bytes = s.getBytes(PREFERRED_ENCODING);
        } catch (java.io.UnsupportedEncodingException uee) {
            bytes = s.getBytes();
        }
        bytes = decode(bytes, 0, bytes.length, options);
        if (bytes != null && bytes.length >= 4) {
            int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);
            if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {
                java.io.ByteArrayInputStream bais = null;
                java.util.zip.GZIPInputStream gzis = null;
                java.io.ByteArrayOutputStream baos = null;
                byte[] buffer = new byte[2048];
                int length = 0;
                try {
                    baos = new java.io.ByteArrayOutputStream();
                    bais = new java.io.ByteArrayInputStream(bytes);
                    gzis = new java.util.zip.GZIPInputStream(bais);
                    while ((length = gzis.read(buffer)) >= 0) {
                        baos.write(buffer, 0, length);
                    }
                    bytes = baos.toByteArray();
                } catch (java.io.IOException e) {
                } finally {
                    try {
                        baos.close();
                    } catch (Exception e) {
                    }
                    try {
                        gzis.close();
                    } catch (Exception e) {
                    }
                    try {
                        bais.close();
                    } catch (Exception e) {
                    }
                }
            }
        }
        return bytes;
    }
----------------------------------------
    public static byte[] decode(String s, int options) throws java.io.IOException {
        if (s == null) {
            throw new NullPointerException("Input string was null.");
        }
        byte[] bytes;
        try {
            bytes = s.getBytes(PREFERRED_ENCODING);
        } catch (java.io.UnsupportedEncodingException uee) {
            bytes = s.getBytes();
        }
        bytes = decode(bytes, 0, bytes.length, options);
        if (bytes != null && bytes.length >= 4) {
            int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);
            if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {
                java.io.ByteArrayInputStream bais = null;
                java.util.zip.GZIPInputStream gzis = null;
                java.io.ByteArrayOutputStream baos = null;
                byte[] buffer = new byte[2048];
                int length = 0;
                try {
                    baos = new java.io.ByteArrayOutputStream();
                    bais = new java.io.ByteArrayInputStream(bytes);
                    gzis = new java.util.zip.GZIPInputStream(bais);
                    while ((length = gzis.read(buffer)) >= 0) {
                        baos.write(buffer, 0, length);
                    }
                    bytes = baos.toByteArray();
                } catch (java.io.IOException e) {
                } finally {
                    try {
                        baos.close();
                    } catch (Exception e) {
                    }
                    try {
                        gzis.close();
                    } catch (Exception e) {
                    }
                    try {
                        bais.close();
                    } catch (Exception e) {
                    }
                }
            }
        }
        return bytes;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1098324.java,605,647
selected,974838.java,852,897
----------------------------------------
    public static byte[] decode(String s, int options) {
        byte[] bytes;
        try {
            bytes = s.getBytes(PREFERRED_ENCODING);
        } catch (java.io.UnsupportedEncodingException uee) {
            bytes = s.getBytes();
        }
        bytes = decode(bytes, 0, bytes.length, options);
        if (bytes != null && bytes.length >= 4) {
            int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);
            if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {
                java.io.ByteArrayInputStream bais = null;
                java.util.zip.GZIPInputStream gzis = null;
                java.io.ByteArrayOutputStream baos = null;
                byte[] buffer = new byte[2048];
                int length = 0;
                try {
                    baos = new java.io.ByteArrayOutputStream();
                    bais = new java.io.ByteArrayInputStream(bytes);
                    gzis = new java.util.zip.GZIPInputStream(bais);
                    while ((length = gzis.read(buffer)) >= 0) {
                        baos.write(buffer, 0, length);
                    }
                    bytes = baos.toByteArray();
                } catch (java.io.IOException e) {
                } finally {
                    try {
                        baos.close();
                    } catch (Exception e) {
                    }
                    try {
                        gzis.close();
                    } catch (Exception e) {
                    }
                    try {
                        bais.close();
                    } catch (Exception e) {
                    }
                }
            }
        }
        return bytes;
    }
----------------------------------------
    public static byte[] decode(String s, int options) throws java.io.IOException {
        if (s == null) {
            throw new NullPointerException("Input string was null.");
        }
        byte[] bytes;
        try {
            bytes = s.getBytes(PREFERRED_ENCODING);
        } catch (java.io.UnsupportedEncodingException uee) {
            bytes = s.getBytes();
        }
        bytes = decode(bytes, 0, bytes.length, options);
        if (bytes != null && bytes.length >= 4) {
            int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);
            if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {
                java.io.ByteArrayInputStream bais = null;
                java.util.zip.GZIPInputStream gzis = null;
                java.io.ByteArrayOutputStream baos = null;
                byte[] buffer = new byte[2048];
                int length = 0;
                try {
                    baos = new java.io.ByteArrayOutputStream();
                    bais = new java.io.ByteArrayInputStream(bytes);
                    gzis = new java.util.zip.GZIPInputStream(bais);
                    while ((length = gzis.read(buffer)) >= 0) {
                        baos.write(buffer, 0, length);
                    }
                    bytes = baos.toByteArray();
                } catch (java.io.IOException e) {
                } finally {
                    try {
                        baos.close();
                    } catch (Exception e) {
                    }
                    try {
                        gzis.close();
                    } catch (Exception e) {
                    }
                    try {
                        bais.close();
                    } catch (Exception e) {
                    }
                }
            }
        }
        return bytes;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132039.java,443,485
default,28899.java,450,492
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19383.java,450,492
default,97613.java,443,485
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4537.java,450,492
default,112571.java,450,492
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4537.java,450,492
default,118595.java,443,485
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33571.java,437,479
default,36934.java,463,505
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53939.java,543,587
default,20843.java,543,587
----------------------------------------
    private static int pushVarArgToSpillArea(int methodID, boolean skip4Args) {
        int glueFrameSize = NATIVE_TO_JAVA_GLUE_FRAME_SIZE;
        int glueFrameSize = JNI_GLUE_FRAME_SIZE;
        int fp = VM_Magic.getMemoryWord(VM_Magic.getFramePointer() + VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET);
        fp = VM_Magic.getMemoryWord(fp + VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET);
        int gluefp = VM_Magic.getMemoryWord(fp + VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET);
        int varargGPROffset = VARARG_AREA_OFFSET + (skip4Args ? 4 : 0);
        int varargFPROffset = varargGPROffset + 5 * 4;
        int spillAreaLimit = glueFrameSize + AIX_FRAME_HEADER_SIZE + 8 * 4;
        int spillAreaOffset = glueFrameSize + AIX_FRAME_HEADER_SIZE + (skip4Args ? 4 * 4 : 3 * 4);
        int varargAddress = gluefp + spillAreaOffset;
        VM_Method targetMethod = VM_MethodDictionary.getValue(methodID);
        VM_Type[] argTypes = targetMethod.getParameterTypes();
        int argCount = argTypes.length;
        for (int i = 0; i < argCount && spillAreaOffset < spillAreaLimit; i++) {
            int hiword, loword;
            if (argTypes[i].isFloatType() || argTypes[i].isDoubleType()) {
                hiword = VM_Magic.getMemoryWord(gluefp + varargFPROffset);
                varargFPROffset += 4;
                loword = VM_Magic.getMemoryWord(gluefp + varargFPROffset);
                varargFPROffset += 4;
                VM_Magic.setMemoryWord(gluefp + spillAreaOffset, hiword);
                spillAreaOffset += 4;
                VM_Magic.setMemoryWord(gluefp + spillAreaOffset, loword);
                spillAreaOffset += 4;
            } else if (argTypes[i].isLongType()) {
                hiword = VM_Magic.getMemoryWord(gluefp + varargGPROffset);
                varargGPROffset += 4;
                VM_Magic.setMemoryWord(gluefp + spillAreaOffset, hiword);
                spillAreaOffset += 4;
                if (spillAreaOffset < spillAreaLimit) {
                    loword = VM_Magic.getMemoryWord(gluefp + varargGPROffset);
                    varargGPROffset += 4;
                    VM_Magic.setMemoryWord(gluefp + spillAreaOffset, loword);
                    spillAreaOffset += 4;
                }
            } else {
                hiword = VM_Magic.getMemoryWord(gluefp + varargGPROffset);
                varargGPROffset += 4;
                VM_Magic.setMemoryWord(gluefp + spillAreaOffset, hiword);
                spillAreaOffset += 4;
            }
        }
        return varargAddress;
    }
----------------------------------------
    private static int pushVarArgToSpillArea(int methodID, boolean skip4Args) {
        int glueFrameSize = NATIVE_TO_JAVA_GLUE_FRAME_SIZE;
        int glueFrameSize = JNI_GLUE_FRAME_SIZE;
        int fp = VM_Magic.getMemoryWord(VM_Magic.getFramePointer() + VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET);
        fp = VM_Magic.getMemoryWord(fp + VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET);
        int gluefp = VM_Magic.getMemoryWord(fp + VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET);
        int varargGPROffset = VARARG_AREA_OFFSET + (skip4Args ? 4 : 0);
        int varargFPROffset = varargGPROffset + 5 * 4;
        int spillAreaLimit = glueFrameSize + AIX_FRAME_HEADER_SIZE + 8 * 4;
        int spillAreaOffset = glueFrameSize + AIX_FRAME_HEADER_SIZE + (skip4Args ? 4 * 4 : 3 * 4);
        int varargAddress = gluefp + spillAreaOffset;
        VM_Method targetMethod = VM_MethodDictionary.getValue(methodID);
        VM_Type[] argTypes = targetMethod.getParameterTypes();
        int argCount = argTypes.length;
        for (int i = 0; i < argCount && spillAreaOffset < spillAreaLimit; i++) {
            int hiword, loword;
            if (argTypes[i].isFloatType() || argTypes[i].isDoubleType()) {
                hiword = VM_Magic.getMemoryWord(gluefp + varargFPROffset);
                varargFPROffset += 4;
                loword = VM_Magic.getMemoryWord(gluefp + varargFPROffset);
                varargFPROffset += 4;
                VM_Magic.setMemoryWord(gluefp + spillAreaOffset, hiword);
                spillAreaOffset += 4;
                VM_Magic.setMemoryWord(gluefp + spillAreaOffset, loword);
                spillAreaOffset += 4;
            } else if (argTypes[i].isLongType()) {
                hiword = VM_Magic.getMemoryWord(gluefp + varargGPROffset);
                varargGPROffset += 4;
                VM_Magic.setMemoryWord(gluefp + spillAreaOffset, hiword);
                spillAreaOffset += 4;
                if (spillAreaOffset < spillAreaLimit) {
                    loword = VM_Magic.getMemoryWord(gluefp + varargGPROffset);
                    varargGPROffset += 4;
                    VM_Magic.setMemoryWord(gluefp + spillAreaOffset, loword);
                    spillAreaOffset += 4;
                }
            } else {
                hiword = VM_Magic.getMemoryWord(gluefp + varargGPROffset);
                varargGPROffset += 4;
                VM_Magic.setMemoryWord(gluefp + spillAreaOffset, hiword);
                spillAreaOffset += 4;
            }
        }
        return varargAddress;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126614.java,443,485
default,86184.java,443,485
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45025.java,443,485
default,19383.java,450,492
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,3880.java,443,485
default,118595.java,443,485
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,41120.java,443,485
default,31509.java,463,505
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45025.java,443,485
default,45048.java,463,505
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,833516.java,508,552
selected,833516.java,830,864
----------------------------------------
    public ItemSkuResult skuUpdate(ItemRequest itemRequest) throws UnsupportedOperationException {
        ItemSkuResult res = new ItemSkuResult();
        TaobaoSkuRequest itemSkuReq = (TaobaoSkuRequest) itemRequest;
        if (itemSkuReq == null || itemSkuReq.getShopId() == null || itemSkuReq.getNumIid() == null || StringUtil.isBlank(itemSkuReq.getProperties())) {
            logger.error("skuUpdate param error:itemSkuReq=" + itemSkuReq);
            res.setError(ResultConstants.RESULT_PARAM_NULL, ResultConstants.RESULT_PARAM_NULL_INFO);
            return res;
        }
        ItemSkuUpdateRequest req = new ItemSkuUpdateRequest();
        if (itemSkuReq.getItemPrice() != null) {
            req.setItemPrice(String.valueOf(itemSkuReq.getItemPrice()));
        }
        if (StringUtil.isNotBlank(itemSkuReq.getOuterId())) {
            req.setOuterId(itemSkuReq.getOuterId());
        }
        if (StringUtil.isNotBlank(itemSkuReq.getLang())) {
            req.setLang(itemSkuReq.getLang());
        }
        if (itemSkuReq.getQuantity() != null) {
            req.setQuantity(itemSkuReq.getQuantity());
        }
        if (itemSkuReq.getPrice() != null) {
            req.setPrice(String.valueOf(itemSkuReq.getPrice()));
        }
        String sessionKey = commonCache.getSessionKey(itemSkuReq.getShopId());
        if (StringUtil.isBlank(sessionKey)) {
            logger.error("skuUpdate shop[" + itemSkuReq.getShopId() + "] sessionKey is empty.");
            res.setError(ResultConstants.RESULT_SESSIONKEY_NULL, ";shopId[" + itemSkuReq.getShopId() + "] " + ResultConstants.RESULT_SESSIONKEY_NULL_INFO);
            return res;
        }
        try {
            ItemSkuUpdateResponse response = taobaoClient.execute(req, sessionKey);
            if (!response.isSuccess()) {
                logger.error("skuUpdate ErrorCode=" + response.getErrorCode() + ";ErrorMsg=" + response.getMsg() + ";itemSkuReq=" + itemSkuReq);
                res.setError(response.getErrorCode(), response.getMsg());
                return res;
            }
            res.setSku(response.getSku());
        } catch (ApiException e) {
            logger.error("skuUpdate ApiException", e);
            res.setError(ResultConstants.RESULT_TAOBAO_TOP_API_ERROR, ResultConstants.RESULT_TAOBAO_TOP_API_ERROR_INFO);
            return res;
        }
        return res;
    }
----------------------------------------
    public ItemResult itemsCustomGet(ItemRequest itemRequest) throws UnsupportedOperationException {
        ItemResult res = new ItemResult();
        TaobaoItemRequest itemReq = (TaobaoItemRequest) itemRequest;
        if (itemReq == null || itemReq.getShopId() == null || StringUtil.isBlank(itemReq.getOuterId())) {
            logger.error("itemsCustomGet param error:itemReq=" + itemReq);
            res.setError(ResultConstants.RESULT_PARAM_NULL, ResultConstants.RESULT_PARAM_NULL_INFO);
            return res;
        }
        ItemsCustomGetRequest req = new ItemsCustomGetRequest();
        if (StringUtil.isNotBlank(itemReq.getFields())) {
            req.setFields(itemReq.getFields());
        } else {
            req.setFields("num_iid,title,price,cid,after_sale_id,approve_status,auction_point,auto_fill,cod_postage_id,created," + "delist_time,desc,detail_url,ems_fee,express_fee,freight_payer,has_discount,has_invoice,has_showcase,has_warranty," + "increment,input_pids,input_str,is_3D,is_ex,is_fenxiao,is_lightning_consignment,is_prepay,is_taobao,is_timing," + "is_virtual,is_xinpin,item_img,list_time,location,modified,,nick,num,one_station,outer_id,pic_url,post_fee,postage_id" + "product_id,promoted_service,prop_img,property_alias,props,props_name,score,second_kill,sell_promise,seller_cids,sku" + "stuff_status,sub_stock,template_id,type,valid_thru,video,violation,volume,wap_desc,wap_detail_url,ww_status,");
        }
        String sessionKey = commonCache.getSessionKey(itemReq.getShopId());
        if (StringUtil.isBlank(sessionKey)) {
            logger.error("itemsCustomGet shop[" + itemReq.getShopId() + "] sessionKey is empty.");
            res.setError(ResultConstants.RESULT_SESSIONKEY_NULL, ";shopId[" + itemReq.getShopId() + "] " + ResultConstants.RESULT_SESSIONKEY_NULL_INFO);
            return res;
        }
        try {
            ItemsCustomGetResponse response = taobaoClient.execute(req, sessionKey);
            if (!response.isSuccess()) {
                logger.error("itemsCustomGet ErrorCode=" + response.getErrorCode() + ";ErrorMsg=" + response.getMsg() + ";itemReq=" + itemReq);
                res.setError(response.getErrorCode(), response.getMsg());
                return res;
            }
            res.setItems(response.getItems());
        } catch (ApiException e) {
            logger.error("itemsCustomGet ApiException", e);
            res.setError(ResultConstants.RESULT_TAOBAO_TOP_API_ERROR, ResultConstants.RESULT_TAOBAO_TOP_API_ERROR_INFO);
            return res;
        }
        return res;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73087.java,725,764
default,3931.java,725,764
----------------------------------------
    public String listAllThreads(boolean byClassName) {
        try {
            String result = "";
            int allThreads[] = getAllThreads();
            int runThreads[] = getVMThreadIDInSystemThread();
            for (int j = 0; j < runThreads.length; j++) {
                runThreads[j] = getVMThreadForIndex(runThreads[j]);
            }
            result = "All threads: " + allThreads.length + "\n";
            if (byClassName) {
                result += "  ID  VM_Thread   Thread Class\n";
                result += "  -- -----------  ------------\n";
            } else {
                result += "  ID  VM_Thread   top stack frame\n";
                result += "  -- -----------  -----------------\n";
            }
            int activeThread = reg.registerToTPIndex(reg.hardwareTP());
            activeThread = getVMThreadForIndex(activeThread);
            for (int i = 0; i < allThreads.length; i++) {
                if (allThreads[i] == activeThread) result += " -"; else result += "  ";
                boolean running = false;
                for (int j = 0; j < runThreads.length; j++) {
                    if (allThreads[i] == runThreads[j]) running = true;
                }
                if (running) result += ">"; else result += " ";
                if (byClassName) {
                    VM_Field field = bmap.findVMField("VM_Thread", "threadSlot");
                    int fieldOffset = field.getOffset();
                    int id = mem.read(allThreads[i] + fieldOffset);
                    result += id + " @" + VM.intAsHexString(allThreads[i]) + "  ";
                    result += bmap.addressToClassString(allThreads[i]).substring(1) + "\n";
                } else {
                    result += threadToString(allThreads[i]) + "\n";
                }
            }
            return result;
        } catch (Exception e) {
            return e.getMessage();
        }
    }
----------------------------------------
    public String listAllThreads(boolean byClassName) {
        try {
            String result = "";
            int allThreads[] = getAllThreads();
            int runThreads[] = getVMThreadIDInSystemThread();
            for (int j = 0; j < runThreads.length; j++) {
                runThreads[j] = getVMThreadForIndex(runThreads[j]);
            }
            result = "All threads: " + allThreads.length + "\n";
            if (byClassName) {
                result += "  ID  VM_Thread   Thread Class\n";
                result += "  -- -----------  ------------\n";
            } else {
                result += "  ID  VM_Thread   top stack frame\n";
                result += "  -- -----------  -----------------\n";
            }
            int activeThread = reg.registerToTPIndex(reg.hardwareTP());
            activeThread = getVMThreadForIndex(activeThread);
            for (int i = 0; i < allThreads.length; i++) {
                if (allThreads[i] == activeThread) result += " -"; else result += "  ";
                boolean running = false;
                for (int j = 0; j < runThreads.length; j++) {
                    if (allThreads[i] == runThreads[j]) running = true;
                }
                if (running) result += ">"; else result += " ";
                if (byClassName) {
                    VM_Field field = bmap.findVMField("VM_Thread", "threadSlot");
                    int fieldOffset = field.getOffset();
                    int id = mem.read(allThreads[i] + fieldOffset);
                    result += id + " @" + VM.intAsHexString(allThreads[i]) + "  ";
                    result += bmap.addressToClassString(allThreads[i]).substring(1) + "\n";
                } else {
                    result += threadToString(allThreads[i]) + "\n";
                }
            }
            return result;
        } catch (Exception e) {
            return e.getMessage();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,356074.java,623,663
selected,1521582.java,635,675
----------------------------------------
    private Pool loadDensityFileAscii(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new FileNotFoundException("Error trying to read file " + location + path);
        }
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading density file from: " + path);
        est.expectString("param");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mgau");
            est.expectInt("mgau index", i);
            est.expectString("feat");
            est.expectInt("feat index", 0);
            for (int j = 0; j < numGaussiansPerState; j++) {
                est.expectString("density");
                est.expectInt("densityValue", j);
                float[] density = new float[vectorLength];
                for (int k = 0; k < vectorLength; k++) {
                    density[k] = est.getFloat("val");
                    if (density[k] < floor) {
                        density[k] = floor;
                    }
                }
                int id = i * numGaussiansPerState + j;
                pool.put(id, density);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
    private Pool loadDensityFileAscii(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new FileNotFoundException("Error trying to read file " + location + path);
        }
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading density file from: " + path);
        est.expectString("param");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mgau");
            est.expectInt("mgau index", i);
            est.expectString("feat");
            est.expectInt("feat index", 0);
            for (int j = 0; j < numGaussiansPerState; j++) {
                est.expectString("density");
                est.expectInt("densityValue", j);
                float[] density = new float[vectorLength];
                for (int k = 0; k < vectorLength; k++) {
                    density[k] = est.getFloat("val");
                    if (density[k] < floor) {
                        density[k] = floor;
                    }
                }
                int id = i * numGaussiansPerState + j;
                pool.put(id, density);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2676504.java,83,126
selected,2676504.java,83,126
----------------------------------------
    public TextView(ScrollOnShowProperty scrollOnShow, SelectionProxy selectionProxy, SearchStringProxy search, GmaneFacade gmane, CommonService service) {
        super();
        this.scrollOnShow = scrollOnShow;
        this.gmane = gmane;
        this.commonService = service;
        setBorder(BorderFactory.createEmptyBorder());
        pane.setEditable(false);
        pane.setPreferredSize(new Dimension(400, 200));
        pane.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));
        pane.setFont(new Font("Courier New", 0, 12));
        pane.addHyperlinkListener(new HyperlinkListener() {

            public void hyperlinkUpdate(HyperlinkEvent arg0) {
                if (arg0.getEventType().equals(HyperlinkEvent.EventType.ACTIVATED)) {
                    browse(arg0.getURL());
                }
            }
        });
        setViewportView(pane);
        invalidate();
        final StateChangeListener<PrimaryDocument> pdListener = new StateChangeListener<PrimaryDocument>() {

            public void stateChangedNotification(PrimaryDocument t) {
                update();
            }
        };
        selectionProxy.add(new VariableProxyListener<Object>() {

            public void setVariable(Object show) {
                if (toShow != null && toShow instanceof PrimaryDocument) ((PrimaryDocument) toShow).getTextChangeNotifier().remove(pdListener);
                toShow = show;
                if (toShow != null && toShow instanceof PrimaryDocument) ((PrimaryDocument) toShow).getTextChangeNotifier().add(pdListener);
                update();
            }
        });
        this.toShow = selectionProxy.getVariable();
        search.addAndNotify(new VariableProxyListener<String>() {

            public void setVariable(String highlightQuery) {
                TextView.this.highlightQuery = highlightQuery;
                updateHighlight();
            }
        });
    }
----------------------------------------
    public TextView(ScrollOnShowProperty scrollOnShow, SelectionProxy selectionProxy, SearchStringProxy search, GmaneFacade gmane, CommonService service) {
        super();
        this.scrollOnShow = scrollOnShow;
        this.gmane = gmane;
        this.commonService = service;
        setBorder(BorderFactory.createEmptyBorder());
        pane.setEditable(false);
        pane.setPreferredSize(new Dimension(400, 200));
        pane.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));
        pane.setFont(new Font("Courier New", 0, 12));
        pane.addHyperlinkListener(new HyperlinkListener() {

            public void hyperlinkUpdate(HyperlinkEvent arg0) {
                if (arg0.getEventType().equals(HyperlinkEvent.EventType.ACTIVATED)) {
                    browse(arg0.getURL());
                }
            }
        });
        setViewportView(pane);
        invalidate();
        final StateChangeListener<PrimaryDocument> pdListener = new StateChangeListener<PrimaryDocument>() {

            public void stateChangedNotification(PrimaryDocument t) {
                update();
            }
        };
        selectionProxy.add(new VariableProxyListener<Object>() {

            public void setVariable(Object show) {
                if (toShow != null && toShow instanceof PrimaryDocument) ((PrimaryDocument) toShow).getTextChangeNotifier().remove(pdListener);
                toShow = show;
                if (toShow != null && toShow instanceof PrimaryDocument) ((PrimaryDocument) toShow).getTextChangeNotifier().add(pdListener);
                update();
            }
        });
        this.toShow = selectionProxy.getVariable();
        search.addAndNotify(new VariableProxyListener<String>() {

            public void setVariable(String highlightQuery) {
                TextView.this.highlightQuery = highlightQuery;
                updateHighlight();
            }
        });
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2499791.java,635,675
selected,1746689.java,635,675
----------------------------------------
    private Pool loadDensityFileAscii(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new FileNotFoundException("Error trying to read file " + location + path);
        }
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading density file from: " + path);
        est.expectString("param");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mgau");
            est.expectInt("mgau index", i);
            est.expectString("feat");
            est.expectInt("feat index", 0);
            for (int j = 0; j < numGaussiansPerState; j++) {
                est.expectString("density");
                est.expectInt("densityValue", j);
                float[] density = new float[vectorLength];
                for (int k = 0; k < vectorLength; k++) {
                    density[k] = est.getFloat("val");
                    if (density[k] < floor) {
                        density[k] = floor;
                    }
                }
                int id = i * numGaussiansPerState + j;
                pool.put(id, density);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
    private Pool loadDensityFileAscii(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new FileNotFoundException("Error trying to read file " + location + path);
        }
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading density file from: " + path);
        est.expectString("param");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mgau");
            est.expectInt("mgau index", i);
            est.expectString("feat");
            est.expectInt("feat index", 0);
            for (int j = 0; j < numGaussiansPerState; j++) {
                est.expectString("density");
                est.expectInt("densityValue", j);
                float[] density = new float[vectorLength];
                for (int k = 0; k < vectorLength; k++) {
                    density[k] = est.getFloat("val");
                    if (density[k] < floor) {
                        density[k] = floor;
                    }
                }
                int id = i * numGaussiansPerState + j;
                pool.put(id, density);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2552304.java,635,675
selected,2275689.java,635,675
----------------------------------------
    private Pool loadDensityFileAscii(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new FileNotFoundException("Error trying to read file " + location + path);
        }
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading density file from: " + path);
        est.expectString("param");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mgau");
            est.expectInt("mgau index", i);
            est.expectString("feat");
            est.expectInt("feat index", 0);
            for (int j = 0; j < numGaussiansPerState; j++) {
                est.expectString("density");
                est.expectInt("densityValue", j);
                float[] density = new float[vectorLength];
                for (int k = 0; k < vectorLength; k++) {
                    density[k] = est.getFloat("val");
                    if (density[k] < floor) {
                        density[k] = floor;
                    }
                }
                int id = i * numGaussiansPerState + j;
                pool.put(id, density);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
    private Pool loadDensityFileAscii(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new FileNotFoundException("Error trying to read file " + location + path);
        }
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading density file from: " + path);
        est.expectString("param");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mgau");
            est.expectInt("mgau index", i);
            est.expectString("feat");
            est.expectInt("feat index", 0);
            for (int j = 0; j < numGaussiansPerState; j++) {
                est.expectString("density");
                est.expectInt("densityValue", j);
                float[] density = new float[vectorLength];
                for (int k = 0; k < vectorLength; k++) {
                    density[k] = est.getFloat("val");
                    if (density[k] < floor) {
                        density[k] = floor;
                    }
                }
                int id = i * numGaussiansPerState + j;
                pool.put(id, density);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,131309.java,319,362
default,33257.java,319,362
----------------------------------------
    private static void constructors() throws TestException {
        Constructor cons;
        boolean error;
        System.out.print("    * getConstructor( String, null )");
        try {
            cons = RJavaTools.getConstructor(String.class, (Class[]) null, (boolean[]) null);
        } catch (Exception e) {
            throw new TestException("getConstructor( String, null )");
        }
        System.out.println(" : ok ");
        System.out.print("    * getConstructor( Integer, { String.class } )");
        try {
            cons = RJavaTools.getConstructor(Integer.class, new Class[] { String.class }, new boolean[] { false });
        } catch (Exception e) {
            throw new TestException("getConstructor( Integer, { String.class } )");
        }
        System.out.println(" : ok ");
        error = false;
        System.out.print("    * getConstructor( Integer, null )");
        try {
            cons = RJavaTools.getConstructor(Integer.class, (Class[]) null, (boolean[]) null);
        } catch (Exception e) {
            error = true;
        }
        if (!error) {
            throw new TestException("getConstructor( Integer, null ) did not generate error");
        }
        System.out.println(" -> exception : ok ");
        Object o1 = null;
        Object o2 = null;
        ExampleClass foo = new ExampleClass(o1, (String) o2, false);
        error = false;
        System.out.print("    * getConstructor( ExampleClass, {Object.class, Object.class, boolean}) : ");
        try {
            cons = RJavaTools.getConstructor(ExampleClass.class, new Class[] { Object.class, Object.class, Boolean.TYPE }, new boolean[] { true, true, false });
        } catch (Exception e) {
            error = true;
            e.printStackTrace();
        }
        if (error) {
            throw new TestException("getConstructor( ExampleClass, {Object.class, Object.class, boolean}) : exception ");
        }
        System.out.println(" ok");
    }
----------------------------------------
    private static void constructors() throws TestException {
        Constructor cons;
        boolean error;
        System.out.print("    * getConstructor( String, null )");
        try {
            cons = RJavaTools.getConstructor(String.class, (Class[]) null, (boolean[]) null);
        } catch (Exception e) {
            throw new TestException("getConstructor( String, null )");
        }
        System.out.println(" : ok ");
        System.out.print("    * getConstructor( Integer, { String.class } )");
        try {
            cons = RJavaTools.getConstructor(Integer.class, new Class[] { String.class }, new boolean[] { false });
        } catch (Exception e) {
            throw new TestException("getConstructor( Integer, { String.class } )");
        }
        System.out.println(" : ok ");
        error = false;
        System.out.print("    * getConstructor( Integer, null )");
        try {
            cons = RJavaTools.getConstructor(Integer.class, (Class[]) null, (boolean[]) null);
        } catch (Exception e) {
            error = true;
        }
        if (!error) {
            throw new TestException("getConstructor( Integer, null ) did not generate error");
        }
        System.out.println(" -> exception : ok ");
        Object o1 = null;
        Object o2 = null;
        ExampleClass foo = new ExampleClass(o1, (String) o2, false);
        error = false;
        System.out.print("    * getConstructor( ExampleClass, {Object.class, Object.class, boolean}) : ");
        try {
            cons = RJavaTools.getConstructor(ExampleClass.class, new Class[] { Object.class, Object.class, Boolean.TYPE }, new boolean[] { true, true, false });
        } catch (Exception e) {
            error = true;
            e.printStackTrace();
        }
        if (error) {
            throw new TestException("getConstructor( ExampleClass, {Object.class, Object.class, boolean}) : exception ");
        }
        System.out.println(" ok");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,608664.java,623,663
selected,2037579.java,623,663
----------------------------------------
    private Pool loadDensityFileAscii(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new FileNotFoundException("Error trying to read file " + location + path);
        }
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading density file from: " + path);
        est.expectString("param");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mgau");
            est.expectInt("mgau index", i);
            est.expectString("feat");
            est.expectInt("feat index", 0);
            for (int j = 0; j < numGaussiansPerState; j++) {
                est.expectString("density");
                est.expectInt("densityValue", j);
                float[] density = new float[vectorLength];
                for (int k = 0; k < vectorLength; k++) {
                    density[k] = est.getFloat("val");
                    if (density[k] < floor) {
                        density[k] = floor;
                    }
                }
                int id = i * numGaussiansPerState + j;
                pool.put(id, density);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
    private Pool loadDensityFileAscii(String path, float floor) throws FileNotFoundException, IOException {
        int token_type;
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new FileNotFoundException("Error trying to read file " + location + path);
        }
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        Pool pool = new Pool(path);
        logger.fine("Loading density file from: " + path);
        est.expectString("param");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mgau");
            est.expectInt("mgau index", i);
            est.expectString("feat");
            est.expectInt("feat index", 0);
            for (int j = 0; j < numGaussiansPerState; j++) {
                est.expectString("density");
                est.expectInt("densityValue", j);
                float[] density = new float[vectorLength];
                for (int k = 0; k < vectorLength; k++) {
                    density[k] = est.getFloat("val");
                    if (density[k] < floor) {
                        density[k] = floor;
                    }
                }
                int id = i * numGaussiansPerState + j;
                pool.put(id, density);
            }
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,125079.java,681,722
default,28083.java,681,722
----------------------------------------
    static Object[] packageParameterFromVarArg(VM_Method targetMethod, int argAddress) {
        VM_Type[] argTypes = targetMethod.getParameterTypes();
        int argCount = argTypes.length;
        Object[] argObjectArray = new Object[argCount];
        VM_JNIEnvironment env = VM_Thread.getCurrentThread().getJNIEnv();
        for (int i = 0, addr = argAddress; i < argCount; i++) {
            int loword, hiword;
            hiword = VM_Magic.getMemoryWord(addr);
            addr += 4;
            if (argTypes[i].isFloatType()) {
                loword = VM_Magic.getMemoryWord(addr);
                addr += 4;
                long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapFloat((float) (Double.longBitsToDouble(doubleBits)));
            } else if (argTypes[i].isDoubleType()) {
                loword = VM_Magic.getMemoryWord(addr);
                addr += 4;
                long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapDouble(Double.longBitsToDouble(doubleBits));
            } else if (argTypes[i].isLongType()) {
                loword = VM_Magic.getMemoryWord(addr);
                addr += 4;
                long longValue = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapLong(longValue);
            } else if (argTypes[i].isBooleanType()) {
                argObjectArray[i] = VM_Reflection.wrapBoolean(hiword);
            } else if (argTypes[i].isByteType()) {
                argObjectArray[i] = VM_Reflection.wrapByte((byte) hiword);
            } else if (argTypes[i].isCharType()) {
                argObjectArray[i] = VM_Reflection.wrapChar((char) hiword);
            } else if (argTypes[i].isShortType()) {
                argObjectArray[i] = VM_Reflection.wrapShort((short) hiword);
            } else if (argTypes[i].isReferenceType()) {
                argObjectArray[i] = env.getJNIRef(hiword);
            } else if (argTypes[i].isIntType()) {
                argObjectArray[i] = VM_Reflection.wrapInt(hiword);
            } else {
                return null;
            }
        }
        return argObjectArray;
    }
----------------------------------------
    static Object[] packageParameterFromVarArg(VM_Method targetMethod, int argAddress) {
        VM_Type[] argTypes = targetMethod.getParameterTypes();
        int argCount = argTypes.length;
        Object[] argObjectArray = new Object[argCount];
        VM_JNIEnvironment env = VM_Thread.getCurrentThread().getJNIEnv();
        for (int i = 0, addr = argAddress; i < argCount; i++) {
            int loword, hiword;
            hiword = VM_Magic.getMemoryWord(addr);
            addr += 4;
            if (argTypes[i].isFloatType()) {
                loword = VM_Magic.getMemoryWord(addr);
                addr += 4;
                long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapFloat((float) (Double.longBitsToDouble(doubleBits)));
            } else if (argTypes[i].isDoubleType()) {
                loword = VM_Magic.getMemoryWord(addr);
                addr += 4;
                long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapDouble(Double.longBitsToDouble(doubleBits));
            } else if (argTypes[i].isLongType()) {
                loword = VM_Magic.getMemoryWord(addr);
                addr += 4;
                long longValue = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapLong(longValue);
            } else if (argTypes[i].isBooleanType()) {
                argObjectArray[i] = VM_Reflection.wrapBoolean(hiword);
            } else if (argTypes[i].isByteType()) {
                argObjectArray[i] = VM_Reflection.wrapByte((byte) hiword);
            } else if (argTypes[i].isCharType()) {
                argObjectArray[i] = VM_Reflection.wrapChar((char) hiword);
            } else if (argTypes[i].isShortType()) {
                argObjectArray[i] = VM_Reflection.wrapShort((short) hiword);
            } else if (argTypes[i].isReferenceType()) {
                argObjectArray[i] = env.getJNIRef(hiword);
            } else if (argTypes[i].isIntType()) {
                argObjectArray[i] = VM_Reflection.wrapInt(hiword);
            } else {
                return null;
            }
        }
        return argObjectArray;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,500112.java,230,267
selected,1470057.java,362,403
----------------------------------------
    private void newSetOfData() {
        DecimalFormat valueFormat = new DecimalFormat("###.###");
        String paramPV_string = "";
        String measurePV_string = "";
        String legend_string = "";
        Double paramValue = new Double(scanController.getParamValue());
        Double paramValueRB = new Double(scanController.getParamValueRB());
        if (scanVariableParameter.getChannel() != null) {
            String paramValString = valueFormat.format(scanVariableParameter.getValue());
            paramPV_string = paramPV_string + " par.PV : " + scanVariableParameter.getChannel().getId() + "=" + paramValString;
            paramValue = new Double(scanVariableParameter.getValue());
        } else {
            paramPV_string = paramPV_string + " param.= " + paramValue;
        }
        for (int i = 0, n = measuredValuesV.size(); i < n; i++) {
            MeasuredValue mv_tmp = measuredValuesV.get(i);
            BasicGraphData gd = mv_tmp.getDataContainer();
            if (mv_tmp.getChannel() != null) {
                measurePV_string = mv_tmp.getChannel().getId();
            }
            legend_string = mv_tmp.getAlias() + ": " + measurePV_string + paramPV_string + " ";
            if (gd != null) {
                gd.removeAllPoints();
                gd.setGraphProperty(graphScan.getLegendKeyString(), legend_string);
                if (paramValue != null) gd.setGraphProperty("PARAMETER_VALUE", paramValue);
                if (paramValueRB != null) gd.setGraphProperty("PARAMETER_VALUE_RB", paramValueRB);
            }
            if (scanVariable.getChannelRB() != null) {
                gd = mv_tmp.getDataContainerRB();
                if (gd != null) {
                    if (paramValue != null) gd.setGraphProperty("PARAMETER_VALUE", paramValue);
                    if (paramValueRB != null) gd.setGraphProperty("PARAMETER_VALUE_RB", paramValueRB);
                }
            }
        }
        updateGraphPanel();
        theDoc.setHasChanges(true);
    }
----------------------------------------
    private void newSetOfData() {
        DecimalFormat valueFormat = new DecimalFormat("###.###");
        String paramPV_string = "";
        String scanPV_string = "";
        String measurePV_string = "";
        String legend_string = "";
        Double paramValue = new Double(scanController.getParamValue());
        Double paramValueRB = new Double(scanController.getParamValueRB());
        if (scanVariableParameter.getChannel() != null) {
            String paramValString = valueFormat.format(scanVariableParameter.getValue());
            paramPV_string = paramPV_string + " par.PV : " + scanVariableParameter.getChannel().getId() + "=" + paramValString;
            paramValue = new Double(scanVariableParameter.getValue());
        } else {
            paramPV_string = paramPV_string + " param.= " + paramValue;
        }
        if (scanVariable.getChannel() != null) {
            scanPV_string = "xPV=" + scanVariable.getChannel().getId();
        }
        for (int i = 0, n = measuredValuesV.size(); i < n; i++) {
            MeasuredValue mv_tmp = (MeasuredValue) measuredValuesV.get(i);
            BasicGraphData gd = mv_tmp.getDataContainer();
            if (mv_tmp.getChannel() != null) {
                measurePV_string = mv_tmp.getChannel().getId();
            }
            legend_string = measurePV_string + paramPV_string + " ";
            if (gd != null) {
                gd.removeAllPoints();
                gd.setGraphProperty(graphScan.getLegendKeyString(), legend_string);
                if (paramValue != null) gd.setGraphProperty("PARAMETER_VALUE", paramValue);
                if (paramValueRB != null) gd.setGraphProperty("PARAMETER_VALUE_RB", paramValueRB);
            }
            if (scanVariable.getChannelRB() != null) {
                gd = mv_tmp.getDataContainerRB();
                if (gd != null) {
                    if (paramValue != null) gd.setGraphProperty("PARAMETER_VALUE", paramValue);
                    if (paramValueRB != null) gd.setGraphProperty("PARAMETER_VALUE_RB", paramValueRB);
                }
            }
        }
        updateGraphPanel();
        theDoc.setHasChanges(true);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,7272.java,126,165
default,12608.java,126,165
----------------------------------------
    private static void getfieldnames() throws TestException {
        String[] names;
        System.out.print("    * getFieldNames(DummyPoint, false)");
        names = RJavaTools.getFieldNames(DummyPoint.class, false);
        if (names.length != 2) {
            throw new TestException("getFieldNames(DummyPoint, false).length != 2");
        }
        for (int i = 0; i < 2; i++) {
            if (!("x".equals(names[i]) || "y".equals(names[i]))) {
                throw new TestException("getFieldNames(DummyPoint, false).length != c('x','y') ");
            }
        }
        System.out.println(" : ok ");
        System.out.print("    * getFieldNames(DummyPoint, true )");
        names = RJavaTools.getFieldNames(DummyPoint.class, true);
        if (names.length != 0) {
            throw new TestException("getFieldNames(DummyPoint, true ) != character(0)");
        }
        System.out.println(" : ok ");
        System.out.print("    * getFieldNames(RJavaTools_Test, true )");
        names = RJavaTools.getFieldNames(RJavaTools_Test.class, true);
        if (names.length != 1) {
            throw new TestException("getFieldNames(RJavaTools_Test, true ).length != 1");
        }
        if (!"static_x".equals(names[0])) {
            throw new TestException("getFieldNames(RJavaTools_Test, true )[0] != 'static_x' ");
        }
        System.out.println(" : ok ");
        System.out.print("    * getFieldNames(RJavaTools_Test, false )");
        names = RJavaTools.getFieldNames(RJavaTools_Test.class, false);
        if (names.length != 2) {
            throw new TestException("getFieldNames(RJavaTools_Test, false ).length != 2");
        }
        for (int i = 0; i < 2; i++) {
            if (!("x".equals(names[i]) || "static_x".equals(names[i]))) {
                throw new TestException("getFieldNames(RJavaTools_Test, false ) != c('x', 'static_x') ");
            }
        }
        System.out.println(" : ok ");
    }
----------------------------------------
    private static void getfieldnames() throws TestException {
        String[] names;
        System.out.print("    * getFieldNames(DummyPoint, false)");
        names = RJavaTools.getFieldNames(DummyPoint.class, false);
        if (names.length != 2) {
            throw new TestException("getFieldNames(DummyPoint, false).length != 2");
        }
        for (int i = 0; i < 2; i++) {
            if (!("x".equals(names[i]) || "y".equals(names[i]))) {
                throw new TestException("getFieldNames(DummyPoint, false).length != c('x','y') ");
            }
        }
        System.out.println(" : ok ");
        System.out.print("    * getFieldNames(DummyPoint, true )");
        names = RJavaTools.getFieldNames(DummyPoint.class, true);
        if (names.length != 0) {
            throw new TestException("getFieldNames(DummyPoint, true ) != character(0)");
        }
        System.out.println(" : ok ");
        System.out.print("    * getFieldNames(RJavaTools_Test, true )");
        names = RJavaTools.getFieldNames(RJavaTools_Test.class, true);
        if (names.length != 1) {
            throw new TestException("getFieldNames(RJavaTools_Test, true ).length != 1");
        }
        if (!"static_x".equals(names[0])) {
            throw new TestException("getFieldNames(RJavaTools_Test, true )[0] != 'static_x' ");
        }
        System.out.println(" : ok ");
        System.out.print("    * getFieldNames(RJavaTools_Test, false )");
        names = RJavaTools.getFieldNames(RJavaTools_Test.class, false);
        if (names.length != 2) {
            throw new TestException("getFieldNames(RJavaTools_Test, false ).length != 2");
        }
        for (int i = 0; i < 2; i++) {
            if (!("x".equals(names[i]) || "static_x".equals(names[i]))) {
                throw new TestException("getFieldNames(RJavaTools_Test, false ) != c('x', 'static_x') ");
            }
        }
        System.out.println(" : ok ");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,175022.java,135,174
selected,639925.java,312,353
----------------------------------------
    private void find() {
        stopFind();
        console = extensionConsoleFactory.getLastOpenedConsole();
        document = console.getDocument();
        WorkspaceSaveContainer.findCurrent = comboFind.getText();
        WorkspaceSaveContainer.directionForward = ((Button) radioForward).getSelection();
        WorkspaceSaveContainer.regularExpression = ((Button) checkRegExp).getSelection();
        WorkspaceSaveContainer.caseSensitive = ((Button) checkCaseSensitive).getSelection();
        if (WorkspaceSaveContainer.findCurrent.equals("")) {
            ((StyledText) editResult).setText("The string to look for is empty.");
            colorizeEdit(((StyledText) editResult));
            return;
        }
        boolean found = false;
        int findHistoryCount = WorkspaceSaveContainer.findHistoryList.size();
        int findHistoryIndex;
        for (findHistoryIndex = 0; findHistoryIndex < findHistoryCount; findHistoryIndex++) {
            String elt = (String) WorkspaceSaveContainer.findHistoryList.get(findHistoryIndex);
            if (elt.equals(WorkspaceSaveContainer.findCurrent)) {
                WorkspaceSaveContainer.findHistoryList.remove(findHistoryIndex);
                found = true;
                break;
            }
        }
        WorkspaceSaveContainer.findHistoryList.add(0, WorkspaceSaveContainer.findCurrent);
        if (!found && WorkspaceSaveContainer.findHistoryList.size() > comboItemCount) WorkspaceSaveContainer.findHistoryList.remove(WorkspaceSaveContainer.findHistoryList.size() - 1);
        findHistoryCount = WorkspaceSaveContainer.findHistoryList.size();
        String[] fields = new String[findHistoryCount];
        for (findHistoryIndex = 0; findHistoryIndex < findHistoryCount; findHistoryIndex++) {
            fields[findHistoryIndex] = (String) WorkspaceSaveContainer.findHistoryList.get(findHistoryIndex);
        }
        comboFind.setItems(fields);
        comboFind.setText(WorkspaceSaveContainer.findCurrent);
        comboFind.setSelection(new Point(0, WorkspaceSaveContainer.findCurrent.length()));
        comboFind.setFocus();
        nowFinding = find(onFindCompletedNotification, WorkspaceSaveContainer.findCurrent, WorkspaceSaveContainer.directionForward, WorkspaceSaveContainer.regularExpression, WorkspaceSaveContainer.caseSensitive);
        if (nowFinding) {
            PlatformUI.getWorkbench().getDisplay().getShells()[0].setCursor(new Cursor(PlatformUI.getWorkbench().getDisplay(), SWT.CURSOR_WAIT));
        }
    }
----------------------------------------
    private void find() {
        stopFind();
        state.findCurrent = ((Combo) comboFind).getText();
        state.directionForward = ((Button) radioForward).getSelection();
        state.regularExpression = ((Button) checkRegExp).getSelection();
        state.caseSensitive = ((Button) checkCaseSensitive).getSelection();
        if (state.findCurrent.equals("")) {
            ((StyledText) editResult).setText("The string to look for is empty.");
            colorizeEdit(((StyledText) editResult));
            return;
        }
        boolean found = false;
        int findHistoryCount = state.findHistoryList.size();
        int findHistoryIndex;
        for (findHistoryIndex = 0; findHistoryIndex < findHistoryCount; findHistoryIndex++) {
            String elt = (String) state.findHistoryList.get(findHistoryIndex);
            if (elt.equals(state.findCurrent)) {
                state.findHistoryList.remove(findHistoryIndex);
                found = true;
                break;
            }
        }
        state.findHistoryList.add(0, state.findCurrent);
        if (!found && state.findHistoryList.size() > comboItemCount) state.findHistoryList.remove(state.findHistoryList.size() - 1);
        findHistoryCount = state.findHistoryList.size();
        String[] fields = new String[findHistoryCount];
        for (findHistoryIndex = 0; findHistoryIndex < findHistoryCount; findHistoryIndex++) {
            fields[findHistoryIndex] = (String) state.findHistoryList.get(findHistoryIndex);
        }
        ((Combo) comboFind).setItems(fields);
        ((Combo) comboFind).setText(state.findCurrent);
        ((Combo) comboFind).setSelection(new Point(0, state.findCurrent.length()));
        ((Combo) comboFind).setFocus();
        LogControlView activeLogControlView = (LogControlView) viewReference.getView(false);
        StringBuffer findResultStr = new StringBuffer();
        nowFinding = activeLogControlView.find(findResultStr, onFindCompletedNotification, state.findCurrent, state.directionForward, state.regularExpression, state.caseSensitive);
        if (!nowFinding) {
            ((StyledText) editResult).setText(findResultStr.toString());
            colorizeEdit(((StyledText) editResult));
            update();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1098324.java,311,352
selected,1561076.java,371,412
----------------------------------------
    public static String encodeObject(java.io.Serializable serializableObject, int options) {
        java.io.ByteArrayOutputStream baos = null;
        java.io.OutputStream b64os = null;
        java.io.ObjectOutputStream oos = null;
        java.util.zip.GZIPOutputStream gzos = null;
        int gzip = (options & GZIP);
        int dontBreakLines = (options & DONT_BREAK_LINES);
        try {
            baos = new java.io.ByteArrayOutputStream();
            b64os = new Base64.OutputStream(baos, ENCODE | options);
            if (gzip == GZIP) {
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                oos = new java.io.ObjectOutputStream(gzos);
            } else oos = new java.io.ObjectOutputStream(b64os);
            oos.writeObject(serializableObject);
        } catch (java.io.IOException e) {
            e.printStackTrace();
            return null;
        } finally {
            try {
                oos.close();
            } catch (Exception e) {
            }
            try {
                gzos.close();
            } catch (Exception e) {
            }
            try {
                b64os.close();
            } catch (Exception e) {
            }
            try {
                baos.close();
            } catch (Exception e) {
            }
        }
        try {
            return new String(baos.toByteArray(), PREFERRED_ENCODING);
        } catch (java.io.UnsupportedEncodingException uue) {
            return new String(baos.toByteArray());
        }
    }
----------------------------------------
    public static String encodeObject(java.io.Serializable serializableObject, int options) {
        java.io.ByteArrayOutputStream baos = null;
        java.io.OutputStream b64os = null;
        java.io.ObjectOutputStream oos = null;
        java.util.zip.GZIPOutputStream gzos = null;
        int gzip = (options & GZIP);
        int dontBreakLines = (options & DONT_BREAK_LINES);
        try {
            baos = new java.io.ByteArrayOutputStream();
            b64os = new Base64.OutputStream(baos, ENCODE | options);
            if (gzip == GZIP) {
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                oos = new java.io.ObjectOutputStream(gzos);
            } else oos = new java.io.ObjectOutputStream(b64os);
            oos.writeObject(serializableObject);
        } catch (java.io.IOException e) {
            e.printStackTrace();
            return null;
        } finally {
            try {
                oos.close();
            } catch (Exception e) {
            }
            try {
                gzos.close();
            } catch (Exception e) {
            }
            try {
                b64os.close();
            } catch (Exception e) {
            }
            try {
                baos.close();
            } catch (Exception e) {
            }
        }
        try {
            return new String(baos.toByteArray(), PREFERRED_ENCODING);
        } catch (java.io.UnsupportedEncodingException uue) {
            return new String(baos.toByteArray());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1831571.java,131,170
selected,10428.java,165,206
----------------------------------------
    public void testSetRollbackOnlyAtTheFirstAccount() throws Exception {
        getLog().debug("+++ testSetRollbackOnlyAtTheFirstAccount");
        Context ctx = getInitialContext();
        getLog().debug("Obtain UserTransaction instance");
        UserTransaction userTx = (UserTransaction) ctx.lookup("UserTransaction");
        getLog().debug("Obtain home interface");
        Object objref = ctx.lookup("dtmtest/PassThrough2OtsEJB");
        PassThroughHome home = (PassThroughHome) PortableRemoteObject.narrow(objref, PassThroughHome.class);
        getLog().debug("Create PassThrough bean");
        PassThrough session = home.create("testSetRollbackOnlyAtTheFirstAccount");
        getLog().debug("Set balances");
        userTx.begin();
        session.setBalances(101, 102);
        userTx.commit();
        int balances[];
        getLog().debug("Get balances");
        userTx.begin();
        balances = session.getBalances();
        userTx.commit();
        assertTrue("first balance == 101", balances[0] == 101);
        assertTrue("second balance == 102", balances[1] == 102);
        getLog().debug("Update balances, set rollback only at " + "the first account, and try to commit");
        try {
            userTx.begin();
            session.addToBalances(100);
            session.tellFirstAccountToSetRollbackOnly();
            session.addToBalances(50);
            userTx.commit();
            fail("RollbackException should have been thrown");
        } catch (RollbackException e) {
            getLog().debug("Expected exception: " + e);
        }
        getLog().debug("Check that all balances remain the same");
        userTx.begin();
        balances = session.getBalances();
        userTx.commit();
        assertTrue("first balance == 101", balances[0] == 101);
        assertTrue("second balance == 102", balances[1] == 102);
        session.remove();
    }
----------------------------------------
    public void testSetRollbackOnlyAtTheFrontEnd() throws Exception {
        getLog().debug("+++ testSetRollbackOnlyAtTheFrontEnd");
        Context ctx = getInitialContext();
        getLog().debug("Obtain UserTransaction instance");
        UserTransaction userTx = (UserTransaction) ctx.lookup("UserTransaction");
        getLog().debug("Obtain home interface");
        Object objref = ctx.lookup("dtmiioptest/FrontEndEJB");
        FrontEndHome home = (FrontEndHome) PortableRemoteObject.narrow(objref, FrontEndHome.class);
        getLog().debug("Create FrontEnd bean");
        FrontEnd frontEnd = home.create("testSetRollbackOnlyAtTheFrontEnd");
        getLog().debug("Set balances");
        userTx.begin();
        frontEnd.setBalances(101, 102, 103);
        userTx.commit();
        int balances[];
        getLog().debug("Get balances");
        userTx.begin();
        balances = frontEnd.getBalances();
        userTx.commit();
        assertTrue("first balance == 101", balances[0] == 101);
        assertTrue("second balance == 102", balances[1] == 102);
        assertTrue("third balance == 103", balances[2] == 103);
        getLog().debug("Update balances, set rollback only at the front end, " + "and try to commit");
        try {
            userTx.begin();
            frontEnd.addToBalances(100);
            frontEnd.setRollbackOnly();
            frontEnd.addToBalances(50);
            userTx.commit();
            fail("RollbackException should have been thrown");
        } catch (RollbackException e) {
            getLog().debug("Expected exception: " + e);
        }
        getLog().debug("Check that all balances remain the same");
        userTx.begin();
        balances = frontEnd.getBalances();
        userTx.commit();
        assertTrue("first balance == 101", balances[0] == 101);
        assertTrue("second balance == 102", balances[1] == 102);
        assertTrue("third balance == 103", balances[2] == 103);
        frontEnd.remove();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,939613.java,178,218
selected,1422595.java,162,202
----------------------------------------
    public static boolean nullSafeEquals(Object o1, Object o2) {
        if (o1 == o2) {
            return true;
        }
        if (o1 == null || o2 == null) {
            return false;
        }
        if (o1.equals(o2)) {
            return true;
        }
        if (o1.getClass().isArray() && o2.getClass().isArray()) {
            if (o1 instanceof Object[] && o2 instanceof Object[]) {
                return Arrays.equals((Object[]) o1, (Object[]) o2);
            }
            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {
                return Arrays.equals((boolean[]) o1, (boolean[]) o2);
            }
            if (o1 instanceof byte[] && o2 instanceof byte[]) {
                return Arrays.equals((byte[]) o1, (byte[]) o2);
            }
            if (o1 instanceof char[] && o2 instanceof char[]) {
                return Arrays.equals((char[]) o1, (char[]) o2);
            }
            if (o1 instanceof double[] && o2 instanceof double[]) {
                return Arrays.equals((double[]) o1, (double[]) o2);
            }
            if (o1 instanceof float[] && o2 instanceof float[]) {
                return Arrays.equals((float[]) o1, (float[]) o2);
            }
            if (o1 instanceof int[] && o2 instanceof int[]) {
                return Arrays.equals((int[]) o1, (int[]) o2);
            }
            if (o1 instanceof long[] && o2 instanceof long[]) {
                return Arrays.equals((long[]) o1, (long[]) o2);
            }
            if (o1 instanceof short[] && o2 instanceof short[]) {
                return Arrays.equals((short[]) o1, (short[]) o2);
            }
        }
        return false;
    }
----------------------------------------
    public static boolean nullSafeEquals(Object o1, Object o2) {
        if (o1 == o2) {
            return true;
        }
        if (o1 == null || o2 == null) {
            return false;
        }
        if (o1.equals(o2)) {
            return true;
        }
        if (o1.getClass().isArray() && o2.getClass().isArray()) {
            if (o1 instanceof Object[] && o2 instanceof Object[]) {
                return Arrays.equals((Object[]) o1, (Object[]) o2);
            }
            if (o1 instanceof boolean[] && o2 instanceof boolean[]) {
                return Arrays.equals((boolean[]) o1, (boolean[]) o2);
            }
            if (o1 instanceof byte[] && o2 instanceof byte[]) {
                return Arrays.equals((byte[]) o1, (byte[]) o2);
            }
            if (o1 instanceof char[] && o2 instanceof char[]) {
                return Arrays.equals((char[]) o1, (char[]) o2);
            }
            if (o1 instanceof double[] && o2 instanceof double[]) {
                return Arrays.equals((double[]) o1, (double[]) o2);
            }
            if (o1 instanceof float[] && o2 instanceof float[]) {
                return Arrays.equals((float[]) o1, (float[]) o2);
            }
            if (o1 instanceof int[] && o2 instanceof int[]) {
                return Arrays.equals((int[]) o1, (int[]) o2);
            }
            if (o1 instanceof long[] && o2 instanceof long[]) {
                return Arrays.equals((long[]) o1, (long[]) o2);
            }
            if (o1 instanceof short[] && o2 instanceof short[]) {
                return Arrays.equals((short[]) o1, (short[]) o2);
            }
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1907234.java,487,525
selected,1907234.java,619,657
----------------------------------------
    private static void sort1(short x[], int off, int len) {
        if (len < 7) {
            for (int i = off; i < len + off; i++) for (int j = i; j > off && x[j - 1] > x[j]; j--) swap(x, j, j - 1);
            return;
        }
        int m = off + len / 2;
        if (len > 7) {
            int l = off;
            int n = off + len - 1;
            if (len > 40) {
                int s = len / 8;
                l = med3(x, l, l + s, l + 2 * s);
                m = med3(x, m - s, m, m + s);
                n = med3(x, n - 2 * s, n - s, n);
            }
            m = med3(x, l, m, n);
        }
        short v = x[m];
        int a = off, b = a, c = off + len - 1, d = c;
        while (true) {
            while (b <= c && x[b] <= v) {
                if (x[b] == v) swap(x, a++, b);
                b++;
            }
            while (c >= b && x[c] >= v) {
                if (x[c] == v) swap(x, c, d--);
                c--;
            }
            if (b > c) break;
            swap(x, b++, c--);
        }
        int s, n = off + len;
        s = Math.min(a - off, b - a);
        vecswap(x, off, b - s, s);
        s = Math.min(d - c, n - d - 1);
        vecswap(x, b, n - s, s);
        if ((s = b - a) > 1) sort1(x, off, s);
        if ((s = d - c) > 1) sort1(x, n - s, s);
    }
----------------------------------------
    private static void sort1(byte x[], int off, int len) {
        if (len < 7) {
            for (int i = off; i < len + off; i++) for (int j = i; j > off && x[j - 1] > x[j]; j--) swap(x, j, j - 1);
            return;
        }
        int m = off + len / 2;
        if (len > 7) {
            int l = off;
            int n = off + len - 1;
            if (len > 40) {
                int s = len / 8;
                l = med3(x, l, l + s, l + 2 * s);
                m = med3(x, m - s, m, m + s);
                n = med3(x, n - 2 * s, n - s, n);
            }
            m = med3(x, l, m, n);
        }
        byte v = x[m];
        int a = off, b = a, c = off + len - 1, d = c;
        while (true) {
            while (b <= c && x[b] <= v) {
                if (x[b] == v) swap(x, a++, b);
                b++;
            }
            while (c >= b && x[c] >= v) {
                if (x[c] == v) swap(x, c, d--);
                c--;
            }
            if (b > c) break;
            swap(x, b++, c--);
        }
        int s, n = off + len;
        s = Math.min(a - off, b - a);
        vecswap(x, off, b - s, s);
        s = Math.min(d - c, n - d - 1);
        vecswap(x, b, n - s, s);
        if ((s = b - a) > 1) sort1(x, off, s);
        if ((s = d - c) > 1) sort1(x, n - s, s);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2016846.java,39,81
selected,2016846.java,39,81
----------------------------------------
    public static void copy(File fromFile, File toFile) throws IOException {
        String fromFilename = fromFile.getPath();
        String toFileName = toFile.getPath();
        if (!fromFile.exists()) throw new IOException("FileCopy: " + "no such source file: " + fromFilename);
        if (!fromFile.isFile()) throw new IOException("FileCopy: " + "can't copy directory: " + fromFilename);
        if (!fromFile.canRead()) throw new IOException("FileCopy: " + "source file is unreadable: " + fromFilename);
        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());
        if (toFile.exists()) {
            if (!toFile.canWrite()) throw new IOException("FileCopy: " + "destination file is unwriteable: " + toFileName);
            if (AppState.isVerbose()) System.out.print("Overwrite existing file " + toFile.getName() + "? (Y/N): ");
            System.out.flush();
            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            String response = in.readLine();
            if (!response.equals("Y") && !response.equals("y")) throw new IOException("FileCopy: " + "existing file was not overwritten.");
        } else {
            String parent = toFile.getParent();
            if (parent == null) parent = System.getProperty("user.dir");
            File dir = new File(parent);
            if (!dir.exists()) throw new IOException("FileCopy: " + "destination directory doesn't exist: " + parent);
            if (dir.isFile()) throw new IOException("FileCopy: " + "destination is not a directory: " + parent);
            if (!dir.canWrite()) throw new IOException("FileCopy: " + "destination directory is unwriteable: " + parent);
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(fromFile);
            to = new FileOutputStream(toFile);
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                ;
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                ;
            }
        }
    }
----------------------------------------
    public static void copy(File fromFile, File toFile) throws IOException {
        String fromFilename = fromFile.getPath();
        String toFileName = toFile.getPath();
        if (!fromFile.exists()) throw new IOException("FileCopy: " + "no such source file: " + fromFilename);
        if (!fromFile.isFile()) throw new IOException("FileCopy: " + "can't copy directory: " + fromFilename);
        if (!fromFile.canRead()) throw new IOException("FileCopy: " + "source file is unreadable: " + fromFilename);
        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());
        if (toFile.exists()) {
            if (!toFile.canWrite()) throw new IOException("FileCopy: " + "destination file is unwriteable: " + toFileName);
            if (AppState.isVerbose()) System.out.print("Overwrite existing file " + toFile.getName() + "? (Y/N): ");
            System.out.flush();
            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            String response = in.readLine();
            if (!response.equals("Y") && !response.equals("y")) throw new IOException("FileCopy: " + "existing file was not overwritten.");
        } else {
            String parent = toFile.getParent();
            if (parent == null) parent = System.getProperty("user.dir");
            File dir = new File(parent);
            if (!dir.exists()) throw new IOException("FileCopy: " + "destination directory doesn't exist: " + parent);
            if (dir.isFile()) throw new IOException("FileCopy: " + "destination is not a directory: " + parent);
            if (!dir.canWrite()) throw new IOException("FileCopy: " + "destination directory is unwriteable: " + parent);
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(fromFile);
            to = new FileOutputStream(toFile);
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                ;
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16384.java,248,285
default,6689.java,248,285
----------------------------------------
    private void displayMessageHeaders(MailUserData mud, Message msg, ServletOutputStream out) throws IOException {
        try {
            out.println("<b>Date:</b> " + msg.getSentDate() + "<br>");
            Address[] fr = msg.getFrom();
            if (fr != null) {
                boolean tf = true;
                out.print("<b>From:</b> ");
                for (int i = 0; i < fr.length; i++) {
                    out.print(((tf) ? " " : ", ") + getDisplayAddress(fr[i]));
                    tf = false;
                }
                out.println("<br>");
            }
            Address[] to = msg.getRecipients(Message.RecipientType.TO);
            if (to != null) {
                boolean tf = true;
                out.print("<b>To:</b> ");
                for (int i = 0; i < to.length; i++) {
                    out.print(((tf) ? " " : ", ") + getDisplayAddress(to[i]));
                    tf = false;
                }
                out.println("<br>");
            }
            Address[] cc = msg.getRecipients(Message.RecipientType.CC);
            if (cc != null) {
                boolean cf = true;
                out.print("<b>CC:</b> ");
                for (int i = 0; i < cc.length; i++) {
                    out.print(((cf) ? " " : ", ") + getDisplayAddress(cc[i]));
                    cf = false;
                }
                out.println("<br>");
            }
            out.print("<b>Subject:</b> " + ((msg.getSubject() != null) ? msg.getSubject() : "") + "<br>");
        } catch (MessagingException mex) {
            out.println(msg.toString());
        }
    }
----------------------------------------
    private void displayMessageHeaders(MailUserData mud, Message msg, ServletOutputStream out) throws IOException {
        try {
            out.println("<b>Date:</b> " + msg.getSentDate() + "<br>");
            Address[] fr = msg.getFrom();
            if (fr != null) {
                boolean tf = true;
                out.print("<b>From:</b> ");
                for (int i = 0; i < fr.length; i++) {
                    out.print(((tf) ? " " : ", ") + getDisplayAddress(fr[i]));
                    tf = false;
                }
                out.println("<br>");
            }
            Address[] to = msg.getRecipients(Message.RecipientType.TO);
            if (to != null) {
                boolean tf = true;
                out.print("<b>To:</b> ");
                for (int i = 0; i < to.length; i++) {
                    out.print(((tf) ? " " : ", ") + getDisplayAddress(to[i]));
                    tf = false;
                }
                out.println("<br>");
            }
            Address[] cc = msg.getRecipients(Message.RecipientType.CC);
            if (cc != null) {
                boolean cf = true;
                out.print("<b>CC:</b> ");
                for (int i = 0; i < cc.length; i++) {
                    out.print(((cf) ? " " : ", ") + getDisplayAddress(cc[i]));
                    cf = false;
                }
                out.println("<br>");
            }
            out.print("<b>Subject:</b> " + ((msg.getSubject() != null) ? msg.getSubject() : "") + "<br>");
        } catch (MessagingException mex) {
            out.println(msg.toString());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,935096.java,244,280
selected,935096.java,282,322
----------------------------------------
    public static byte[] compressFile(File inFile, File outFile, String tsuid, int[] planarConfiguration, int[] pxdataVR, byte[] buffer) throws Exception {
        log.info("M-READ file:" + inFile);
        InputStream in = new BufferedInputStream(new FileInputStream(inFile));
        try {
            DcmParser p = DcmParserFactory.getInstance().newDcmParser(in);
            final DcmObjectFactory of = DcmObjectFactory.getInstance();
            Dataset ds = of.newDataset();
            p.setDcmHandler(ds.getDcmHandler());
            p.parseDcmFile(FileFormat.DICOM_FILE, Tags.PixelData);
            if (planarConfiguration != null && planarConfiguration.length != 0) planarConfiguration[0] = ds.getInt(Tags.PlanarConfiguration, 0);
            if (pxdataVR != null && pxdataVR.length != 0) pxdataVR[0] = p.getReadVR();
            FileMetaInfo fmi = of.newFileMetaInfo(ds, tsuid);
            ds.setFileMetaInfo(fmi);
            log.info("M-WRITE file:" + outFile);
            MessageDigest md = MessageDigest.getInstance("MD5");
            DigestOutputStream dos = new DigestOutputStream(new FileOutputStream(outFile), md);
            BufferedOutputStream bos = new BufferedOutputStream(dos, buffer);
            try {
                DcmDecodeParam decParam = p.getDcmDecodeParam();
                DcmEncodeParam encParam = DcmEncodeParam.valueOf(tsuid);
                CompressCmd compressCmd = CompressCmd.createCompressCmd(ds, tsuid);
                compressCmd.coerceDataset(ds);
                ds.writeFile(bos, encParam);
                ds.writeHeader(bos, encParam, Tags.PixelData, VRs.OB, -1);
                int read = compressCmd.compress(decParam.byteOrder, in, bos, null);
                ds.writeHeader(bos, encParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                skipFully(in, p.getReadLength() - read);
                p.parseDataset(decParam, -1);
                ds.subSet(Tags.PixelData, -1).writeDataset(bos, encParam);
            } finally {
                bos.close();
            }
            return md.digest();
        } finally {
            in.close();
        }
    }
----------------------------------------
    public static byte[] compressFileJPEGLossy(File inFile, File outFile, int[] planarConfiguration, int[] pxdataVR, float quality, String derivationDescription, float estimatedCompressionRatio, float[] actualCompressionRatio, String iuid, String suid, byte[] buffer, Dataset ds, FileInfo fileInfo) throws Exception {
        if (suid != null && iuid == null) throw new IllegalArgumentException("New Series Instance UID requires new SOP Instance UID");
        log.info("M-READ file:" + inFile);
        InputStream in = new BufferedInputStream(new FileInputStream(inFile));
        try {
            DcmParser p = DcmParserFactory.getInstance().newDcmParser(in);
            if (ds == null) ds = DcmObjectFactory.getInstance().newDataset();
            p.setDcmHandler(ds.getDcmHandler());
            p.parseDcmFile(FileFormat.DICOM_FILE, Tags.PixelData);
            if (planarConfiguration != null && planarConfiguration.length != 0) planarConfiguration[0] = ds.getInt(Tags.PlanarConfiguration, 0);
            if (pxdataVR != null && pxdataVR.length != 0) pxdataVR[0] = p.getReadVR();
            if (fileInfo != null) {
                DatasetUtils.fromByteArray(fileInfo.patAttrs, DatasetUtils.fromByteArray(fileInfo.studyAttrs, DatasetUtils.fromByteArray(fileInfo.seriesAttrs, DatasetUtils.fromByteArray(fileInfo.instAttrs, ds))));
            }
            CompressCmd compressCmd = createJPEGLossyCompressCmd(ds, quality, derivationDescription, estimatedCompressionRatio, iuid, suid);
            compressCmd.coerceDataset(ds);
            String tsuid = compressCmd.getTransferSyntaxUID();
            FileMetaInfo fmi = DcmObjectFactory.getInstance().newFileMetaInfo(ds, tsuid);
            ds.setFileMetaInfo(fmi);
            log.info("M-WRITE file:" + outFile);
            MessageDigest md = MessageDigest.getInstance("MD5");
            DigestOutputStream dos = new DigestOutputStream(new FileOutputStream(outFile), md);
            BufferedOutputStream bos = new BufferedOutputStream(dos, buffer);
            try {
                DcmDecodeParam decParam = p.getDcmDecodeParam();
                DcmEncodeParam encParam = DcmEncodeParam.valueOf(tsuid);
                ds.writeFile(bos, encParam);
                ds.writeHeader(bos, encParam, Tags.PixelData, VRs.OB, -1);
                int read = compressCmd.compress(decParam.byteOrder, in, bos, actualCompressionRatio);
                ds.writeHeader(bos, encParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                skipFully(in, p.getReadLength() - read);
                p.parseDataset(decParam, -1);
                ds.subSet(Tags.PixelData, -1).writeDataset(bos, encParam);
            } finally {
                bos.close();
            }
            return md.digest();
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,48824.java,627,667
default,44688.java,662,702
----------------------------------------
    private byte[] addUpdateItem(HTTPurl urlData) throws Exception {
        String id = urlData.getParameter("id");
        ScheduleItem item = null;
        String statusPage = urlData.getParameter("status");
        String backURL = urlData.getCookie("backURL");
        try {
            backURL = URLDecoder.decode(backURL, "UTF-8");
        } catch (Exception e) {
        }
        if (backURL == null || backURL.length() == 0) backURL = "/servlet/" + urlData.getServletClass();
        if (id != null && id.length() > 0) {
            item = store.getScheduleItem(id);
        }
        if (item != null && (item.getState() != ScheduleItem.FINISHED && item.getState() != ScheduleItem.WAITING && item.getState() != ScheduleItem.SKIPPED && item.getState() != ScheduleItem.ERROR)) {
            StringBuffer out = new StringBuffer();
            out.append("HTTP/1.0 302 Moved Temporarily\n");
            out.append("Location: /servlet/ScheduleDataRes\n\n");
            return out.toString().getBytes();
        }
        String mes = addSchedule(urlData, item);
        if (statusPage != null && statusPage.equals("1")) {
            StringBuffer buff = new StringBuffer();
            buff.append("HTTP/1.0 200\n");
            buff.append("Content-Type: text/xml\n\n");
            buff.append("<schedule_add>\n");
            if (mes == null) {
                buff.append("<status>ADDED</status>\n");
                buff.append("<message></message>\n");
            } else {
                buff.append("<status>FAILED</status>\n");
                buff.append("<message>" + mes + "</message>\n");
            }
            buff.append("</schedule_add>\n");
            return buff.toString().getBytes();
        }
        if (mes != null) throw new Exception(mes);
        StringBuffer out = new StringBuffer(4096);
        out.append("HTTP/1.0 302 Moved Temporarily\n");
        out.append("Location: " + backURL + "\n\n");
        return out.toString().getBytes();
    }
----------------------------------------
    private byte[] addUpdateItem(HTTPurl urlData) throws Exception {
        String id = urlData.getParameter("id");
        ScheduleItem item = null;
        String statusPage = urlData.getParameter("status");
        String backURL = urlData.getCookie("backURL");
        try {
            backURL = URLDecoder.decode(backURL, "UTF-8");
        } catch (Exception e) {
        }
        if (backURL == null || backURL.length() == 0) backURL = "/servlet/" + urlData.getServletClass();
        if (id != null && id.length() > 0) {
            item = store.getScheduleItem(id);
        }
        if (item != null && (item.getState() != ScheduleItem.FINISHED && item.getState() != ScheduleItem.WAITING && item.getState() != ScheduleItem.SKIPPED && item.getState() != ScheduleItem.ERROR)) {
            StringBuffer out = new StringBuffer();
            out.append("HTTP/1.0 302 Moved Temporarily\n");
            out.append("Location: /servlet/ScheduleDataRes\n\n");
            return out.toString().getBytes();
        }
        String mes = addSchedule(urlData, item);
        if (statusPage != null && statusPage.equals("1")) {
            StringBuffer buff = new StringBuffer();
            buff.append("HTTP/1.0 200\n");
            buff.append("Content-Type: text/xml\n\n");
            buff.append("<schedule_add>\n");
            if (mes == null) {
                buff.append("<status>ADDED</status>\n");
                buff.append("<message></message>\n");
            } else {
                buff.append("<status>FAILED</status>\n");
                buff.append("<message>" + mes + "</message>\n");
            }
            buff.append("</schedule_add>\n");
            return buff.toString().getBytes();
        }
        if (mes != null) throw new Exception(mes);
        StringBuffer out = new StringBuffer(4096);
        out.append("HTTP/1.0 302 Moved Temporarily\n");
        out.append("Location: " + backURL + "\n\n");
        return out.toString().getBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,355856.java,167,197
selected,1484507.java,329,368
----------------------------------------
    private boolean _jspx_meth_html_005flink_005f0(PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.struts.taglib.html.LinkTag _jspx_th_html_005flink_005f0 = (org.apache.struts.taglib.html.LinkTag) _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.get(org.apache.struts.taglib.html.LinkTag.class);
        _jspx_th_html_005flink_005f0.setPageContext(_jspx_page_context);
        _jspx_th_html_005flink_005f0.setParent(null);
        _jspx_th_html_005flink_005f0.setStyleId("incluir");
        _jspx_th_html_005flink_005f0.setHref("login.do");
        int _jspx_eval_html_005flink_005f0 = _jspx_th_html_005flink_005f0.doStartTag();
        if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_html_005flink_005f0.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_html_005flink_005f0.doInitBody();
            }
            do {
                out.write("Início");
                int evalDoAfterBody = _jspx_th_html_005flink_005f0.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_html_005flink_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f0);
            return true;
        }
        _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f0);
        return false;
    }
----------------------------------------
    private boolean _jspx_meth_html_005fselect_005f0(javax.servlet.jsp.tagext.JspTag _jspx_th_html_005fform_005f0, PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.struts.taglib.html.SelectTag _jspx_th_html_005fselect_005f0 = (org.apache.struts.taglib.html.SelectTag) _005fjspx_005ftagPool_005fhtml_005fselect_005fstyleId_005fstyleClass_005fproperty.get(org.apache.struts.taglib.html.SelectTag.class);
        _jspx_th_html_005fselect_005f0.setPageContext(_jspx_page_context);
        _jspx_th_html_005fselect_005f0.setParent((javax.servlet.jsp.tagext.Tag) _jspx_th_html_005fform_005f0);
        _jspx_th_html_005fselect_005f0.setProperty("grupo");
        _jspx_th_html_005fselect_005f0.setStyleId("grupo");
        _jspx_th_html_005fselect_005f0.setStyleClass("campo");
        int _jspx_eval_html_005fselect_005f0 = _jspx_th_html_005fselect_005f0.doStartTag();
        if (_jspx_eval_html_005fselect_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_html_005fselect_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_html_005fselect_005f0.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_html_005fselect_005f0.doInitBody();
            }
            do {
                out.write("\r\n");
                out.write("\t\t");
                if (_jspx_meth_html_005foption_005f0(_jspx_th_html_005fselect_005f0, _jspx_page_context)) return true;
                out.write("\r\n");
                out.write("\t\t");
                if (_jspx_meth_html_005foptionsCollection_005f0(_jspx_th_html_005fselect_005f0, _jspx_page_context)) return true;
                out.write('\r');
                out.write('\n');
                out.write('	');
                int evalDoAfterBody = _jspx_th_html_005fselect_005f0.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_html_005fselect_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_html_005fselect_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fhtml_005fselect_005fstyleId_005fstyleClass_005fproperty.reuse(_jspx_th_html_005fselect_005f0);
            return true;
        }
        _005fjspx_005ftagPool_005fhtml_005fselect_005fstyleId_005fstyleClass_005fproperty.reuse(_jspx_th_html_005fselect_005f0);
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1036506.java,1286,1322
selected,1626163.java,1286,1322
----------------------------------------
    protected Pool loadTransitionMatricesAscii(String path) throws FileNotFoundException, IOException {
        InputStream inputStream = StreamFactory.getInputStream(location, path);
        logger.fine("Loading transition matrices from: " + path);
        int numMatrices;
        int numStates;
        Pool pool = new Pool(path);
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        est.expectString("tmat");
        numMatrices = est.getInt("numMatrices");
        numStates = est.getInt("numStates");
        logger.fine("with " + numMatrices + " and " + numStates + " states, in " + (sparseForm ? "sparse" : "dense") + " form");
        for (int i = 0; i < numMatrices; i++) {
            est.expectString("tmat");
            est.expectString("[" + i + "]");
            float[][] tmat = new float[numStates][numStates];
            for (int j = 0; j < numStates; j++) {
                for (int k = 0; k < numStates; k++) {
                    if (j < numStates - 1) {
                        if (sparseForm) {
                            if (k == j || k == j + 1) {
                                tmat[j][k] = est.getFloat("tmat value");
                            }
                        } else {
                            tmat[j][k] = est.getFloat("tmat value");
                        }
                    }
                    tmat[j][k] = logMath.linearToLog(tmat[j][k]);
                    if (logger.isLoggable(Level.FINE)) {
                        logger.fine("tmat j " + j + " k " + k + " tm " + tmat[j][k]);
                    }
                }
            }
            pool.put(i, tmat);
        }
        est.close();
        return pool;
    }
----------------------------------------
    protected Pool loadTransitionMatricesAscii(String path) throws FileNotFoundException, IOException {
        InputStream inputStream = StreamFactory.getInputStream(location, path);
        logger.fine("Loading transition matrices from: " + path);
        int numMatrices;
        int numStates;
        Pool pool = new Pool(path);
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        est.expectString("tmat");
        numMatrices = est.getInt("numMatrices");
        numStates = est.getInt("numStates");
        logger.fine("with " + numMatrices + " and " + numStates + " states, in " + (sparseForm ? "sparse" : "dense") + " form");
        for (int i = 0; i < numMatrices; i++) {
            est.expectString("tmat");
            est.expectString("[" + i + "]");
            float[][] tmat = new float[numStates][numStates];
            for (int j = 0; j < numStates; j++) {
                for (int k = 0; k < numStates; k++) {
                    if (j < numStates - 1) {
                        if (sparseForm) {
                            if (k == j || k == j + 1) {
                                tmat[j][k] = est.getFloat("tmat value");
                            }
                        } else {
                            tmat[j][k] = est.getFloat("tmat value");
                        }
                    }
                    tmat[j][k] = logMath.linearToLog(tmat[j][k]);
                    if (logger.isLoggable(Level.FINE)) {
                        logger.fine("tmat j " + j + " k " + k + " tm " + tmat[j][k]);
                    }
                }
            }
            pool.put(i, tmat);
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1194865.java,98,135
selected,1194865.java,140,177
----------------------------------------
    public void testDecodeJTLM_publish100() throws Exception {
        EXISchema corpus = EXISchemaFactoryTestUtil.getEXISchema("/JTLM/schemas/TLMComposite.xsd", getClass(), m_compilerErrors);
        Assert.assertEquals(0, m_compilerErrors.getTotalCount());
        GrammarCache grammarCache = new GrammarCache(corpus, GrammarOptions.DEFAULT_OPTIONS);
        String[] exiFiles = { "/JTLM/publish100/publish100.bitPacked", "/JTLM/publish100/publish100.byteAligned", "/JTLM/publish100/publish100.preCompress", "/JTLM/publish100/publish100.compress" };
        for (int i = 0; i < Alignments.length; i++) {
            AlignmentType alignment = Alignments[i];
            EXIDecoder decoder = new EXIDecoder();
            Scanner scanner;
            decoder.setAlignmentType(alignment);
            URL url = resolveSystemIdAsURL(exiFiles[i]);
            int n_events, n_texts;
            decoder.setEXISchema(grammarCache);
            decoder.setInputStream(url.openStream());
            scanner = decoder.processHeader();
            ArrayList<EXIEvent> exiEventList = new ArrayList<EXIEvent>();
            EXIEvent exiEvent;
            n_events = 0;
            n_texts = 0;
            while ((exiEvent = scanner.nextEvent()) != null) {
                ++n_events;
                if (exiEvent.getEventVariety() == EXIEvent.EVENT_CH) {
                    String stringValue = exiEvent.getCharacters().makeString();
                    if (stringValue.length() == 0 && exiEvent.getEventType().itemType == EventCode.ITEM_SCHEMA_CH) {
                        --n_events;
                        continue;
                    }
                    if (n_texts % 100 == 0) {
                        final int n = n_texts / 100;
                        Assert.assertEquals(publish100_centennials[n], stringValue);
                    }
                    ++n_texts;
                }
                exiEventList.add(exiEvent);
            }
            Assert.assertEquals(10610, n_events);
        }
    }
----------------------------------------
    public void testDecodeJTLM_publish911() throws Exception {
        EXISchema corpus = EXISchemaFactoryTestUtil.getEXISchema("/JTLM/schemas/TLMComposite.xsd", getClass(), m_compilerErrors);
        Assert.assertEquals(0, m_compilerErrors.getTotalCount());
        GrammarCache grammarCache = new GrammarCache(corpus, GrammarOptions.DEFAULT_OPTIONS);
        String[] exiFiles = { "/JTLM/publish911/publish911.bitPacked", "/JTLM/publish911/publish911.byteAligned", "/JTLM/publish911/publish911.preCompress", "/JTLM/publish911/publish911.compress" };
        for (int i = 0; i < Alignments.length; i++) {
            AlignmentType alignment = Alignments[i];
            EXIDecoder decoder = new EXIDecoder();
            Scanner scanner;
            decoder.setAlignmentType(alignment);
            URL url = resolveSystemIdAsURL(exiFiles[i]);
            int n_events, n_texts;
            decoder.setEXISchema(grammarCache);
            decoder.setInputStream(url.openStream());
            scanner = decoder.processHeader();
            ArrayList<EXIEvent> exiEventList = new ArrayList<EXIEvent>();
            EXIEvent exiEvent;
            n_events = 0;
            n_texts = 0;
            while ((exiEvent = scanner.nextEvent()) != null) {
                ++n_events;
                if (exiEvent.getEventVariety() == EXIEvent.EVENT_CH) {
                    String stringValue = exiEvent.getCharacters().makeString();
                    if (stringValue.length() == 0 && exiEvent.getEventType().itemType == EventCode.ITEM_SCHEMA_CH) {
                        --n_events;
                        continue;
                    }
                    if (n_texts % 100 == 0) {
                        final int n = n_texts / 100;
                        Assert.assertEquals(publish911_centennials[n], stringValue);
                    }
                    ++n_texts;
                }
                exiEventList.add(exiEvent);
            }
            Assert.assertEquals(96576, n_events);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5489.java,414,450
default,123451.java,410,446
----------------------------------------
    public void serveUDP(InetAddress addr, int port) {
        try {
            DatagramSocket sock = new DatagramSocket(port, addr);
            final short udpLength = 512;
            byte[] in = new byte[udpLength];
            DatagramPacket indp = new DatagramPacket(in, in.length);
            DatagramPacket outdp = null;
            while (true) {
                indp.setLength(in.length);
                try {
                    sock.receive(indp);
                } catch (InterruptedIOException e) {
                    continue;
                }
                Message query;
                byte[] response = null;
                try {
                    query = new Message(in);
                    response = generateReply(query, in, indp.getLength(), null);
                    if (response == null) continue;
                } catch (IOException e) {
                    response = formerrMessage(in);
                }
                if (outdp == null) outdp = new DatagramPacket(response, response.length, indp.getAddress(), indp.getPort()); else {
                    outdp.setData(response);
                    outdp.setLength(response.length);
                    outdp.setAddress(indp.getAddress());
                    outdp.setPort(indp.getPort());
                }
                sock.send(outdp);
            }
        } catch (IOException e) {
            String addrString;
            if (addr == null) addrString = "0.0.0.0"; else addrString = addr.getHostAddress();
            System.out.println("serveUDP(" + addrString + "#" + port + "): " + e);
        }
    }
----------------------------------------
    public void serveUDP(InetAddress addr, int port) {
        try {
            DatagramSocket sock = new DatagramSocket(port, addr);
            final short udpLength = 512;
            byte[] in = new byte[udpLength];
            DatagramPacket indp = new DatagramPacket(in, in.length);
            DatagramPacket outdp = null;
            while (true) {
                indp.setLength(in.length);
                try {
                    sock.receive(indp);
                } catch (InterruptedIOException e) {
                    continue;
                }
                Message query;
                byte[] response = null;
                try {
                    query = new Message(in);
                    response = generateReply(query, in, indp.getLength(), null);
                    if (response == null) continue;
                } catch (IOException e) {
                    response = formerrMessage(in);
                }
                if (outdp == null) outdp = new DatagramPacket(response, response.length, indp.getAddress(), indp.getPort()); else {
                    outdp.setData(response);
                    outdp.setLength(response.length);
                    outdp.setAddress(indp.getAddress());
                    outdp.setPort(indp.getPort());
                }
                sock.send(outdp);
            }
        } catch (IOException e) {
            String addrString;
            if (addr == null) addrString = "0.0.0.0"; else addrString = addr.getHostAddress();
            System.out.println("serveUDP(" + addrString + "#" + port + "): " + e);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,357712.java,1281,1318
selected,762516.java,1269,1306
----------------------------------------
    protected void synchronizeChildren() {
        if (needsSyncData()) {
            synchronizeData();
            if (!needsSyncChildren()) {
                return;
            }
        }
        boolean orig = mutationEvents;
        mutationEvents = false;
        needsSyncChildren(false);
        getNodeType(0);
        ChildNode first = null;
        ChildNode last = null;
        for (int index = getLastChild(0); index != -1; index = getPrevSibling(index)) {
            ChildNode node = (ChildNode) getNodeObject(index);
            if (last == null) {
                last = node;
            } else {
                first.previousSibling = node;
            }
            node.ownerNode = this;
            node.isOwned(true);
            node.nextSibling = first;
            first = node;
            int type = node.getNodeType();
            if (type == Node.ELEMENT_NODE) {
                docElement = (ElementImpl) node;
            } else if (type == Node.DOCUMENT_TYPE_NODE) {
                docType = (DocumentTypeImpl) node;
            }
        }
        if (first != null) {
            firstChild = first;
            first.isFirstChild(true);
            lastChild(last);
        }
        mutationEvents = orig;
    }
----------------------------------------
    protected void synchronizeChildren() {
        if (needsSyncData()) {
            synchronizeData();
            if (!needsSyncChildren()) {
                return;
            }
        }
        boolean orig = mutationEvents;
        mutationEvents = false;
        needsSyncChildren(false);
        getNodeType(0);
        ChildNode first = null;
        ChildNode last = null;
        for (int index = getLastChild(0); index != -1; index = getPrevSibling(index)) {
            ChildNode node = (ChildNode) getNodeObject(index);
            if (last == null) {
                last = node;
            } else {
                first.previousSibling = node;
            }
            node.ownerNode = this;
            node.isOwned(true);
            node.nextSibling = first;
            first = node;
            int type = node.getNodeType();
            if (type == Node.ELEMENT_NODE) {
                docElement = (ElementImpl) node;
            } else if (type == Node.DOCUMENT_TYPE_NODE) {
                docType = (DocumentTypeImpl) node;
            }
        }
        if (first != null) {
            firstChild = first;
            first.isFirstChild(true);
            lastChild(last);
        }
        mutationEvents = orig;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5489.java,414,450
default,89284.java,409,443
----------------------------------------
    public void serveUDP(InetAddress addr, int port) {
        try {
            DatagramSocket sock = new DatagramSocket(port, addr);
            final short udpLength = 512;
            byte[] in = new byte[udpLength];
            DatagramPacket indp = new DatagramPacket(in, in.length);
            DatagramPacket outdp = null;
            while (true) {
                indp.setLength(in.length);
                try {
                    sock.receive(indp);
                } catch (InterruptedIOException e) {
                    continue;
                }
                Message query;
                byte[] response = null;
                try {
                    query = new Message(in);
                    response = generateReply(query, in, indp.getLength(), null);
                    if (response == null) continue;
                } catch (IOException e) {
                    response = formerrMessage(in);
                }
                if (outdp == null) outdp = new DatagramPacket(response, response.length, indp.getAddress(), indp.getPort()); else {
                    outdp.setData(response);
                    outdp.setLength(response.length);
                    outdp.setAddress(indp.getAddress());
                    outdp.setPort(indp.getPort());
                }
                sock.send(outdp);
            }
        } catch (IOException e) {
            String addrString;
            if (addr == null) addrString = "0.0.0.0"; else addrString = addr.getHostAddress();
            System.out.println("serveUDP(" + addrString + "#" + port + "): " + e);
        }
    }
----------------------------------------
    public void serveUDP(InetAddress addr, int port) {
        try {
            DatagramSocket sock = new DatagramSocket(port, addr);
            final short udpLength = 512;
            byte[] in = new byte[udpLength];
            DatagramPacket indp = new DatagramPacket(in, in.length);
            DatagramPacket outdp = null;
            while (true) {
                indp.setLength(in.length);
                try {
                    sock.receive(indp);
                } catch (InterruptedIOException e) {
                    continue;
                }
                Message query;
                byte[] response = null;
                try {
                    query = new Message(in);
                    response = generateReply(query, in, indp.getLength(), null);
                    if (response == null) continue;
                } catch (IOException e) {
                    response = formerrMessage(in);
                }
                if (outdp == null) outdp = new DatagramPacket(response, response.length, indp.getAddress(), indp.getPort()); else {
                    outdp.setData(response);
                    outdp.setLength(response.length);
                    outdp.setAddress(indp.getAddress());
                    outdp.setPort(indp.getPort());
                }
                sock.send(outdp);
            }
        } catch (IOException e) {
            System.out.println("serveUDP(" + addrport(addr, port) + "): " + e);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,653713.java,169,204
selected,1348472.java,165,203
----------------------------------------
    private void createTables() throws Exception {
        String databaseType = Environment.getInstance().getDatabaseType();
        String resourceName = new StringBuffer().append("create_").append(databaseType).append(".sql").toString();
        InputStream createScriptStream = WikiBase.getInstance().getResourceAsStream(resourceName);
        if (createScriptStream == null) {
            logger.log(Level.SEVERE, "Can't find create script: " + resourceName);
            throw new WikiException("unable to create database, sql script file missing: " + resourceName);
        }
        BufferedReader in = new BufferedReader(new InputStreamReader(createScriptStream));
        StringBuffer buffer = new StringBuffer();
        while (true) {
            String line = in.readLine();
            if (line == null) {
                break;
            }
            if (line.length() > 0 && line.charAt(0) != '#') buffer.append(line);
        }
        in.close();
        StringTokenizer tokens = new StringTokenizer(buffer.toString(), ";");
        Connection conn = null;
        try {
            conn = DatabaseConnection.getConnection();
            Statement st = conn.createStatement();
            while (tokens.hasMoreTokens()) {
                String token = tokens.nextToken();
                try {
                    st.executeUpdate(token);
                } catch (SQLException e) {
                    logger.log(Level.WARNING, "", e);
                }
            }
            st.close();
        } finally {
            DatabaseConnection.closeConnection(conn);
        }
    }
----------------------------------------
    private void createTables() throws Exception {
        String databaseType = Environment.getInstance().getDatabaseType();
        StringBuffer buffer = new StringBuffer();
        buffer.append("/create_");
        buffer.append(databaseType);
        buffer.append(".sql");
        String resourceName = buffer.toString();
        InputStream createScriptStream = getClass().getResourceAsStream(resourceName);
        if (createScriptStream == null) {
            logger.error("Can't find create script: " + resourceName);
        }
        BufferedReader in = new BufferedReader(new InputStreamReader(createScriptStream));
        buffer = new StringBuffer();
        while (true) {
            String line = in.readLine();
            if (line == null) {
                break;
            }
            buffer.append(line);
        }
        in.close();
        StringTokenizer tokens = new StringTokenizer(buffer.toString(), ";");
        Connection conn = null;
        try {
            conn = DatabaseConnection.getConnection();
            Statement st = conn.createStatement();
            while (tokens.hasMoreTokens()) {
                String token = tokens.nextToken();
                try {
                    st.executeUpdate(token);
                } catch (SQLException e) {
                    logger.warn(e);
                }
            }
            st.close();
        } finally {
            DatabaseConnection.closeConnection(conn);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,848052.java,313,349
selected,848052.java,313,349
----------------------------------------
    public static boolean zipListFileRecursiveOld(List<File> filesToZip, File zipFileName, String cutPrefix, String excludeRegEx, boolean compress) {
        try {
            byte[] buffer = new byte[18024];
            ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFileName));
            if (!compress) {
                out.setLevel(Deflater.NO_COMPRESSION);
            } else {
                out.setLevel(Deflater.DEFAULT_COMPRESSION);
            }
            for (int i = 0; i < filesToZip.size(); i++) {
                if (excludeRegEx == null || !filesToZip.get(i).getName().contains(excludeRegEx)) {
                    FileInputStream in = new FileInputStream(filesToZip.get(i));
                    String filePath = filesToZip.get(i).getPath();
                    filePath = filePath.substring(cutPrefix.length());
                    System.out.println("Deflating: " + filePath);
                    out.putNextEntry(new ZipEntry(filePath));
                    int len;
                    while ((len = in.read(buffer)) > 0) {
                        out.write(buffer, 0, len);
                    }
                    out.closeEntry();
                    in.close();
                }
            }
            out.close();
        } catch (IllegalArgumentException iae) {
            iae.printStackTrace();
            return (false);
        } catch (FileNotFoundException fnfe) {
            fnfe.printStackTrace();
            return (false);
        } catch (IOException ioe) {
            ioe.printStackTrace();
            return (false);
        }
        return (true);
    }
----------------------------------------
    public static boolean zipListFileRecursiveOld(List<File> filesToZip, File zipFileName, String cutPrefix, String excludeRegEx, boolean compress) {
        try {
            byte[] buffer = new byte[18024];
            ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFileName));
            if (!compress) {
                out.setLevel(Deflater.NO_COMPRESSION);
            } else {
                out.setLevel(Deflater.DEFAULT_COMPRESSION);
            }
            for (int i = 0; i < filesToZip.size(); i++) {
                if (excludeRegEx == null || !filesToZip.get(i).getName().contains(excludeRegEx)) {
                    FileInputStream in = new FileInputStream(filesToZip.get(i));
                    String filePath = filesToZip.get(i).getPath();
                    filePath = filePath.substring(cutPrefix.length());
                    System.out.println("Deflating: " + filePath);
                    out.putNextEntry(new ZipEntry(filePath));
                    int len;
                    while ((len = in.read(buffer)) > 0) {
                        out.write(buffer, 0, len);
                    }
                    out.closeEntry();
                    in.close();
                }
            }
            out.close();
        } catch (IllegalArgumentException iae) {
            iae.printStackTrace();
            return (false);
        } catch (FileNotFoundException fnfe) {
            fnfe.printStackTrace();
            return (false);
        } catch (IOException ioe) {
            ioe.printStackTrace();
            return (false);
        }
        return (true);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2012563.java,290,324
selected,2063502.java,445,481
----------------------------------------
    public static void benchmarkFloatTSVD_Periodic_3D(int threads) {
        ConcurrencyUtils.setNumberOfThreads(threads);
        Opener o = new Opener();
        ImagePlus blurImage = o.openImage(path + blur_image);
        ImagePlus psfImage = o.openImage(path + psf_image);
        double av_time_deblur = 0;
        double av_time_deblur_regParam = 0;
        double av_time_update = 0;
        long elapsedTime_deblur = 0;
        long elapsedTime_deblur_regParam = 0;
        long elapsedTime_update = 0;
        System.out.println("Benchmarking FloatTSVD_Periodic_3D using " + threads + " threads");
        for (int i = 0; i < NITER; i++) {
            elapsedTime_deblur = System.nanoTime();
            FloatPeriodicTruncatedSVD3D tsvd = new FloatPeriodicTruncatedSVD3D(blurImage, psfImage, resizing, output, false, -1, threshold);
            ImagePlus imX = tsvd.deconvolve();
            elapsedTime_deblur = System.nanoTime() - elapsedTime_deblur;
            av_time_deblur = av_time_deblur + elapsedTime_deblur;
            elapsedTime_deblur_regParam = System.nanoTime();
            tsvd = new FloatPeriodicTruncatedSVD3D(blurImage, psfImage, resizing, output, false, float_regParam_deblur, threshold);
            imX = tsvd.deconvolve();
            elapsedTime_deblur_regParam = System.nanoTime() - elapsedTime_deblur_regParam;
            av_time_deblur_regParam = av_time_deblur_regParam + elapsedTime_deblur_regParam;
            elapsedTime_update = System.nanoTime();
            tsvd.update(float_regParam_update, threshold, imX);
            elapsedTime_update = System.nanoTime() - elapsedTime_update;
            av_time_update = av_time_update + elapsedTime_update;
            imX = null;
            tsvd = null;
        }
        System.out.println("Average execution time (deblur()): " + String.format(format, av_time_deblur / 1000000000.0 / (double) NITER) + " sec");
        System.out.println("Average execution time (deblur(regParam)): " + String.format(format, av_time_deblur_regParam / 1000000000.0 / (double) NITER) + " sec");
        System.out.println("Average execution time (update()): " + String.format(format, av_time_update / 1000000000.0 / (double) NITER) + " sec");
        writeResultsToFile("FloatTSVD_Periodic_3D_" + threads + "_threads.txt", (double) av_time_deblur / 1000000000.0 / (double) NITER, (double) av_time_deblur_regParam / 1000000000.0 / (double) NITER, (double) av_time_update / 1000000000.0 / (double) NITER);
    }
----------------------------------------
    public static void benchmarkFloatGTikhonov_Periodic_2D(int threads) {
        ConcurrencyUtils.setNumberOfThreads(threads);
        Opener o = new Opener();
        ImagePlus blurImage = o.openImage(path + blur_image);
        ImagePlus psfImage = o.openImage(path + psf_image);
        double av_time_deblur = 0;
        double av_time_deblur_regParam = 0;
        double av_time_update = 0;
        long elapsedTime_deblur = 0;
        long elapsedTime_deblur_regParam = 0;
        long elapsedTime_update = 0;
        System.out.println("Benchmarking FloatGTikhonov_Periodic_2D using " + threads + " threads");
        for (int i = 0; i < NITER; i++) {
            elapsedTime_deblur = System.nanoTime();
            FloatPeriodicGeneralizedTikhonov2D tsvd = new FloatPeriodicGeneralizedTikhonov2D(blurImage, psfImage, floatStencil, resizing, output, false, -1, threshold);
            ImagePlus imX = tsvd.deconvolve();
            elapsedTime_deblur = System.nanoTime() - elapsedTime_deblur;
            av_time_deblur = av_time_deblur + elapsedTime_deblur;
            elapsedTime_deblur_regParam = System.nanoTime();
            tsvd = new FloatPeriodicGeneralizedTikhonov2D(blurImage, psfImage, floatStencil, resizing, output, false, float_regParam_deblur, threshold);
            imX = tsvd.deconvolve();
            elapsedTime_deblur_regParam = System.nanoTime() - elapsedTime_deblur_regParam;
            av_time_deblur_regParam = av_time_deblur_regParam + elapsedTime_deblur_regParam;
            elapsedTime_update = System.nanoTime();
            tsvd.update(float_regParam_update, threshold, imX);
            elapsedTime_update = System.nanoTime() - elapsedTime_update;
            av_time_update = av_time_update + elapsedTime_update;
            imX = null;
            tsvd = null;
        }
        blurImage = null;
        psfImage = null;
        System.out.println("Average execution time (deblur()): " + String.format(format, av_time_deblur / 1000000000.0 / (double) NITER) + " sec");
        System.out.println("Average execution time (deblur(regParam)): " + String.format(format, av_time_deblur_regParam / 1000000000.0 / (double) NITER) + " sec");
        System.out.println("Average execution time (update()): " + String.format(format, av_time_update / 1000000000.0 / (double) NITER) + " sec");
        writeResultsToFile("FloatGTikhonov_Periodic_2D_" + threads + "_threads.txt", (double) av_time_deblur / 1000000000.0 / (double) NITER, (double) av_time_deblur_regParam / 1000000000.0 / (double) NITER, (double) av_time_update / 1000000000.0 / (double) NITER);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,10720.java,484,517
default,120736.java,484,517
----------------------------------------
    void processLoopRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing var name in LOOP");
        String var_name = pst.nextToken();
        Vector valvec = new Vector();
        while (pst.hasMoreTokens()) {
            String v_i = pst.nextToken();
            int dotdot = v_i.indexOf("..");
            if (dotdot != -1 && dotdot == v_i.lastIndexOf("..")) {
                int start = Integer.parseInt(v_i.substring(0, dotdot));
                int end = Integer.parseInt(v_i.substring(dotdot + 2));
                for (int j = start; j <= end; j++) valvec.addElement(Integer.toString(j));
            } else valvec.addElement(v_i);
        }
        String[] values = new String[valvec.size()];
        for (int i = 0; i < values.length; i++) values[i] = (String) valvec.elementAt(i);
        if (DEBUG) System.out.println("doing loop with varname " + var_name + " on values :" + params.substring(var_name.length() + 1));
        for (int curValue = 0; curValue < values.length; curValue++) {
            for (int j = 1; j < region.size(); j++) {
                try {
                    String currentLine = (String) region.elementAt(j);
                    String result = substitute(currentLine, var_name + "." + indexField, Integer.toString(curValue));
                    result = substitute(result, var_name, values[curValue]);
                    out.print(result + "\n");
                } catch (ClassCastException e) {
                    Vector oldRegion = (Vector) region.elementAt(j);
                    Vector newRegion = substituteInRegion(oldRegion, var_name + "." + indexField, Integer.toString(curValue));
                    newRegion = substituteInRegion(newRegion, var_name, values[curValue]);
                    processTemplateRegion(newRegion);
                }
            }
        }
    }
----------------------------------------
    void processLoopRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing var name in LOOP");
        String var_name = pst.nextToken();
        Vector valvec = new Vector();
        while (pst.hasMoreTokens()) {
            String v_i = pst.nextToken();
            int dotdot = v_i.indexOf("..");
            if (dotdot != -1 && dotdot == v_i.lastIndexOf("..")) {
                int start = Integer.parseInt(v_i.substring(0, dotdot));
                int end = Integer.parseInt(v_i.substring(dotdot + 2));
                for (int j = start; j <= end; j++) valvec.addElement(Integer.toString(j));
            } else valvec.addElement(v_i);
        }
        String[] values = new String[valvec.size()];
        for (int i = 0; i < values.length; i++) values[i] = (String) valvec.elementAt(i);
        if (DEBUG) System.out.println("doing loop with varname " + var_name + " on values :" + params.substring(var_name.length() + 1));
        for (int curValue = 0; curValue < values.length; curValue++) {
            for (int j = 1; j < region.size(); j++) {
                try {
                    String currentLine = (String) region.elementAt(j);
                    String result = substitute(currentLine, var_name + "." + indexField, Integer.toString(curValue));
                    result = substitute(result, var_name, values[curValue]);
                    out.print(result + "\n");
                } catch (ClassCastException e) {
                    Vector oldRegion = (Vector) region.elementAt(j);
                    Vector newRegion = substituteInRegion(oldRegion, var_name + "." + indexField, Integer.toString(curValue));
                    newRegion = substituteInRegion(newRegion, var_name, values[curValue]);
                    processTemplateRegion(newRegion);
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,50301.java,18,55
default,97964.java,18,55
----------------------------------------
    public int addPedido(Pedido pe) throws errorConexionBD, errorSQL {
        System.out.println("GestorPedido.addPedido()");
        String sql;
        PreparedStatement pstmt = null;
        Statement stmt = null;
        ResultSet rs = null;
        int nuevoId = 0;
        try {
            gd.begin();
            sql = "INSERT INTO pedido(id_cliente, id_promocion, id_producto, " + "importe, fecha) VALUES (?, ?, ?, ?, ?) RETURNING id";
            System.out.println("Ejecuando: " + sql);
            pstmt = gd.getConexion().prepareStatement(sql);
            pstmt.setInt(1, pe.getIdCliente());
            pstmt.setInt(2, pe.getIdPromocion());
            pstmt.setInt(3, pe.getIdProducto());
            pstmt.setFloat(4, pe.getImporte());
            if (pe.getFecha() != null) {
                pstmt.setDate(5, new java.sql.Date(pe.getFecha().getTime()));
            } else {
                pstmt.setNull(5, Types.DATE);
            }
            rs = pstmt.executeQuery();
            System.out.println("Devolviendo el nuevo ID");
            if (rs.next()) {
                nuevoId = rs.getInt(1);
                System.out.println("Nuevo id: " + nuevoId);
            }
            gd.commit();
            System.out.println("commit");
            pstmt.close();
            rs.close();
            return nuevoId;
        } catch (SQLException e) {
            System.err.println("Error en GestorPedido.addPedido()");
            gd.rollback();
            throw new errorSQL(e.toString());
        }
    }
----------------------------------------
    public int addPedido(Pedido pe) throws errorConexionBD, errorSQL {
        System.out.println("GestorPedido.addPedido()");
        String sql;
        PreparedStatement pstmt = null;
        Statement stmt = null;
        ResultSet rs = null;
        int nuevoId = 0;
        try {
            gd.begin();
            sql = "INSERT INTO pedido(id_cliente, id_promocion, id_producto, " + "importe, fecha) VALUES (?, ?, ?, ?, ?) RETURNING id";
            System.out.println("Ejecuando: " + sql);
            pstmt = gd.getConexion().prepareStatement(sql);
            pstmt.setInt(1, pe.getIdCliente());
            pstmt.setInt(2, pe.getIdPromocion());
            pstmt.setInt(3, pe.getIdProducto());
            pstmt.setFloat(4, pe.getImporte());
            if (pe.getFecha() != null) {
                pstmt.setDate(5, new java.sql.Date(pe.getFecha().getTime()));
            } else {
                pstmt.setNull(5, Types.DATE);
            }
            rs = pstmt.executeQuery();
            System.out.println("Devolviendo el nuevo ID");
            if (rs.next()) {
                nuevoId = rs.getInt(1);
                System.out.println("Nuevo id: " + nuevoId);
            }
            gd.commit();
            System.out.println("commit");
            pstmt.close();
            rs.close();
            return nuevoId;
        } catch (SQLException e) {
            System.err.println("Error en GestorPedido.addPedido()");
            gd.rollback();
            throw new errorSQL(e.toString());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2427414.java,478,515
selected,46027.java,362,397
----------------------------------------
        private void sendResponse(String status, String mime, Properties header, String payload) {
            InputStream data = new ByteArrayInputStream(payload.getBytes());
            try {
                if (status == null) throw new Error("sendResponse(): Status can't be null.");
                OutputStream out = mySocket.getOutputStream();
                PrintWriter pw = new PrintWriter(out);
                pw.print("HTTP/1.0 " + status + " \r\n");
                if (mime != null) pw.print("Content-Type: " + mime + "\r\n");
                if (header == null || header.getProperty("Date") == null) pw.print("Date: " + gmtFrmt.format(new Date()) + "\r\n");
                if (header != null) {
                    Enumeration e = header.keys();
                    while (e.hasMoreElements()) {
                        String key = (String) e.nextElement();
                        String value = header.getProperty(key);
                        pw.print(key + ": " + value + "\r\n");
                    }
                }
                pw.print("\r\n");
                pw.flush();
                if (data != null) {
                    byte[] buff = new byte[2048];
                    int read = 2048;
                    while (read == 2048) {
                        read = data.read(buff, 0, 2048);
                        out.write((byte[]) buff, 0, read);
                    }
                }
                out.flush();
                out.close();
                if (data != null) data.close();
            } catch (IOException ioe) {
                logger.debug("Could not write on socket");
                try {
                    mySocket.close();
                } catch (Throwable t) {
                }
            }
        }
----------------------------------------
        private void sendResponse(String status, String mime, Properties header, InputStream data) {
            try {
                if (status == null) throw new Error("sendResponse(): Status can't be null.");
                OutputStream out = mySocket.getOutputStream();
                PrintWriter pw = new PrintWriter(out);
                pw.print("HTTP/1.0 " + status + " \r\n");
                if (mime != null) pw.print("Content-Type: " + mime + "\r\n");
                if (header == null || header.getProperty("Date") == null) pw.print("Date: " + gmtFrmt.format(new Date()) + "\r\n");
                if (header != null) {
                    Enumeration e = header.keys();
                    while (e.hasMoreElements()) {
                        String key = (String) e.nextElement();
                        String value = header.getProperty(key);
                        pw.print(key + ": " + value + "\r\n");
                    }
                }
                pw.print("\r\n");
                pw.flush();
                if (data != null) {
                    byte[] buff = new byte[2048];
                    while (true) {
                        int read = data.read(buff, 0, 2048);
                        if (read <= 0) break;
                        out.write(buff, 0, read);
                    }
                }
                out.flush();
                out.close();
                if (data != null) data.close();
            } catch (IOException ioe) {
                try {
                    mySocket.close();
                } catch (Throwable t) {
                }
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2650687.java,41,75
selected,1967125.java,41,77
----------------------------------------
    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Error: " + e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            System.out.println("Error:" + e);
        }
    }
----------------------------------------
    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Error: " + e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) {
                    sb.append('0');
                }
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            System.out.println("Error:" + e);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24353.java,484,517
default,109831.java,484,517
----------------------------------------
    void processLoopRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing var name in LOOP");
        String var_name = pst.nextToken();
        Vector valvec = new Vector();
        while (pst.hasMoreTokens()) {
            String v_i = pst.nextToken();
            int dotdot = v_i.indexOf("..");
            if (dotdot != -1 && dotdot == v_i.lastIndexOf("..")) {
                int start = Integer.parseInt(v_i.substring(0, dotdot));
                int end = Integer.parseInt(v_i.substring(dotdot + 2));
                for (int j = start; j <= end; j++) valvec.addElement(Integer.toString(j));
            } else valvec.addElement(v_i);
        }
        String[] values = new String[valvec.size()];
        for (int i = 0; i < values.length; i++) values[i] = (String) valvec.elementAt(i);
        if (DEBUG) System.out.println("doing loop with varname " + var_name + " on values :" + params.substring(var_name.length() + 1));
        for (int curValue = 0; curValue < values.length; curValue++) {
            for (int j = 1; j < region.size(); j++) {
                try {
                    String currentLine = (String) region.elementAt(j);
                    String result = substitute(currentLine, var_name + "." + indexField, Integer.toString(curValue));
                    result = substitute(result, var_name, values[curValue]);
                    out.print(result + "\n");
                } catch (ClassCastException e) {
                    Vector oldRegion = (Vector) region.elementAt(j);
                    Vector newRegion = substituteInRegion(oldRegion, var_name + "." + indexField, Integer.toString(curValue));
                    newRegion = substituteInRegion(newRegion, var_name, values[curValue]);
                    processTemplateRegion(newRegion);
                }
            }
        }
    }
----------------------------------------
    void processLoopRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing var name in LOOP");
        String var_name = pst.nextToken();
        Vector valvec = new Vector();
        while (pst.hasMoreTokens()) {
            String v_i = pst.nextToken();
            int dotdot = v_i.indexOf("..");
            if (dotdot != -1 && dotdot == v_i.lastIndexOf("..")) {
                int start = Integer.parseInt(v_i.substring(0, dotdot));
                int end = Integer.parseInt(v_i.substring(dotdot + 2));
                for (int j = start; j <= end; j++) valvec.addElement(Integer.toString(j));
            } else valvec.addElement(v_i);
        }
        String[] values = new String[valvec.size()];
        for (int i = 0; i < values.length; i++) values[i] = (String) valvec.elementAt(i);
        if (DEBUG) System.out.println("doing loop with varname " + var_name + " on values :" + params.substring(var_name.length() + 1));
        for (int curValue = 0; curValue < values.length; curValue++) {
            for (int j = 1; j < region.size(); j++) {
                try {
                    String currentLine = (String) region.elementAt(j);
                    String result = substitute(currentLine, var_name + "." + indexField, Integer.toString(curValue));
                    result = substitute(result, var_name, values[curValue]);
                    out.print(result + "\n");
                } catch (ClassCastException e) {
                    Vector oldRegion = (Vector) region.elementAt(j);
                    Vector newRegion = substituteInRegion(oldRegion, var_name + "." + indexField, Integer.toString(curValue));
                    newRegion = substituteInRegion(newRegion, var_name, values[curValue]);
                    processTemplateRegion(newRegion);
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45048.java,328,366
default,37347.java,322,360
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,37347.java,422,457
default,36934.java,426,461
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109003.java,322,360
default,31509.java,328,366
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19383.java,309,347
default,94357.java,306,344
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file, Dataset mergeDataset) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, merge(ds, mergeDataset));
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94169.java,306,344
default,103538.java,306,344
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43630.java,406,441
default,11974.java,406,441
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88095.java,306,344
default,135544.java,322,360
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53763.java,422,457
default,74245.java,406,441
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88374.java,322,360
default,36204.java,306,344
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,135544.java,322,360
default,50607.java,309,347
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file, Dataset mergeDataset) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, merge(ds, mergeDataset));
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,118736.java,306,344
default,26187.java,306,344
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23401.java,306,344
default,132272.java,306,344
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2638026.java,1295,1330
selected,2037579.java,1295,1330
----------------------------------------
    protected Pool loadTransitionMatricesBinary(String path) throws FileNotFoundException, IOException {
        logger.fine("Loading transition matrices from: " + path);
        int numMatrices;
        int numStates;
        int numRows;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(TMAT_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numMatrices = readInt(dis);
        numRows = readInt(dis);
        numStates = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numRows * numMatrices;
        for (int i = 0; i < numMatrices; i++) {
            float[][] tmat = new float[numStates][];
            tmat[numStates - 1] = new float[numStates];
            convertToLogMath(tmat[numStates - 1]);
            for (int j = 0; j < numRows; j++) {
                tmat[j] = readFloatArray(dis, numStates);
                nonZeroFloor(tmat[j], 0.00001f);
                normalize(tmat[j]);
                convertToLogMath(tmat[j]);
            }
            pool.put(i, tmat);
        }
        dis.close();
        return pool;
    }
----------------------------------------
    protected Pool loadTransitionMatricesBinary(String path) throws FileNotFoundException, IOException {
        logger.fine("Loading transition matrices from: " + path);
        int numMatrices;
        int numStates;
        int numRows;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(TMAT_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numMatrices = readInt(dis);
        numRows = readInt(dis);
        numStates = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numRows * numMatrices;
        for (int i = 0; i < numMatrices; i++) {
            float[][] tmat = new float[numStates][];
            tmat[numStates - 1] = new float[numStates];
            convertToLogMath(tmat[numStates - 1]);
            for (int j = 0; j < numRows; j++) {
                tmat[j] = readFloatArray(dis, numStates);
                nonZeroFloor(tmat[j], 0.00001f);
                normalize(tmat[j]);
                convertToLogMath(tmat[j]);
            }
            pool.put(i, tmat);
        }
        dis.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,67537.java,413,448
default,2085.java,422,457
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,67537.java,413,448
default,79290.java,400,435
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2638026.java,1295,1330
selected,2037579.java,1195,1229
----------------------------------------
    protected Pool loadTransitionMatricesBinary(String path) throws FileNotFoundException, IOException {
        logger.fine("Loading transition matrices from: " + path);
        int numMatrices;
        int numStates;
        int numRows;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(TMAT_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numMatrices = readInt(dis);
        numRows = readInt(dis);
        numStates = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numRows * numMatrices;
        for (int i = 0; i < numMatrices; i++) {
            float[][] tmat = new float[numStates][];
            tmat[numStates - 1] = new float[numStates];
            convertToLogMath(tmat[numStates - 1]);
            for (int j = 0; j < numRows; j++) {
                tmat[j] = readFloatArray(dis, numStates);
                nonZeroFloor(tmat[j], 0.00001f);
                normalize(tmat[j]);
                convertToLogMath(tmat[j]);
            }
            pool.put(i, tmat);
        }
        dis.close();
        return pool;
    }
----------------------------------------
    private Pool loadMixtureWeightsBinary(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(MIXW_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numStreams * numGaussiansPerState;
        assert numStreams == 1;
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            float[] logMixtureWeight = readFloatArray(dis, numGaussiansPerState);
            nonZeroFloor(logMixtureWeight, floor);
            normalize(logMixtureWeight);
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        dis.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2128909.java,48,82
selected,892708.java,143,179
----------------------------------------
    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            logger.error("At RandomGUID !!!", e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            logger.error("At RandomGUID !!!", e);
        }
    }
----------------------------------------
    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            log.error(e.getMessage());
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) {
                    sb.append('0');
                }
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            log.error(e.getMessage());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28755.java,683,718
default,85984.java,732,766
----------------------------------------
    static Object[] packageParameterFromJValue(VM_Method targetMethod, int argAddress) {
        VM_Type[] argTypes = targetMethod.getParameterTypes();
        int argCount = argTypes.length;
        Object[] argObjectArray = new Object[argCount];
        VM_JNIEnvironment env = VM_Thread.getCurrentThread().getJNIEnv();
        for (int i = 0, addr = argAddress; i < argCount; i++, addr += 8) {
            int loword, hiword;
            loword = VM_Magic.getMemoryWord(addr);
            if (argTypes[i].isFloatType()) {
                argObjectArray[i] = VM_Reflection.wrapFloat(Float.intBitsToFloat(loword));
            } else if (argTypes[i].isDoubleType()) {
                hiword = VM_Magic.getMemoryWord(addr + 4);
                long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapDouble(Double.longBitsToDouble(doubleBits));
            } else if (argTypes[i].isLongType()) {
                hiword = VM_Magic.getMemoryWord(addr + 4);
                long longValue = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapLong(longValue);
            } else if (argTypes[i].isBooleanType()) {
                argObjectArray[i] = VM_Reflection.wrapBoolean(loword & 0x000000FF);
            } else if (argTypes[i].isByteType()) {
                argObjectArray[i] = VM_Reflection.wrapByte((byte) (loword & 0x000000FF));
            } else if (argTypes[i].isCharType()) {
                argObjectArray[i] = VM_Reflection.wrapChar((char) (loword & 0x0000FFFF));
            } else if (argTypes[i].isShortType()) {
                argObjectArray[i] = VM_Reflection.wrapShort((short) (loword & 0x0000FFFF));
            } else if (argTypes[i].isReferenceType()) {
                argObjectArray[i] = env.getJNIRef(loword);
            } else if (argTypes[i].isIntType()) {
                argObjectArray[i] = VM_Reflection.wrapInt(loword);
            } else {
                return null;
            }
        }
        return argObjectArray;
    }
----------------------------------------
    static Object[] packageParameterFromJValue(VM_Method targetMethod, VM_Address argAddress) {
        VM_Type[] argTypes = targetMethod.getParameterTypes();
        int argCount = argTypes.length;
        Object[] argObjectArray = new Object[argCount];
        VM_JNIEnvironment env = VM_Thread.getCurrentThread().getJNIEnv();
        for (int i = 0; i < argCount; i++) {
            VM_Address addr = argAddress.add(8 * i);
            int hiword = VM_Magic.getMemoryWord(addr);
            int loword = VM_Magic.getMemoryWord(addr.add(4));
            if (argTypes[i].isFloatType()) {
                argObjectArray[i] = VM_Reflection.wrapFloat(Float.intBitsToFloat(hiword));
            } else if (argTypes[i].isDoubleType()) {
                long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapDouble(Double.longBitsToDouble(doubleBits));
            } else if (argTypes[i].isLongType()) {
                long longValue = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
                argObjectArray[i] = VM_Reflection.wrapLong(longValue);
            } else if (argTypes[i].isBooleanType()) {
                argObjectArray[i] = VM_Reflection.wrapBoolean((hiword & 0xFF000000) >>> 24);
            } else if (argTypes[i].isByteType()) {
                argObjectArray[i] = VM_Reflection.wrapByte((byte) ((hiword & 0xFF000000) >>> 24));
            } else if (argTypes[i].isCharType()) {
                argObjectArray[i] = VM_Reflection.wrapChar((char) ((hiword & 0xFFFF0000) >>> 16));
            } else if (argTypes[i].isShortType()) {
                argObjectArray[i] = VM_Reflection.wrapShort((short) ((hiword & 0xFFFF0000) >>> 16));
            } else if (argTypes[i].isReferenceType()) {
                argObjectArray[i] = env.getJNIRef(hiword);
            } else if (argTypes[i].isIntType()) {
                argObjectArray[i] = VM_Reflection.wrapInt(hiword);
            } else {
                return null;
            }
        }
        return argObjectArray;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1728841.java,120,154
selected,1728841.java,208,244
----------------------------------------
    public void createDocument(String documentId, String templateId, int state) {
        logger.debug("createDocument(%s, %s, %s)", documentId, templateId, String.valueOf(state));
        Connection connection = null;
        NamedParameterStatement statement = null;
        try {
            connection = this.dataSource.getConnection();
            connection.setAutoCommit(false);
            statement = new NamedParameterStatement(connection, this.queryStore.get(QueryStore.INSERT_DOCUMENT));
            statement.setString(QueryStore.INSERT_DOCUMENT_PARAM_ID, documentId);
            statement.setString(QueryStore.INSERT_DOCUMENT_PARAM_ID_TEMPLATE, templateId);
            statement.setInt(QueryStore.INSERT_DOCUMENT_PARAM_STATE, state);
            statement.executeUpdate();
            statement.close();
            statement = null;
            statement = new NamedParameterStatement(connection, queryStore.get(QueryStore.CREATE_DOCUMENT_DATA_FROM_TEMPLATE));
            statement.setString(QueryStore.CREATE_DOCUMENT_DATA_FROM_TEMPLATE_PARAM_ID_DOCUMENT, documentId);
            statement.executeUpdate();
            statement.close();
            statement = null;
            connection.commit();
        } catch (SQLException e) {
            logger.error(e.getMessage(), e);
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException ex) {
                logger.error(e.getMessage(), e);
            }
            throw new ApplicationException(e.getMessage());
        } finally {
            close(statement);
            close(connection);
        }
    }
----------------------------------------
    public void removeDocument(String documentId) {
        logger.debug("removeDocument(%s)", documentId);
        Connection connection = null;
        NamedParameterStatement statement = null;
        try {
            connection = this.dataSource.getConnection();
            connection.setAutoCommit(false);
            statement = new NamedParameterStatement(connection, this.queryStore.get(QueryStore.DELETE_DOCUMENT_PREVIEW_DATA));
            statement.setString(QueryStore.DELETE_DOCUMENT_PREVIEW_DATA_PARAM_ID_DOCUMENT, documentId);
            statement.executeUpdate();
            statement.close();
            statement = null;
            statement = new NamedParameterStatement(connection, this.queryStore.get(QueryStore.DELETE_DOCUMENT_DATA));
            statement.setString(QueryStore.DELETE_DOCUMENT_DATA_ID_DOCUMENT, documentId);
            statement.executeUpdate();
            statement.close();
            statement = null;
            statement = new NamedParameterStatement(connection, this.queryStore.get(QueryStore.DELETE_DOCUMENT));
            statement.setString(QueryStore.DELETE_DOCUMENT_ID_DOCUMENT, documentId);
            statement.executeUpdate();
            statement.close();
            statement = null;
            connection.commit();
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                logger.error(e.getMessage(), e1);
            }
        } finally {
            close(statement);
            close(connection);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,85902.java,346,382
default,79324.java,167,197
----------------------------------------
    public void serveTCP(short port) {
        try {
            ServerSocket sock = new ServerSocket(port);
            while (true) {
                Socket s = sock.accept();
                int inLength;
                DataInputStream dataIn;
                DataOutputStream dataOut;
                byte[] in;
                try {
                    InputStream is = s.getInputStream();
                    dataIn = new DataInputStream(is);
                    inLength = dataIn.readUnsignedShort();
                    in = new byte[inLength];
                    dataIn.readFully(in);
                } catch (InterruptedIOException e) {
                    s.close();
                    continue;
                }
                Message query, response;
                try {
                    query = new Message(in);
                    response = generateReply(query, in, s);
                    if (response == null) continue;
                } catch (IOException e) {
                    response = formerrMessage(in);
                }
                byte[] out = response.toWire();
                dataOut = new DataOutputStream(s.getOutputStream());
                dataOut.writeShort(out.length);
                dataOut.write(out);
                s.close();
            }
        } catch (IOException e) {
            System.out.println("serveTCP: " + e);
        }
    }
----------------------------------------
    public void serveTCP(short port) {
        try {
            ServerSocket sock = new ServerSocket(port);
            while (true) {
                Socket s = sock.accept();
                int inLength;
                DataInputStream dataIn;
                DataOutputStream dataOut;
                byte[] in;
                try {
                    InputStream is = s.getInputStream();
                    dataIn = new DataInputStream(is);
                    inLength = dataIn.readUnsignedShort();
                    in = new byte[inLength];
                    dataIn.readFully(in);
                } catch (InterruptedIOException e) {
                    s.close();
                    continue;
                }
                Message query = new Message(in);
                Message response = generateReply(query);
                byte[] out = response.toWire();
                dataOut = new DataOutputStream(s.getOutputStream());
                dataOut.writeShort(out.length);
                dataOut.write(out);
                s.close();
            }
        } catch (IOException e) {
            System.out.println("serveTCP: " + e);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,71420.java,1183,1217
default,16051.java,739,773
----------------------------------------
    public String _align(String rText, String rBackText, int rColWidth, char rAlignment) {
        String result = rText;
        if (null == rText) {
            result = "";
        } else if (null != rBackText) {
            try {
                int textLen = rText.length();
                if (rColWidth > textLen) {
                    int backTextLen = rBackText.length();
                    int remainWidth = rColWidth - textLen;
                    int backTextRepeats = remainWidth / backTextLen;
                    int backTextRemain = remainWidth % backTextLen;
                    String back = "";
                    for (int backTextI = 0; backTextI < backTextRepeats; backTextI++) {
                        back = back + rBackText;
                    }
                    back = back + rBackText.substring(0, backTextRemain);
                    switch(rAlignment) {
                        case 'l':
                            result = result + back;
                            break;
                        case 'c':
                            result = back.substring(0, (back.length() / 2)) + result + back.substring((back.length() / 2));
                            break;
                        case 'r':
                            result = back + result;
                            break;
                    }
                }
            } catch (Exception e) {
                result = rText;
            }
        }
        return result;
    }
----------------------------------------
    public String _align(String rText, String rBackText, int rColWidth, char rAlignment) {
        String result = rText;
        if (null == rText) {
            result = "";
        } else if (null != rBackText) {
            try {
                int textLen = rText.length();
                if (rColWidth > textLen) {
                    int backTextLen = rBackText.length();
                    int remainWidth = rColWidth - textLen;
                    int backTextRepeats = remainWidth / backTextLen;
                    int backTextRemain = remainWidth % backTextLen;
                    String back = "";
                    for (int backTextI = 0; backTextI < backTextRepeats; backTextI++) {
                        back = back + rBackText;
                    }
                    back = back + rBackText.substring(0, backTextRemain);
                    switch(rAlignment) {
                        case 'l':
                            result = result + back;
                            break;
                        case 'c':
                            result = back.substring(0, (back.length() / 2)) + result + back.substring((back.length() / 2));
                            break;
                        case 'r':
                            result = back + result;
                            break;
                    }
                }
            } catch (Exception e) {
                result = rText;
            }
        }
        return result;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,293333.java,72,107
selected,1568102.java,73,108
----------------------------------------
    public static void copyFile(IPath fromFileName, IPath toFileName) throws IOException {
        File fromFile = fromFileName.toFile();
        File toFile = toFileName.toFile();
        if (!fromFile.exists()) throw new IOException("FileCopy: " + "no such source file: " + fromFileName);
        if (!fromFile.isFile()) throw new IOException("FileCopy: " + "can't copy directory: " + fromFileName);
        if (!fromFile.canRead()) throw new IOException("FileCopy: " + "source file is unreadable: " + fromFileName);
        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());
        if (toFile.exists()) {
            if (!toFile.canWrite()) throw new IOException("FileCopy: " + "destination file is unwriteable: " + toFileName);
        } else {
            String parent = toFile.getParent();
            if (parent == null) parent = System.getProperty("user.dir");
            File dir = new File(parent);
            if (!dir.exists()) throw new IOException("FileCopy: " + "destination directory doesn't exist: " + parent);
            if (dir.isFile()) throw new IOException("FileCopy: " + "destination is not a directory: " + parent);
            if (!dir.canWrite()) throw new IOException("FileCopy: " + "destination directory is unwriteable: " + parent);
        }
        InputStream from = null;
        OutputStream to = null;
        try {
            from = new BufferedInputStream(new FileInputStream(fromFile));
            to = new BufferedOutputStream(new FileOutputStream(toFile));
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
            }
        }
    }
----------------------------------------
    public static void copyFile(IPath fromFileName, IPath toFileName) throws IOException {
        File fromFile = fromFileName.toFile();
        File toFile = toFileName.toFile();
        if (!fromFile.exists()) throw new IOException("FileCopy: " + "no such source file: " + fromFileName);
        if (!fromFile.isFile()) throw new IOException("FileCopy: " + "can't copy directory: " + fromFileName);
        if (!fromFile.canRead()) throw new IOException("FileCopy: " + "source file is unreadable: " + fromFileName);
        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());
        if (toFile.exists()) {
            if (!toFile.canWrite()) throw new IOException("FileCopy: " + "destination file is unwriteable: " + toFileName);
        } else {
            String parent = toFile.getParent();
            if (parent == null) parent = System.getProperty("user.dir");
            File dir = new File(parent);
            if (!dir.exists()) throw new IOException("FileCopy: " + "destination directory doesn't exist: " + parent);
            if (dir.isFile()) throw new IOException("FileCopy: " + "destination is not a directory: " + parent);
            if (!dir.canWrite()) throw new IOException("FileCopy: " + "destination directory is unwriteable: " + parent);
        }
        InputStream from = null;
        OutputStream to = null;
        try {
            from = new BufferedInputStream(new FileInputStream(fromFile));
            to = new BufferedOutputStream(new FileOutputStream(toFile));
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1272321.java,209,242
selected,2171280.java,176,209
----------------------------------------
    public static void benchmarkRealForward_2D_input_2D(int init_exp) {
        int[] sizes = new int[nsize];
        double[] times = new double[nsize];
        float[][] x;
        for (int i = 0; i < nsize; i++) {
            int exponent = init_exp + i;
            int N = (int) Math.pow(2, exponent);
            sizes[i] = N;
            System.out.println("Real forward FFT 2D (input 2D) of size 2^" + exponent + " x 2^" + exponent);
            FloatFft2D fft2 = new FloatFft2D(N, N);
            x = new float[N][2 * N];
            if (doWarmup) {
                IoUtils.fillMatrix_2D(N, N, x);
                fft2.realForwardFull(x);
                IoUtils.fillMatrix_2D(N, N, x);
                fft2.realForwardFull(x);
            }
            float av_time = 0;
            long elapsedTime = 0;
            for (int j = 0; j < niter; j++) {
                IoUtils.fillMatrix_2D(N, N, x);
                elapsedTime = System.nanoTime();
                fft2.realForwardFull(x);
                elapsedTime = System.nanoTime() - elapsedTime;
                av_time = av_time + elapsedTime;
            }
            times[i] = (double) av_time / 1000000.0 / (double) niter;
            System.out.println("\tAverage execution time: " + String.format("%.2f", av_time / 1000000.0 / (float) niter) + " msec");
            x = null;
            fft2 = null;
            System.gc();
        }
        IoUtils.writeFFTBenchmarkResultsToFile("benchmarkFloatRealForwardFFT_2D_input_2D.txt", nthread, niter, doWarmup, doScaling, sizes, times);
    }
----------------------------------------
    public static void benchmarkForward_3D_input_3D(int init_exp) {
        int[] sizes = new int[nsize];
        double[] times = new double[nsize];
        float[][][] x;
        for (int i = 0; i < nsize; i++) {
            int exponent = init_exp + i;
            int N = (int) Math.pow(2, exponent);
            sizes[i] = N;
            System.out.println("Forward DST 3D (input 3D) of size 2^" + exponent + " x 2^" + exponent + " x 2^" + exponent);
            FloatDst3D dst3 = new FloatDst3D(N, N, N);
            x = new float[N][N][N];
            if (doWarmup) {
                IoUtils.fillMatrix_3D(N, N, N, x);
                dst3.forward(x, false);
                IoUtils.fillMatrix_3D(N, N, N, x);
                dst3.forward(x, false);
            }
            float av_time = 0;
            long elapsedTime = 0;
            for (int j = 0; j < niter; j++) {
                IoUtils.fillMatrix_3D(N, N, N, x);
                elapsedTime = System.nanoTime();
                dst3.forward(x, false);
                elapsedTime = System.nanoTime() - elapsedTime;
                av_time = av_time + elapsedTime;
            }
            times[i] = (double) av_time / 1000000.0 / (double) niter;
            System.out.println("Average execution time: " + String.format("%.2f", av_time / 1000000.0 / (float) niter) + " msec");
            x = null;
            dst3 = null;
            System.gc();
        }
        IoUtils.writeFFTBenchmarkResultsToFile("benchmarkFloatForwardDST_3D_input_3D.txt", nthread, niter, doWarmup, doScaling, sizes, times);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1778922.java,1237,1271
selected,656204.java,1237,1271
----------------------------------------
    private Pool loadMixtureWeightsBinary(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(MIXW_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numStreams * numGaussiansPerState;
        assert numStreams == 1;
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            float[] logMixtureWeight = readFloatArray(dis, numGaussiansPerState);
            nonZeroFloor(logMixtureWeight, floor);
            normalize(logMixtureWeight);
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        dis.close();
        return pool;
    }
----------------------------------------
    private Pool loadMixtureWeightsBinary(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(MIXW_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numStreams * numGaussiansPerState;
        assert numStreams == 1;
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            float[] logMixtureWeight = readFloatArray(dis, numGaussiansPerState);
            nonZeroFloor(logMixtureWeight, floor);
            normalize(logMixtureWeight);
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        dis.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1465010.java,306,338
selected,1161059.java,596,631
----------------------------------------
    private boolean _jspx_meth_html_005flink_005f2(javax.servlet.jsp.tagext.JspTag _jspx_th_html_005fform_005f0, PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.struts.taglib.html.LinkTag _jspx_th_html_005flink_005f2 = (org.apache.struts.taglib.html.LinkTag) _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fstyleClass_005fonclick_005fhref.get(org.apache.struts.taglib.html.LinkTag.class);
        _jspx_th_html_005flink_005f2.setPageContext(_jspx_page_context);
        _jspx_th_html_005flink_005f2.setParent((javax.servlet.jsp.tagext.Tag) _jspx_th_html_005fform_005f0);
        _jspx_th_html_005flink_005f2.setStyleId("linkGerar");
        _jspx_th_html_005flink_005f2.setHref("#");
        _jspx_th_html_005flink_005f2.setOnclick("submeter2()");
        _jspx_th_html_005flink_005f2.setStyleClass("botao");
        int _jspx_eval_html_005flink_005f2 = _jspx_th_html_005flink_005f2.doStartTag();
        if (_jspx_eval_html_005flink_005f2 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_html_005flink_005f2 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_html_005flink_005f2.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_html_005flink_005f2.doInitBody();
            }
            do {
                out.write("Aplicar Script");
                int evalDoAfterBody = _jspx_th_html_005flink_005f2.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_html_005flink_005f2 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_html_005flink_005f2.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fstyleClass_005fonclick_005fhref.reuse(_jspx_th_html_005flink_005f2);
            return true;
        }
        _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fstyleClass_005fonclick_005fhref.reuse(_jspx_th_html_005flink_005f2);
        return false;
    }
----------------------------------------
    private boolean _jspx_meth_html_005fselect_005f0(javax.servlet.jsp.tagext.JspTag _jspx_th_html_005fform_005f0, PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.struts.taglib.html.SelectTag _jspx_th_html_005fselect_005f0 = (org.apache.struts.taglib.html.SelectTag) _005fjspx_005ftagPool_005fhtml_005fselect_005fstyleId_005fstyleClass_005fproperty.get(org.apache.struts.taglib.html.SelectTag.class);
        _jspx_th_html_005fselect_005f0.setPageContext(_jspx_page_context);
        _jspx_th_html_005fselect_005f0.setParent((javax.servlet.jsp.tagext.Tag) _jspx_th_html_005fform_005f0);
        _jspx_th_html_005fselect_005f0.setProperty("tipoRecibo");
        _jspx_th_html_005fselect_005f0.setStyleId("tipoRecibo");
        _jspx_th_html_005fselect_005f0.setStyleClass("campo");
        int _jspx_eval_html_005fselect_005f0 = _jspx_th_html_005fselect_005f0.doStartTag();
        if (_jspx_eval_html_005fselect_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_html_005fselect_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_html_005fselect_005f0.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_html_005fselect_005f0.doInitBody();
            }
            do {
                out.write("\r\n");
                out.write("\t\t\t\t");
                if (_jspx_meth_html_005foptionsCollection_005f0(_jspx_th_html_005fselect_005f0, _jspx_page_context)) return true;
                out.write("\r\n");
                out.write("\t\t");
                int evalDoAfterBody = _jspx_th_html_005fselect_005f0.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_html_005fselect_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_html_005fselect_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fhtml_005fselect_005fstyleId_005fstyleClass_005fproperty.reuse(_jspx_th_html_005fselect_005f0);
            return true;
        }
        _005fjspx_005ftagPool_005fhtml_005fselect_005fstyleId_005fstyleClass_005fproperty.reuse(_jspx_th_html_005fselect_005f0);
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132935.java,1183,1217
default,10101.java,913,947
----------------------------------------
    public String _align(String rText, String rBackText, int rColWidth, char rAlignment) {
        String result = rText;
        if (null == rText) {
            result = "";
        } else if (null != rBackText) {
            try {
                int textLen = rText.length();
                if (rColWidth > textLen) {
                    int backTextLen = rBackText.length();
                    int remainWidth = rColWidth - textLen;
                    int backTextRepeats = remainWidth / backTextLen;
                    int backTextRemain = remainWidth % backTextLen;
                    String back = "";
                    for (int backTextI = 0; backTextI < backTextRepeats; backTextI++) {
                        back = back + rBackText;
                    }
                    back = back + rBackText.substring(0, backTextRemain);
                    switch(rAlignment) {
                        case 'l':
                            result = result + back;
                            break;
                        case 'c':
                            result = back.substring(0, (back.length() / 2)) + result + back.substring((back.length() / 2));
                            break;
                        case 'r':
                            result = back + result;
                            break;
                    }
                }
            } catch (Exception e) {
                result = rText;
            }
        }
        return result;
    }
----------------------------------------
    public String _align(String rText, String rBackText, int rColWidth, char rAlignment) {
        String result = rText;
        if (null == rText) {
            result = "";
        } else if (null != rBackText) {
            try {
                int textLen = rText.length();
                if (rColWidth > textLen) {
                    int backTextLen = rBackText.length();
                    int remainWidth = rColWidth - textLen;
                    int backTextRepeats = remainWidth / backTextLen;
                    int backTextRemain = remainWidth % backTextLen;
                    String back = "";
                    for (int backTextI = 0; backTextI < backTextRepeats; backTextI++) {
                        back = back + rBackText;
                    }
                    back = back + rBackText.substring(0, backTextRemain);
                    switch(rAlignment) {
                        case 'l':
                            result = result + back;
                            break;
                        case 'c':
                            result = back.substring(0, (back.length() / 2)) + result + back.substring((back.length() / 2));
                            break;
                        case 'r':
                            result = back + result;
                            break;
                    }
                }
            } catch (Exception e) {
                result = rText;
            }
        }
        return result;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,905285.java,335,370
selected,2095100.java,386,421
----------------------------------------
        private void sendResponse(String status, String mime, Properties header, InputStream data) {
            try {
                if (status == null) throw new Error("sendResponse(): Status can't be null.");
                OutputStream out = mySocket.getOutputStream();
                PrintWriter pw = new PrintWriter(out);
                pw.print("HTTP/1.0 " + status + " \r\n");
                if (mime != null) pw.print("Content-Type: " + mime + "\r\n");
                if (header == null || header.getProperty("Date") == null) pw.print("Date: " + gmtFrmt.format(new Date()) + "\r\n");
                if (header != null) {
                    Enumeration e = header.keys();
                    while (e.hasMoreElements()) {
                        String key = (String) e.nextElement();
                        String value = header.getProperty(key);
                        pw.print(key + ": " + value + "\r\n");
                    }
                }
                pw.print("\r\n");
                pw.flush();
                if (data != null) {
                    byte[] buff = new byte[2048];
                    while (true) {
                        int read = data.read(buff, 0, 2048);
                        if (read <= 0) break;
                        out.write(buff, 0, read);
                    }
                }
                out.flush();
                out.close();
                if (data != null) data.close();
            } catch (IOException ioe) {
                try {
                    mySocket.close();
                } catch (Throwable t) {
                }
            }
        }
----------------------------------------
        private void sendResponse(String status, String mime, Properties header, InputStream data) {
            try {
                if (status == null) throw new Error("sendResponse(): Status can't be null.");
                OutputStream out = mySocket.getOutputStream();
                PrintWriter pw = new PrintWriter(out);
                pw.print("HTTP/1.0 " + status + " \r\n");
                if (mime != null) pw.print("Content-Type: " + mime + "\r\n");
                if (header == null || header.getProperty("Date") == null) pw.print("Date: " + gmtFrmt.format(new Date()) + "\r\n");
                if (header != null) {
                    Enumeration e = header.keys();
                    while (e.hasMoreElements()) {
                        String key = (String) e.nextElement();
                        String value = header.getProperty(key);
                        pw.print(key + ": " + value + "\r\n");
                    }
                }
                pw.print("\r\n");
                pw.flush();
                if (data != null) {
                    byte[] buff = new byte[2048];
                    while (true) {
                        int read = data.read(buff, 0, 2048);
                        if (read <= 0) break;
                        out.write(buff, 0, read);
                    }
                }
                out.flush();
                out.close();
                if (data != null) data.close();
            } catch (IOException ioe) {
                try {
                    mySocket.close();
                } catch (Throwable t) {
                }
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1232386.java,216,251
selected,2294578.java,8,40
----------------------------------------
    public static boolean UpdateRebaseDBFile() {
        OutputStream out = null;
        URLConnection conn = null;
        InputStream in = null;
        try {
            URL url = new URL(urlAddress);
            File folder = new File(relativeXmlFileLocation);
            if (!folder.exists()) folder.mkdir();
            out = new BufferedOutputStream(new FileOutputStream(relativeDataFileLocation));
            conn = url.openConnection();
            conn.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0; H010818)");
            int totalSize = Integer.parseInt(conn.getHeaderField("content-length"));
            in = conn.getInputStream();
            byte[] buffer = new byte[1024];
            int numRead;
            long numWritten = 0;
            while ((numRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, numRead);
                numWritten += numRead;
            }
        } catch (Exception exception) {
            exception.printStackTrace();
            return false;
        } finally {
            try {
                if (in != null) {
                    in.close();
                }
                if (out != null) {
                    out.close();
                }
            } catch (IOException ioe) {
            }
        }
        return true;
    }
----------------------------------------
    public static long download(String address, String localFileName) throws Exception {
        OutputStream out = null;
        URLConnection conn = null;
        InputStream in = null;
        long numWritten = 0;
        try {
            URL url = new URL(address);
            out = new BufferedOutputStream(new FileOutputStream(localFileName));
            conn = url.openConnection();
            in = conn.getInputStream();
            byte[] buffer = new byte[1024];
            int numRead;
            while ((numRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, numRead);
                numWritten += numRead;
            }
            System.out.println(localFileName + "\t" + numWritten);
        } catch (Exception exception) {
            System.out.println("Error: " + exception);
            throw exception;
        } finally {
            try {
                if (in != null) {
                    in.close();
                }
                if (out != null) {
                    out.close();
                }
            } catch (IOException ioe) {
            }
            return numWritten;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,453369.java,38,72
selected,1623776.java,132,164
----------------------------------------
    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Error: " + e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            System.out.println("Error:" + e);
        }
    }
----------------------------------------
    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer(128);
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer(32);
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & TWO_BYTES;
                if (b < PAD_BELOW) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,172418.java,1237,1271
selected,2720826.java,1195,1229
----------------------------------------
    private Pool loadMixtureWeightsBinary(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(MIXW_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numStreams * numGaussiansPerState;
        assert numStreams == 1;
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            float[] logMixtureWeight = readFloatArray(dis, numGaussiansPerState);
            nonZeroFloor(logMixtureWeight, floor);
            normalize(logMixtureWeight);
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        dis.close();
        return pool;
    }
----------------------------------------
    private Pool loadMixtureWeightsBinary(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(MIXW_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numStreams * numGaussiansPerState;
        assert numStreams == 1;
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            float[] logMixtureWeight = readFloatArray(dis, numGaussiansPerState);
            nonZeroFloor(logMixtureWeight, floor);
            normalize(logMixtureWeight);
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        dis.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1778922.java,1166,1199
selected,472295.java,1133,1166
----------------------------------------
    private Pool loadMixtureWeightsAscii(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = StreamFactory.getInputStream(location, path);
        Pool pool = new Pool(path);
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        est.expectString("mixw");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mixw");
            est.expectString("[" + i);
            est.expectString("0]");
            float total = est.getFloat("total");
            float[] logMixtureWeight = new float[numGaussiansPerState];
            for (int j = 0; j < numGaussiansPerState; j++) {
                float val = est.getFloat("mixwVal");
                if (val < floor) {
                    val = floor;
                }
                logMixtureWeight[j] = val;
            }
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        est.close();
        return pool;
    }
----------------------------------------
    private Pool loadMixtureWeightsAscii(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = StreamFactory.getInputStream(location, path);
        Pool pool = new Pool(path);
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        est.expectString("mixw");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mixw");
            est.expectString("[" + i);
            est.expectString("0]");
            float total = est.getFloat("total");
            float[] logMixtureWeight = new float[numGaussiansPerState];
            for (int j = 0; j < numGaussiansPerState; j++) {
                float val = est.getFloat("mixwVal");
                if (val < floor) {
                    val = floor;
                }
                logMixtureWeight[j] = val;
            }
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1473439.java,1237,1271
selected,2471299.java,1195,1229
----------------------------------------
    private Pool loadMixtureWeightsBinary(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(MIXW_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numStreams * numGaussiansPerState;
        assert numStreams == 1;
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            float[] logMixtureWeight = readFloatArray(dis, numGaussiansPerState);
            nonZeroFloor(logMixtureWeight, floor);
            normalize(logMixtureWeight);
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        dis.close();
        return pool;
    }
----------------------------------------
    private Pool loadMixtureWeightsBinary(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        int numValues;
        Properties props = new Properties();
        DataInputStream dis = readS3BinaryHeader(location, path, props);
        String version = props.getProperty("version");
        boolean doCheckSum;
        if (version == null || !version.equals(MIXW_FILE_VERSION)) {
            throw new IOException("Unsupported version in " + path);
        }
        String checksum = props.getProperty("chksum0");
        doCheckSum = (checksum != null && checksum.equals("yes"));
        Pool pool = new Pool(path);
        numStates = readInt(dis);
        numStreams = readInt(dis);
        numGaussiansPerState = readInt(dis);
        numValues = readInt(dis);
        assert numValues == numStates * numStreams * numGaussiansPerState;
        assert numStreams == 1;
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            float[] logMixtureWeight = readFloatArray(dis, numGaussiansPerState);
            nonZeroFloor(logMixtureWeight, floor);
            normalize(logMixtureWeight);
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        dis.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,356074.java,1145,1178
selected,1778922.java,1166,1199
----------------------------------------
    private Pool loadMixtureWeightsAscii(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = StreamFactory.getInputStream(location, path);
        Pool pool = new Pool(path);
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        est.expectString("mixw");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mixw");
            est.expectString("[" + i);
            est.expectString("0]");
            float total = est.getFloat("total");
            float[] logMixtureWeight = new float[numGaussiansPerState];
            for (int j = 0; j < numGaussiansPerState; j++) {
                float val = est.getFloat("mixwVal");
                if (val < floor) {
                    val = floor;
                }
                logMixtureWeight[j] = val;
            }
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        est.close();
        return pool;
    }
----------------------------------------
    private Pool loadMixtureWeightsAscii(String path, float floor) throws FileNotFoundException, IOException {
        logger.fine("Loading mixture weights from: " + path);
        int numStates;
        int numStreams;
        int numGaussiansPerState;
        InputStream inputStream = StreamFactory.getInputStream(location, path);
        Pool pool = new Pool(path);
        ExtendedStreamTokenizer est = new ExtendedStreamTokenizer(inputStream, '#', false);
        est.expectString("mixw");
        numStates = est.getInt("numStates");
        numStreams = est.getInt("numStreams");
        numGaussiansPerState = est.getInt("numGaussiansPerState");
        pool.setFeature(NUM_SENONES, numStates);
        pool.setFeature(NUM_STREAMS, numStreams);
        pool.setFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState);
        for (int i = 0; i < numStates; i++) {
            est.expectString("mixw");
            est.expectString("[" + i);
            est.expectString("0]");
            float total = est.getFloat("total");
            float[] logMixtureWeight = new float[numGaussiansPerState];
            for (int j = 0; j < numGaussiansPerState; j++) {
                float val = est.getFloat("mixwVal");
                if (val < floor) {
                    val = floor;
                }
                logMixtureWeight[j] = val;
            }
            convertToLogMath(logMixtureWeight);
            pool.put(i, logMixtureWeight);
        }
        est.close();
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,111048.java,181,216
default,849.java,156,191
----------------------------------------
    private JPopupMenu getLocalMenu(final DirectoryNode fNode) {
        JPopupMenu popup = new JPopupMenu();
        JMenuItem menuitem = new JMenuItem("Save file to...");
        menuitem.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ae) {
                String targetFile = Utils.selectFile("Save file as", fNode.getName(), (JFrame) Main.getUI());
                try {
                    FileUtils.copyFile(fNode.getLocalURL(), new File(targetFile));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
        popup.add(menuitem);
        menuitem = new JMenuItem("View as text");
        menuitem.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ae) {
                Window window = new Window((Frame) null, "Content of file " + fNode.getName());
                JTextArea ta = new JTextArea();
                Utils.addPopupMenu(ta);
                ta.setEditable(false);
                try {
                    ta.setText(FileUtils.readFile(fNode.getLocalURL()));
                } catch (IOException ioe) {
                    ta.setText("Error: File " + fNode.getLocalURL() + " cannot be found");
                }
                window.setContent(new JScrollPane(ta));
                window.addCloseButton();
                window.showWindow();
            }
        });
        popup.add(menuitem);
        return popup;
    }
----------------------------------------
    private JPopupMenu getLocalMenu(final DirectoryNode fNode) {
        JPopupMenu popup = new JPopupMenu();
        JMenuItem menuitem = new JMenuItem("Save file to...");
        menuitem.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ae) {
                String targetFile = Utils.selectFile("Save file as", fNode.getName(), FileObserver.this);
                try {
                    FileUtils.copyFile(fNode.getLocalURL(), new File(targetFile));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
        popup.add(menuitem);
        menuitem = new JMenuItem("View as text");
        menuitem.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ae) {
                Window window = new Window((Frame) null, "Content of file " + fNode.getName());
                JTextArea ta = new JTextArea();
                Utils.addPopupMenu(ta);
                ta.setEditable(false);
                try {
                    ta.setText(FileUtils.readFile(fNode.getLocalURL()));
                } catch (IOException ioe) {
                    ta.setText("Error: File " + fNode.getLocalURL() + " cannot be found");
                }
                window.setContent(new JScrollPane(ta));
                window.addCloseButton();
                window.showWindow();
            }
        });
        popup.add(menuitem);
        return popup;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14709.java,205,238
default,72294.java,208,241
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
    DcmDir(File dirfile, Properties cfg) throws IOException {
        this.dirFile = dirfile.getCanonicalFile();
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1794761.java,145,179
selected,950.java,145,179
----------------------------------------
    public static Resource createDiagram(URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
        TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain();
        progressMonitor.beginTask(Messages.OverviewMapsDiagramEditorUtil_CreateDiagramProgressTask, 3);
        final Resource diagramResource = editingDomain.getResourceSet().createResource(diagramURI);
        final Resource modelResource = editingDomain.getResourceSet().createResource(modelURI);
        final String diagramName = diagramURI.lastSegment();
        AbstractTransactionalCommand command = new AbstractTransactionalCommand(editingDomain, Messages.OverviewMapsDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {

            protected CommandResult doExecuteWithResult(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
                LinkedMapContainer model = createInitialModel();
                attachModelToResource(model, modelResource);
                Diagram diagram = ViewService.createDiagram(model, LinkedMapContainerEditPart.MODEL_ID, OverviewMapsDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
                if (diagram != null) {
                    diagramResource.getContents().add(diagram);
                    diagram.setName(diagramName);
                    diagram.setElement(model);
                }
                try {
                    modelResource.save(de.mpiwg.vspace.maps.diagram.part.OverviewMapsDiagramEditorUtil.getSaveOptions());
                    diagramResource.save(de.mpiwg.vspace.maps.diagram.part.OverviewMapsDiagramEditorUtil.getSaveOptions());
                } catch (IOException e) {
                    OverviewMapsDiagramEditorPlugin.getInstance().logError("Unable to store model and diagram resources", e);
                }
                return CommandResult.newOKCommandResult();
            }
        };
        try {
            OperationHistoryFactory.getOperationHistory().execute(command, new SubProgressMonitor(progressMonitor, 1), null);
        } catch (ExecutionException e) {
            OverviewMapsDiagramEditorPlugin.getInstance().logError("Unable to create model and diagram", e);
        }
        setCharset(WorkspaceSynchronizer.getFile(modelResource));
        setCharset(WorkspaceSynchronizer.getFile(diagramResource));
        return diagramResource;
    }
----------------------------------------
    public static Resource createDiagram(URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
        TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain();
        progressMonitor.beginTask(Messages.SaveccmDiagramEditorUtil_CreateDiagramProgressTask, 3);
        final Resource diagramResource = editingDomain.getResourceSet().createResource(diagramURI);
        final Resource modelResource = editingDomain.getResourceSet().createResource(modelURI);
        final String diagramName = diagramURI.lastSegment();
        AbstractTransactionalCommand command = new AbstractTransactionalCommand(editingDomain, Messages.SaveccmDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {

            protected CommandResult doExecuteWithResult(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
                Composite model = createInitialModel();
                attachModelToResource(model, modelResource);
                Diagram diagram = ViewService.createDiagram(model, CompositeEditPart.MODEL_ID, SaveccmDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
                if (diagram != null) {
                    diagramResource.getContents().add(diagram);
                    diagram.setName(diagramName);
                    diagram.setElement(model);
                }
                try {
                    modelResource.save(se.mdh.mrtc.saveccm.composite.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions());
                    diagramResource.save(se.mdh.mrtc.saveccm.composite.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions());
                } catch (IOException e) {
                    SaveccmDiagramEditorPlugin.getInstance().logError("Unable to store model and diagram resources", e);
                }
                return CommandResult.newOKCommandResult();
            }
        };
        try {
            OperationHistoryFactory.getOperationHistory().execute(command, new SubProgressMonitor(progressMonitor, 1), null);
        } catch (ExecutionException e) {
            SaveccmDiagramEditorPlugin.getInstance().logError("Unable to create model and diagram", e);
        }
        setCharset(WorkspaceSynchronizer.getFile(modelResource));
        setCharset(WorkspaceSynchronizer.getFile(diagramResource));
        return diagramResource;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,124843.java,208,241
default,137594.java,208,241
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1422595.java,220,254
selected,1616011.java,222,254
----------------------------------------
    public static int nullSafeHashCode(Object obj) {
        if (obj == null) {
            return 0;
        }
        if (obj.getClass().isArray()) {
            if (obj instanceof Object[]) {
                return nullSafeHashCode((Object[]) obj);
            }
            if (obj instanceof boolean[]) {
                return nullSafeHashCode((boolean[]) obj);
            }
            if (obj instanceof byte[]) {
                return nullSafeHashCode((byte[]) obj);
            }
            if (obj instanceof char[]) {
                return nullSafeHashCode((char[]) obj);
            }
            if (obj instanceof double[]) {
                return nullSafeHashCode((double[]) obj);
            }
            if (obj instanceof float[]) {
                return nullSafeHashCode((float[]) obj);
            }
            if (obj instanceof int[]) {
                return nullSafeHashCode((int[]) obj);
            }
            if (obj instanceof long[]) {
                return nullSafeHashCode((long[]) obj);
            }
            if (obj instanceof short[]) {
                return nullSafeHashCode((short[]) obj);
            }
        }
        return obj.hashCode();
    }
----------------------------------------
    public static int nullSafeHashCode(Object obj) {
        if (obj == null) {
            return 0;
        }
        if (obj instanceof Object[]) {
            return nullSafeHashCode((Object[]) obj);
        }
        if (obj instanceof boolean[]) {
            return nullSafeHashCode((boolean[]) obj);
        }
        if (obj instanceof byte[]) {
            return nullSafeHashCode((byte[]) obj);
        }
        if (obj instanceof char[]) {
            return nullSafeHashCode((char[]) obj);
        }
        if (obj instanceof double[]) {
            return nullSafeHashCode((double[]) obj);
        }
        if (obj instanceof float[]) {
            return nullSafeHashCode((float[]) obj);
        }
        if (obj instanceof int[]) {
            return nullSafeHashCode((int[]) obj);
        }
        if (obj instanceof long[]) {
            return nullSafeHashCode((long[]) obj);
        }
        if (obj instanceof short[]) {
            return nullSafeHashCode((short[]) obj);
        }
        return obj.hashCode();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2683882.java,145,179
selected,2579302.java,144,175
----------------------------------------
    public static Resource createDiagram(URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
        TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain();
        progressMonitor.beginTask(Messages.UIVocabularyDiagramEditorUtil_CreateDiagramProgressTask, 3);
        final Resource diagramResource = editingDomain.getResourceSet().createResource(diagramURI);
        final Resource modelResource = editingDomain.getResourceSet().createResource(modelURI);
        final String diagramName = diagramURI.lastSegment();
        AbstractTransactionalCommand command = new AbstractTransactionalCommand(editingDomain, Messages.UIVocabularyDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {

            protected CommandResult doExecuteWithResult(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
                UIVocabulary model = createInitialModel();
                attachModelToResource(model, modelResource);
                Diagram diagram = ViewService.createDiagram(model, UIVocabularyEditPart.MODEL_ID, UIVocabularyDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
                if (diagram != null) {
                    diagramResource.getContents().add(diagram);
                    diagram.setName(diagramName);
                    diagram.setElement(model);
                }
                try {
                    modelResource.save(org.fluid.uimodeling.uivocabulary.diagram.part.UIVocabularyDiagramEditorUtil.getSaveOptions());
                    diagramResource.save(org.fluid.uimodeling.uivocabulary.diagram.part.UIVocabularyDiagramEditorUtil.getSaveOptions());
                } catch (IOException e) {
                    UIVocabularyDiagramEditorPlugin.getInstance().logError("Unable to store model and diagram resources", e);
                }
                return CommandResult.newOKCommandResult();
            }
        };
        try {
            OperationHistoryFactory.getOperationHistory().execute(command, new SubProgressMonitor(progressMonitor, 1), null);
        } catch (ExecutionException e) {
            UIVocabularyDiagramEditorPlugin.getInstance().logError("Unable to create model and diagram", e);
        }
        setCharset(WorkspaceSynchronizer.getFile(modelResource));
        setCharset(WorkspaceSynchronizer.getFile(diagramResource));
        return diagramResource;
    }
----------------------------------------
    public static Resource createDiagram(URI diagramURI, IProgressMonitor progressMonitor) {
        TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain();
        progressMonitor.beginTask(Messages.TelcoblocksDiagramEditorUtil_CreateDiagramProgressTask, 3);
        final Resource diagramResource = editingDomain.getResourceSet().createResource(diagramURI);
        final String diagramName = diagramURI.lastSegment();
        AbstractTransactionalCommand command = new AbstractTransactionalCommand(editingDomain, Messages.TelcoblocksDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {

            protected CommandResult doExecuteWithResult(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
                org.germinus.telcoblocks.SERVICIOS model = createInitialModel();
                attachModelToResource(model, diagramResource);
                Diagram diagram = ViewService.createDiagram(model, SERVICIOSEditPart.MODEL_ID, TelcoblocksServiciosDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
                if (diagram != null) {
                    diagramResource.getContents().add(diagram);
                    diagram.setName(diagramName);
                    diagram.setElement(model);
                }
                try {
                    diagramResource.save(org.germinus.telcoblocks.servicios.diagram.part.TelcoblocksDiagramEditorUtil.getSaveOptions());
                } catch (IOException e) {
                    TelcoblocksServiciosDiagramEditorPlugin.getInstance().logError("Unable to store model and diagram resources", e);
                }
                return CommandResult.newOKCommandResult();
            }
        };
        try {
            OperationHistoryFactory.getOperationHistory().execute(command, new SubProgressMonitor(progressMonitor, 1), null);
        } catch (ExecutionException e) {
            TelcoblocksServiciosDiagramEditorPlugin.getInstance().logError("Unable to create model and diagram", e);
        }
        setCharset(WorkspaceSynchronizer.getFile(diagramResource));
        return diagramResource;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12819.java,208,241
default,118405.java,208,241
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1402682.java,802,835
selected,1402682.java,891,925
----------------------------------------
    public static boolean insereLicao(final Connection con, Licao lic, Autor aut, Descricao desc) {
        try {
            con.setAutoCommit(false);
            Statement smt = con.createStatement();
            if (aut.getCodAutor() == 0) {
                GeraID.gerarCodAutor(con, aut);
                smt.executeUpdate("INSERT INTO autor VALUES(" + aut.getCodAutor() + ",'" + aut.getNome() + "','" + aut.getEmail() + "')");
            }
            GeraID.gerarCodDescricao(con, desc);
            GeraID.gerarCodLicao(con, lic);
            String titulo = lic.getTitulo().replaceAll("['\"]", "");
            String coment = lic.getComentario().replaceAll("[']", "\"");
            String texto = desc.getTexto().replaceAll("[']", "\"");
            smt.executeUpdate("INSERT INTO descricao VALUES(" + desc.getCodDesc() + ",'" + texto + "')");
            smt.executeUpdate("INSERT INTO licao VALUES(" + lic.getCodigo() + ",'" + titulo + "','" + coment + "'," + desc.getCodDesc() + ")");
            smt.executeUpdate("INSERT INTO lic_aut VALUES(" + lic.getCodigo() + "," + aut.getCodAutor() + ")");
            con.commit();
            return (true);
        } catch (SQLException e) {
            try {
                JOptionPane.showMessageDialog(null, "Rolling back transaction", "LICAO: Database error", JOptionPane.ERROR_MESSAGE);
                con.rollback();
            } catch (SQLException e1) {
                System.err.print(e1.getSQLState());
            }
            return (false);
        } finally {
            try {
                con.setAutoCommit(true);
            } catch (SQLException e2) {
                System.err.print(e2.getSQLState());
            }
        }
    }
----------------------------------------
    private static boolean insereTutorial(final Connection con, final Tutorial tut, final Autor aut, final Descricao desc) {
        try {
            con.setAutoCommit(false);
            Statement smt = con.createStatement();
            if (aut.getCodAutor() == 0) {
                GeraID.gerarCodAutor(con, aut);
                smt.executeUpdate("INSERT INTO autor VALUES(" + aut.getCodAutor() + ",'" + aut.getNome() + "','" + aut.getEmail() + "')");
            }
            GeraID.gerarCodDescricao(con, desc);
            GeraID.gerarCodTutorial(con, tut);
            String titulo = tut.getTitulo().replaceAll("['\"]", "");
            String coment = tut.getComentario().replaceAll("[']", "\"");
            String texto = desc.getTexto().replaceAll("[']", "\"");
            smt.executeUpdate("INSERT INTO descricao VALUES(" + desc.getCodDesc() + ",'" + texto + "')");
            smt.executeUpdate("INSERT INTO tutorial VALUES(" + tut.getCodigo() + ",'" + titulo + "','" + coment + "'," + desc.getCodDesc() + ")");
            smt.executeUpdate("INSERT INTO tut_aut VALUES(" + tut.getCodigo() + "," + aut.getCodAutor() + ")");
            con.commit();
            return (true);
        } catch (SQLException e) {
            try {
                JOptionPane.showMessageDialog(null, "Rolling back transaction", "TUTORIAL: Database error", JOptionPane.ERROR_MESSAGE);
                System.out.print(e.getMessage());
                con.rollback();
            } catch (SQLException e1) {
                System.err.print(e1.getSQLState());
            }
            return (false);
        } finally {
            try {
                con.setAutoCommit(true);
            } catch (SQLException e2) {
                System.err.print(e2.getSQLState());
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,2909.java,797,825
default,11822.java,797,825
----------------------------------------
    void processSplitRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing value in SPLIT");
        String value = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing separators in SPLIT");
        String sep = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing variables in SPLIT");
        int numVars = pst.countTokens();
        String[] var_names = new String[numVars];
        for (int i = 0; i < numVars; i++) var_names[i] = pst.nextToken();
        StringTokenizer vst = new StringTokenizer(value, sep);
        String[] values = new String[numVars];
        for (int i = 0; i < numVars; i++) if (vst.hasMoreTokens()) values[i] = vst.nextToken(); else values[i] = "";
        if (DEBUG) System.out.println("doing split with value \"" + value + "\" to vars :" + params.substring(value.length() + 3));
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                String result = currentLine;
                for (int curVar = 0; curVar < var_names.length; curVar++) result = substitute(result, var_names[curVar], values[curVar]);
                out.print(result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt(j);
                Vector newRegion = oldRegion;
                for (int curVar = 0; curVar < var_names.length; curVar++) newRegion = substituteInRegion(newRegion, var_names[curVar], values[curVar]);
                processTemplateRegion(newRegion);
            }
        }
    }
----------------------------------------
    void processSplitRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing value in SPLIT");
        String value = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing separators in SPLIT");
        String sep = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing variables in SPLIT");
        int numVars = pst.countTokens();
        String[] var_names = new String[numVars];
        for (int i = 0; i < numVars; i++) var_names[i] = pst.nextToken();
        StringTokenizer vst = new StringTokenizer(value, sep);
        String[] values = new String[numVars];
        for (int i = 0; i < numVars; i++) if (vst.hasMoreTokens()) values[i] = vst.nextToken(); else values[i] = "";
        if (DEBUG) System.out.println("doing split with value \"" + value + "\" to vars :" + params.substring(value.length() + 3));
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                String result = currentLine;
                for (int curVar = 0; curVar < var_names.length; curVar++) result = substitute(result, var_names[curVar], values[curVar]);
                out.print(result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt(j);
                Vector newRegion = oldRegion;
                for (int curVar = 0; curVar < var_names.length; curVar++) newRegion = substituteInRegion(newRegion, var_names[curVar], values[curVar]);
                processTemplateRegion(newRegion);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2666453.java,981,1015
selected,2666453.java,1017,1050
----------------------------------------
    public tcg.syscontrol.cos.ICosMonitoredThread cosGetCorbaServerOperationMode(java.lang.String uniqueKey, tcg.syscontrol.cos.CosOperationModeEnumHolder operationMode) throws tcg.syscontrol.cos.CosUnknownProcessException {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("cosGetCorbaServerOperationMode", true);
                    _os.write_string(uniqueKey);
                    _is = _invoke(_os);
                    tcg.syscontrol.cos.ICosMonitoredThread _result = tcg.syscontrol.cos.ICosMonitoredThreadHelper.read(_is);
                    operationMode.value = tcg.syscontrol.cos.CosOperationModeEnumHelper.read(_is);
                    return _result;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    if (_id.equals("IDL:tcg/syscontrol/cos/CosUnknownProcessException:1.0")) {
                        throw tcg.syscontrol.cos.CosUnknownProcessExceptionHelper.read(_ax.getInputStream());
                    }
                    throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("cosGetCorbaServerOperationMode", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                ICosProcessManagerOperations _localServant = (ICosProcessManagerOperations) _so.servant;
                tcg.syscontrol.cos.ICosMonitoredThread _result;
                try {
                    _result = _localServant.cosGetCorbaServerOperationMode(uniqueKey, operationMode);
                } finally {
                    _servant_postinvoke(_so);
                }
                return _result;
            }
        }
    }
----------------------------------------
    public tcg.syscontrol.cos.ICosManagedProcess cosGetActiveManagedProcess(short index) throws tcg.syscontrol.cos.CosIndexOutOfBoundException {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("cosGetActiveManagedProcess", true);
                    _os.write_ushort(index);
                    _is = _invoke(_os);
                    tcg.syscontrol.cos.ICosManagedProcess _result = tcg.syscontrol.cos.ICosManagedProcessHelper.read(_is);
                    return _result;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    if (_id.equals("IDL:tcg/syscontrol/cos/CosIndexOutOfBoundException:1.0")) {
                        throw tcg.syscontrol.cos.CosIndexOutOfBoundExceptionHelper.read(_ax.getInputStream());
                    }
                    throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("cosGetActiveManagedProcess", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                ICosProcessManagerOperations _localServant = (ICosProcessManagerOperations) _so.servant;
                tcg.syscontrol.cos.ICosManagedProcess _result;
                try {
                    _result = _localServant.cosGetActiveManagedProcess(index);
                } finally {
                    _servant_postinvoke(_so);
                }
                return _result;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32260.java,339,373
default,71930.java,325,359
----------------------------------------
    void processTemplateRegion(Vector region) throws IOException {
        String inLine = (String) region.elementAt(0);
        int command = getTemplateCommand(inLine);
        switch(command) {
            case FOREACH:
                processForeachRegion(region);
                break;
            case LOOP:
                processLoopRegion(region);
                break;
            case COUNT:
                processCountRegion(region);
                break;
            case SPLIT:
                processSplitRegion(region);
                break;
            case JOIN:
                processJoinRegion(region);
                break;
            case LET:
                processLetRegion(region);
                break;
            case EVAL:
                processEvalRegion(region);
                break;
            case IF:
                processCondRegion(region);
                break;
            case INCLUDE:
                processIncludeRegion(region);
                break;
            default:
                throw new IOException("Invalid command");
        }
    }
----------------------------------------
    void processTemplateRegion(Vector region) throws IOException {
        String inLine = (String) region.elementAt(0);
        int command = getTemplateCommand(inLine);
        switch(command) {
            case FOREACH:
                processForeachRegion(region);
                break;
            case LOOP:
                processLoopRegion(region);
                break;
            case COUNT:
                processCountRegion(region);
                break;
            case SPLIT:
                processSplitRegion(region);
                break;
            case JOIN:
                processJoinRegion(region);
                break;
            case LET:
                processLetRegion(region);
                break;
            case EVAL:
                processEvalRegion(region);
                break;
            case IF:
                processCondRegion(region);
                break;
            case INCLUDE:
                processIncludeRegion(region);
                break;
            default:
                throw new IOException("Invalid command");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,106446.java,208,241
default,116906.java,208,241
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14977.java,797,825
default,62109.java,797,825
----------------------------------------
    void processSplitRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing value in SPLIT");
        String value = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing separators in SPLIT");
        String sep = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing variables in SPLIT");
        int numVars = pst.countTokens();
        String[] var_names = new String[numVars];
        for (int i = 0; i < numVars; i++) var_names[i] = pst.nextToken();
        StringTokenizer vst = new StringTokenizer(value, sep);
        String[] values = new String[numVars];
        for (int i = 0; i < numVars; i++) if (vst.hasMoreTokens()) values[i] = vst.nextToken(); else values[i] = "";
        if (DEBUG) System.out.println("doing split with value \"" + value + "\" to vars :" + params.substring(value.length() + 3));
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                String result = currentLine;
                for (int curVar = 0; curVar < var_names.length; curVar++) result = substitute(result, var_names[curVar], values[curVar]);
                out.print(result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt(j);
                Vector newRegion = oldRegion;
                for (int curVar = 0; curVar < var_names.length; curVar++) newRegion = substituteInRegion(newRegion, var_names[curVar], values[curVar]);
                processTemplateRegion(newRegion);
            }
        }
    }
----------------------------------------
    void processSplitRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing value in SPLIT");
        String value = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing separators in SPLIT");
        String sep = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing variables in SPLIT");
        int numVars = pst.countTokens();
        String[] var_names = new String[numVars];
        for (int i = 0; i < numVars; i++) var_names[i] = pst.nextToken();
        StringTokenizer vst = new StringTokenizer(value, sep);
        String[] values = new String[numVars];
        for (int i = 0; i < numVars; i++) if (vst.hasMoreTokens()) values[i] = vst.nextToken(); else values[i] = "";
        if (DEBUG) System.out.println("doing split with value \"" + value + "\" to vars :" + params.substring(value.length() + 3));
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                String result = currentLine;
                for (int curVar = 0; curVar < var_names.length; curVar++) result = substitute(result, var_names[curVar], values[curVar]);
                out.print(result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt(j);
                Vector newRegion = oldRegion;
                for (int curVar = 0; curVar < var_names.length; curVar++) newRegion = substituteInRegion(newRegion, var_names[curVar], values[curVar]);
                processTemplateRegion(newRegion);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,67675.java,208,241
default,79012.java,208,241
----------------------------------------
    DcmDir(File dirfile, Properties cfg) throws IOException {
        this.dirFile = dirfile.getCanonicalFile();
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,828322.java,201,235
selected,2177206.java,274,306
----------------------------------------
    public File doPostGetFile(String url, String postData, File inFile) throws IOException {
        long t1 = System.currentTimeMillis();
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("##### doPost-start #####, url=" + url + ", postData=\n" + postData);
        }
        InputStream responseBodyInputStream = null;
        PostMethod pMethod = new PostMethod(url);
        if ("yes".equalsIgnoreCase(config.getProperty(XDriveConstant.CONFIG_HTTPCLIENT_IGNORECOOKIES))) {
            pMethod.getParams().setCookiePolicy(CookiePolicy.IGNORE_COOKIES);
        }
        try {
            NameValuePair type = new NameValuePair("data", postData);
            pMethod.setRequestBody(new NameValuePair[] { type });
            this.hc.executeMethod(pMethod);
            responseBodyInputStream = pMethod.getResponseBodyAsStream();
            final int bufferSize = 2048;
            FileOutputStream fout = new FileOutputStream(inFile);
            byte[] buffer = new byte[bufferSize];
            int readCount = 0;
            while ((readCount = responseBodyInputStream.read(buffer)) != -1) {
                if (readCount < bufferSize) {
                    fout.write(buffer, 0, readCount);
                } else {
                    fout.write(buffer);
                }
            }
            fout.close();
        } finally {
            pMethod.releaseConnection();
        }
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("##### doPost-end   #####, used time: " + (System.currentTimeMillis() - t1) + " ms,response=[InputStream]\n");
        }
        return inFile;
    }
----------------------------------------
    public File doGetFile(String url, File inFile) throws IOException {
        long t1 = System.currentTimeMillis();
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("##### doGet-start  #####, url=" + url);
        }
        InputStream responseBodyInputStream = null;
        GetMethod gMethod = new GetMethod(url);
        if ("yes".equalsIgnoreCase(config.getProperty(BoxConstant.CONFIG_HTTPCLIENT_IGNORECOOKIES))) {
            gMethod.getParams().setCookiePolicy(CookiePolicy.IGNORE_COOKIES);
        }
        try {
            this.hc.executeMethod(gMethod);
            responseBodyInputStream = gMethod.getResponseBodyAsStream();
            final int bufferSize = 2048;
            FileOutputStream fout = new FileOutputStream(inFile);
            byte[] buffer = new byte[bufferSize];
            int readCount = 0;
            while ((readCount = responseBodyInputStream.read(buffer)) != -1) {
                if (readCount < bufferSize) {
                    fout.write(buffer, 0, readCount);
                } else {
                    fout.write(buffer);
                }
            }
            fout.close();
        } finally {
            gMethod.releaseConnection();
        }
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("##### doGet-end    #####, used time: " + (System.currentTimeMillis() - t1) + " ms,response=[InputStream]\n");
        }
        return inFile;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,125676.java,286,320
default,129040.java,286,320
----------------------------------------
        private void subscribe() {
            MetricListener ml = this;
            try {
                this.initFile(jobId);
                MonitorConsumer mc = new MonitorConsumer(this.monitorURL);
                mc.addMetricListener(ml);
                mc.auth();
                MonitorArg args[] = new MonitorArg[1];
                args[0] = new MonitorArg("jobid", jobId);
                MonitorConsumer.CollectResult cr = (MonitorConsumer.CollectResult) mc.collect("application.message", args);
                cr.waitResult();
                MonitorConsumer.MetricInstance suscribeMetric = cr.getMetricInstance();
                int mid = suscribeMetric.getMetricId();
                this.metricId = mid;
                int channel = mc.getChannelId();
                System.out.println("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - mid:" + mid);
                MonitorConsumer.CommandResult sr = mc.subscribe(mid, channel);
                sr.waitResult();
                int status = sr.getStatus();
                if (status != 0) {
                    System.out.println("\n\tTestClient.subscribe(" + this.monitorURL + ", " + jobId + ") -Suscribe failed: " + sr.getStatusStr());
                    System.exit(1);
                }
                System.out.println("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - Subscribe SUCCESSFUL. Waiting for data...");
                while (true) {
                    try {
                        java.lang.Thread.sleep(1000);
                    } catch (Exception e) {
                    }
                }
            } catch (MonitorException mex) {
                System.out.println("\n\tTestClient.subscribe(" + ml + "," + this.monitorURL + ", " + this.jobId + ") -- FAILED.");
                mex.printStackTrace();
            }
        }
----------------------------------------
        private void subscribe() {
            MetricListener ml = this;
            try {
                this.initFile(jobId);
                MonitorConsumer mc = new MonitorConsumer(this.monitorURL);
                mc.addMetricListener(ml);
                mc.auth();
                MonitorArg args[] = new MonitorArg[1];
                args[0] = new MonitorArg("jobid", jobId);
                MonitorConsumer.CollectResult cr = (MonitorConsumer.CollectResult) mc.collect("application.message", args);
                cr.waitResult();
                MonitorConsumer.MetricInstance suscribeMetric = cr.getMetricInstance();
                int mid = suscribeMetric.getMetricId();
                this.metricId = mid;
                int channel = mc.getChannelId();
                System.out.println("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - mid:" + mid);
                MonitorConsumer.CommandResult sr = mc.subscribe(mid, channel);
                sr.waitResult();
                int status = sr.getStatus();
                if (status != 0) {
                    System.out.println("\n\tTestClient.subscribe(" + this.monitorURL + ", " + jobId + ") -Suscribe failed: " + sr.getStatusStr());
                    System.exit(1);
                }
                System.out.println("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - Subscribe SUCCESSFUL. Waiting for data...");
                while (true) {
                    try {
                        java.lang.Thread.sleep(1000);
                    } catch (Exception e) {
                    }
                }
            } catch (MonitorException mex) {
                System.out.println("\n\tTestClient.subscribe(" + ml + "," + this.monitorURL + ", " + this.jobId + ") -- FAILED.");
                mex.printStackTrace();
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49247.java,208,241
default,44208.java,208,241
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88856.java,286,320
default,84498.java,286,320
----------------------------------------
        private void subscribe() {
            MetricListener ml = this;
            try {
                this.initFile(jobId);
                MonitorConsumer mc = new MonitorConsumer(this.monitorURL);
                mc.addMetricListener(ml);
                mc.auth();
                MonitorArg args[] = new MonitorArg[1];
                args[0] = new MonitorArg("jobid", jobId);
                MonitorConsumer.CollectResult cr = (MonitorConsumer.CollectResult) mc.collect("application.message", args);
                cr.waitResult();
                MonitorConsumer.MetricInstance suscribeMetric = cr.getMetricInstance();
                int mid = suscribeMetric.getMetricId();
                this.metricId = mid;
                int channel = mc.getChannelId();
                System.out.println("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - mid:" + mid);
                MonitorConsumer.CommandResult sr = mc.subscribe(mid, channel);
                sr.waitResult();
                int status = sr.getStatus();
                if (status != 0) {
                    System.out.println("\n\tTestClient.subscribe(" + this.monitorURL + ", " + jobId + ") -Suscribe failed: " + sr.getStatusStr());
                    System.exit(1);
                }
                System.out.println("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - Subscribe SUCCESSFUL. Waiting for data...");
                while (true) {
                    try {
                        java.lang.Thread.sleep(1000);
                    } catch (Exception e) {
                    }
                }
            } catch (MonitorException mex) {
                System.out.println("\n\tTestClient.subscribe(" + ml + "," + this.monitorURL + ", " + this.jobId + ") -- FAILED.");
                mex.printStackTrace();
            }
        }
----------------------------------------
        private void subscribe() {
            MetricListener ml = this;
            try {
                this.initFile(jobId);
                MonitorConsumer mc = new MonitorConsumer(this.monitorURL);
                mc.addMetricListener(ml);
                mc.auth();
                MonitorArg args[] = new MonitorArg[1];
                args[0] = new MonitorArg("jobid", jobId);
                MonitorConsumer.CollectResult cr = (MonitorConsumer.CollectResult) mc.collect("application.message", args);
                cr.waitResult();
                MonitorConsumer.MetricInstance suscribeMetric = cr.getMetricInstance();
                int mid = suscribeMetric.getMetricId();
                this.metricId = mid;
                int channel = mc.getChannelId();
                System.out.println("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - mid:" + mid);
                MonitorConsumer.CommandResult sr = mc.subscribe(mid, channel);
                sr.waitResult();
                int status = sr.getStatus();
                if (status != 0) {
                    System.out.println("\n\tTestClient.subscribe(" + this.monitorURL + ", " + jobId + ") -Suscribe failed: " + sr.getStatusStr());
                    System.exit(1);
                }
                System.out.println("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - Subscribe SUCCESSFUL. Waiting for data...");
                while (true) {
                    try {
                        java.lang.Thread.sleep(1000);
                    } catch (Exception e) {
                    }
                }
            } catch (MonitorException mex) {
                System.out.println("\n\tTestClient.subscribe(" + ml + "," + this.monitorURL + ", " + this.jobId + ") -- FAILED.");
                mex.printStackTrace();
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,85894.java,261,293
default,5224.java,261,293
----------------------------------------
    public void send(String[] args, int offset) throws InterruptedException, IOException, GeneralSecurityException {
        if (bufferSize > 0) {
            buffer = new byte[bufferSize];
        }
        long t1 = System.currentTimeMillis();
        for (int i = 0; i < repeatWhole; ++i) {
            ActiveAssociation active = openAssoc();
            if (active != null) {
                for (int k = offset; k < args.length; ++k) {
                    Dataset ds = null;
                    if (random) {
                        ds = datasets[rnd.nextInt(datasets.length)];
                        if (ds == null) ds = overwrite;
                        ds.putUI(Tags.StudyInstanceUID, uidGen.createUID());
                        ds.putUI(Tags.SeriesInstanceUID, uidGen.createUID());
                    } else if (complete) {
                        ds = datasets[(k - offset) % datasets.length];
                        if (ds == null) ds = overwrite;
                    } else if (datasets.length > (k - offset) && datasets[(k - offset)] != null) {
                        ds = datasets[(k - offset)];
                    }
                    if (ds != null) {
                        log.info("Used dataset for FILE/DIR " + args[k] + " :");
                        logDataset(ds);
                    }
                    send(active, new File(args[k]), ds);
                }
                active.release(true);
            }
        }
        long dt = System.currentTimeMillis() - t1;
        log.info(MessageFormat.format(messages.getString("sendDone"), new Object[] { new Integer(sentCount), new Long(sentBytes), new Long(dt), new Float(sentBytes / (1.024f * dt)) }));
    }
----------------------------------------
    public void send(String[] args, int offset) throws InterruptedException, IOException, GeneralSecurityException {
        if (bufferSize > 0) {
            buffer = new byte[bufferSize];
        }
        long t1 = System.currentTimeMillis();
        for (int i = 0; i < repeatWhole; ++i) {
            ActiveAssociation active = openAssoc();
            if (active != null) {
                for (int k = offset; k < args.length; ++k) {
                    Dataset ds = null;
                    if (random) {
                        ds = datasets[rnd.nextInt(datasets.length)];
                        if (ds == null) ds = overwrite;
                        ds.putUI(Tags.StudyInstanceUID, uidGen.createUID());
                        ds.putUI(Tags.SeriesInstanceUID, uidGen.createUID());
                    } else if (complete) {
                        ds = datasets[(k - offset) % datasets.length];
                        if (ds == null) ds = overwrite;
                    } else if (datasets.length > (k - offset) && datasets[(k - offset)] != null) {
                        ds = datasets[(k - offset)];
                    }
                    if (ds != null) {
                        log.info("Used dataset for FILE/DIR " + args[k] + " :");
                        logDataset(ds);
                    }
                    send(active, new File(args[k]), ds);
                }
                active.release(true);
            }
        }
        long dt = System.currentTimeMillis() - t1;
        log.info(MessageFormat.format(messages.getString("sendDone"), new Object[] { new Integer(sentCount), new Long(sentBytes), new Long(dt), new Float(sentBytes / (1.024f * dt)) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,85256.java,58,92
selected,1831571.java,56,88
----------------------------------------
    public void testRolledbackTx() throws Exception {
        getLog().debug("+++ testRolledbackTx");
        Context ctx = getInitialContext();
        getLog().debug("Obtain UserTransaction instance");
        UserTransaction userTx = (UserTransaction) ctx.lookup("UserTransaction");
        getLog().debug("Obtain home interface");
        Object objref = ctx.lookup("dtmtest/FrontEndEJB");
        FrontEndHome home = (FrontEndHome) PortableRemoteObject.narrow(objref, FrontEndHome.class);
        getLog().debug("Create FrontEnd bean");
        FrontEnd frontEnd = home.create("testRolledbackTx");
        getLog().debug("Set balances");
        userTx.begin();
        frontEnd.setBalances(101, 102, 103);
        userTx.commit();
        int balances[];
        getLog().debug("Get balances");
        userTx.begin();
        balances = frontEnd.getBalances();
        userTx.commit();
        assertTrue("first balance == 101", balances[0] == 101);
        assertTrue("second balance == 102", balances[1] == 102);
        assertTrue("third balance == 103", balances[2] == 103);
        getLog().debug("Update balances and rollback");
        userTx.begin();
        frontEnd.addToBalances(100);
        userTx.rollback();
        getLog().debug("Check that all balances remain the same");
        userTx.begin();
        balances = frontEnd.getBalances();
        userTx.commit();
        assertTrue("first balance == 101", balances[0] == 101);
        assertTrue("second balance == 102", balances[1] == 102);
        assertTrue("third balance == 103", balances[2] == 103);
        frontEnd.remove();
    }
----------------------------------------
    public void testRolledbackTx() throws Exception {
        getLog().debug("+++ testRolledbackTx");
        Context ctx = getInitialContext();
        getLog().debug("Obtain UserTransaction instance");
        UserTransaction userTx = (UserTransaction) ctx.lookup("UserTransaction");
        getLog().debug("Obtain home interface");
        Object objref = ctx.lookup("dtmtest/PassThrough2OtsEJB");
        PassThroughHome home = (PassThroughHome) PortableRemoteObject.narrow(objref, PassThroughHome.class);
        getLog().debug("Create PassThrough bean");
        PassThrough session = home.create("testRolledbackTx");
        getLog().debug("Set balances");
        userTx.begin();
        session.setBalances(101, 102);
        userTx.commit();
        int balances[];
        getLog().debug("Get balances");
        userTx.begin();
        balances = session.getBalances();
        userTx.commit();
        assertTrue("first balance == 101", balances[0] == 101);
        assertTrue("second balance == 102", balances[1] == 102);
        getLog().debug("Update balances and rollback");
        userTx.begin();
        session.addToBalances(100);
        userTx.rollback();
        getLog().debug("Check that all balances remain the same");
        userTx.begin();
        balances = session.getBalances();
        userTx.commit();
        assertTrue("first balance == 101", balances[0] == 101);
        assertTrue("second balance == 102", balances[1] == 102);
        session.remove();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2614295.java,114,148
selected,2262634.java,59,89
----------------------------------------
    public static String getResourceFileReferenceWithSHA256HashAsHexEncodedString(File file) {
        String extension = ResourceFileSupport.getExtensionWithDotOrEmptyString(file.getName(), true);
        long size = file.length();
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
            FileInputStream inputStream = new FileInputStream(file);
            messageDigest.update(getExtraBytes(size, extension));
            try {
                byte[] buffer = new byte[4096];
                int bytesRead = 0;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    messageDigest.update(buffer, 0, bytesRead);
                }
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            } finally {
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                    return null;
                }
            }
            byte[] hashSHA256 = messageDigest.digest();
            String resourceFileReference = ResourceFileSupport.ResourceFilePrefix + hexEncodedStringForByteArray(hashSHA256) + getExtraString(size, extension);
            return resourceFileReference;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
----------------------------------------
    public static String XgetSHA1HashAsHexEncodedString(File file) {
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
            FileInputStream inputStream = new FileInputStream(file);
            try {
                byte[] buffer = new byte[4096];
                int bytesRead = 0;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    messageDigest.update(buffer, 0, bytesRead);
                }
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            } finally {
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                    return null;
                }
            }
            byte[] hashSHA1 = messageDigest.digest();
            return hexEncodedStringForByteArray(hashSHA1);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2666453.java,788,820
selected,245970.java,585,618
----------------------------------------
    public void cosRegisterPeer(java.lang.String peerName, tcg.syscontrol.cos.ICosProcessManager p_peerManager) throws tcg.syscontrol.cos.CosFailedToRegisterException {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("cosRegisterPeer", true);
                    _os.write_string(peerName);
                    tcg.syscontrol.cos.ICosProcessManagerHelper.write(_os, p_peerManager);
                    _is = _invoke(_os);
                    return;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    if (_id.equals("IDL:tcg/syscontrol/cos/CosFailedToRegisterException:1.0")) {
                        throw tcg.syscontrol.cos.CosFailedToRegisterExceptionHelper.read(_ax.getInputStream());
                    }
                    throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("cosRegisterPeer", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                ICosProcessManagerOperations _localServant = (ICosProcessManagerOperations) _so.servant;
                try {
                    _localServant.cosRegisterPeer(peerName, p_peerManager);
                } finally {
                    _servant_postinvoke(_so);
                }
                return;
            }
        }
    }
----------------------------------------
    public void write_attributes_4(fr.esrf.Tango.AttributeValue_4[] values, fr.esrf.Tango.ClntIdent cl_ident) throws fr.esrf.Tango.MultiDevFailed, fr.esrf.Tango.DevFailed {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("write_attributes_4", true);
                    fr.esrf.Tango.AttributeValueList_4Helper.write(_os, values);
                    fr.esrf.Tango.ClntIdentHelper.write(_os, cl_ident);
                    _is = _invoke(_os);
                    return;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    if (_id.equals("IDL:Tango/MultiDevFailed:1.0")) {
                        throw fr.esrf.Tango.MultiDevFailedHelper.read(_ax.getInputStream());
                    } else if (_id.equals("IDL:Tango/DevFailed:1.0")) {
                        throw fr.esrf.Tango.DevFailedHelper.read(_ax.getInputStream());
                    } else throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("write_attributes_4", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                Device_4Operations _localServant = (Device_4Operations) _so.servant;
                try {
                    _localServant.write_attributes_4(values, cl_ident);
                } finally {
                    _servant_postinvoke(_so);
                }
                return;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80596.java,258,291
default,41445.java,258,291
----------------------------------------
    byte[] doAXFR(Name name, Message query, TSIG tsig, TSIGRecord qtsig, Socket s) {
        Zone zone = (Zone) znames.get(name);
        boolean first = true;
        if (zone == null) return errorMessage(query, Rcode.REFUSED);
        Iterator it = zone.AXFR();
        try {
            DataOutputStream dataOut;
            dataOut = new DataOutputStream(s.getOutputStream());
            int id = query.getHeader().getID();
            while (it.hasNext()) {
                RRset rrset = (RRset) it.next();
                Message response = new Message(id);
                Header header = response.getHeader();
                header.setFlag(Flags.QR);
                header.setFlag(Flags.AA);
                addRRset(rrset.getName(), response, rrset, Section.ANSWER, FLAG_DNSSECOK);
                if (tsig != null) {
                    tsig.applyStream(response, qtsig, first);
                    qtsig = response.getTSIG();
                }
                first = false;
                byte[] out = response.toWire();
                dataOut.writeShort(out.length);
                dataOut.write(out);
            }
        } catch (IOException ex) {
            System.out.println("AXFR failed");
        }
        try {
            s.close();
        } catch (IOException ex) {
        }
        return null;
    }
----------------------------------------
    byte[] doAXFR(Name name, Message query, TSIG tsig, TSIGRecord qtsig, Socket s) {
        Zone zone = (Zone) znames.get(name);
        boolean first = true;
        if (zone == null) return errorMessage(query, Rcode.REFUSED);
        Iterator it = zone.AXFR();
        try {
            DataOutputStream dataOut;
            dataOut = new DataOutputStream(s.getOutputStream());
            int id = query.getHeader().getID();
            while (it.hasNext()) {
                RRset rrset = (RRset) it.next();
                Message response = new Message(id);
                Header header = response.getHeader();
                header.setFlag(Flags.QR);
                header.setFlag(Flags.AA);
                addRRset(rrset.getName(), response, rrset, Section.ANSWER, FLAG_DNSSECOK);
                if (tsig != null) {
                    tsig.applyStream(response, qtsig, first);
                    qtsig = response.getTSIG();
                }
                first = false;
                byte[] out = response.toWire();
                dataOut.writeShort(out.length);
                dataOut.write(out);
            }
        } catch (IOException ex) {
            System.out.println("AXFR failed");
        }
        try {
            s.close();
        } catch (IOException ex) {
        }
        return null;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2666453.java,1052,1085
selected,2666453.java,1219,1247
----------------------------------------
    public java.lang.String cosGetProcessStatusString2(java.lang.String entity) throws tcg.syscontrol.cos.CosUnknownProcessException {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("cosGetProcessStatusString2", true);
                    _os.write_string(entity);
                    _is = _invoke(_os);
                    java.lang.String _result = _is.read_string();
                    return _result;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    if (_id.equals("IDL:tcg/syscontrol/cos/CosUnknownProcessException:1.0")) {
                        throw tcg.syscontrol.cos.CosUnknownProcessExceptionHelper.read(_ax.getInputStream());
                    }
                    throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("cosGetProcessStatusString2", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                ICosProcessManagerOperations _localServant = (ICosProcessManagerOperations) _so.servant;
                java.lang.String _result;
                try {
                    _result = _localServant.cosGetProcessStatusString2(entity);
                } finally {
                    _servant_postinvoke(_so);
                }
                return _result;
            }
        }
    }
----------------------------------------
    public void cosStartProcess(java.lang.String entity) {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("cosStartProcess", false);
                    _os.write_string(entity);
                    _is = _invoke(_os);
                    return;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("cosStartProcess", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                ICosProcessManagerOperations _localServant = (ICosProcessManagerOperations) _so.servant;
                try {
                    _localServant.cosStartProcess(entity);
                } finally {
                    _servant_postinvoke(_so);
                }
                return;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,978187.java,294,326
selected,595831.java,281,312
----------------------------------------
    private boolean saveLOBData() {
        if ((m_items == null) || (m_items.size() == 0)) {
            setBinaryData(null);
            return true;
        }
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ZipOutputStream zip = new ZipOutputStream(out);
        zip.setMethod(ZipOutputStream.DEFLATED);
        zip.setLevel(Deflater.BEST_COMPRESSION);
        zip.setComment("openXpertya");
        try {
            for (int i = 0; i < m_items.size(); i++) {
                MAttachmentEntry item = getEntry(i);
                ZipEntry entry = new ZipEntry(item.getName());
                entry.setTime(System.currentTimeMillis());
                entry.setMethod(ZipEntry.DEFLATED);
                zip.putNextEntry(entry);
                byte[] data = item.getData();
                zip.write(data, 0, data.length);
                zip.closeEntry();
                log.fine(entry.getName() + " - " + entry.getCompressedSize() + " (" + entry.getSize() + ") " + (entry.getCompressedSize() * 100 / entry.getSize()) + "%");
            }
            zip.close();
            byte[] zipData = out.toByteArray();
            log.fine("Length=" + zipData.length);
            setBinaryData(zipData);
            return true;
        } catch (Exception e) {
            log.log(Level.SEVERE, "saveLOBData", e);
        }
        setBinaryData(null);
        return false;
    }
----------------------------------------
    private boolean saveLOBData() {
        if ((m_items == null) || (m_items.size() == 0)) {
            setBinartyfile(null);
            return true;
        }
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ZipOutputStream zip = new ZipOutputStream(out);
        zip.setMethod(ZipOutputStream.DEFLATED);
        zip.setLevel(Deflater.BEST_COMPRESSION);
        zip.setComment("openXpertya");
        try {
            for (int i = 0; i < m_items.size(); i++) {
                MAttachmentEntry item = getEntry(i);
                ZipEntry entry = new ZipEntry(item.getName());
                entry.setTime(System.currentTimeMillis());
                entry.setMethod(ZipEntry.DEFLATED);
                zip.putNextEntry(entry);
                byte[] data = item.getData();
                zip.write(data, 0, data.length);
                zip.closeEntry();
            }
            zip.close();
            byte[] zipData = out.toByteArray();
            log.fine("Length=" + zipData.length);
            setBinartyfile(zipData);
            return true;
        } catch (Exception e) {
            log.log(Level.SEVERE, "saveLOBData", e);
        }
        setBinartyfile(null);
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2080871.java,13,46
selected,2080871.java,48,81
----------------------------------------
    public static ItemNotaFiscal selectByID(int codigo) {
        Connection c = DBConnection.getConnection();
        ItemNotaFiscal objINF = null;
        if (c == null) {
            return null;
        }
        if (codigo < 1) {
            return null;
        }
        String sql = "SELECT i.id_item_nota_fiscal, i.id_item_pedido, i.id_produto, " + "       i.quantidade, truncate(i.subtotal,2) as subtotal " + "FROM item_nota_fiscal i " + "where i.id_item_nota_fiscal = ? ";
        PreparedStatement pst = null;
        ResultSet rs = null;
        try {
            pst = c.prepareStatement(sql);
            pst.setInt(1, codigo);
            rs = pst.executeQuery();
            while (rs.next()) {
                objINF = new ItemNotaFiscal();
                objINF.setCodigo(rs.getInt("id_item_nota_fiscal"));
                objINF.setItemPedido(ItemPedidoDAO.selectByIDFromNotaFiscal(rs.getInt("id_item_pedido")));
                objINF.setProduto(ProdutoDAO.selectByID(rs.getString("id_produto")));
                objINF.setQuantidade(rs.getInt("quantidade"));
                objINF.setSubtotal(rs.getDouble("subtotal"));
            }
        } catch (Exception e) {
            System.out.println("[ItemNotaFiscalDAO.selectByID]" + e.getMessage());
            objINF = null;
        } finally {
            DBConnection.closeResultSet(rs);
            DBConnection.closePreparedStatement(pst);
            DBConnection.closeConnection(c);
        }
        return objINF;
    }
----------------------------------------
    public static ArrayList<ItemNotaFiscal> selectByNotaFiscal(int codigo) {
        Connection c = DBConnection.getConnection();
        ArrayList<ItemNotaFiscal> al = new ArrayList<ItemNotaFiscal>();
        ItemNotaFiscal objINF;
        if (c == null) {
            return null;
        }
        String sql = "SELECT i.id_item_nota_fiscal, i.id_item_pedido, i.id_produto, " + "       i.quantidade, truncate(i.subtotal,2) as subtotal " + "FROM item_nota_fiscal i, produto p " + "where i.id_nota_fiscal = ? " + "and i.id_produto = p.id_produto " + "order by p.nome";
        PreparedStatement pst = null;
        ResultSet rs = null;
        try {
            pst = c.prepareStatement(sql);
            pst.setInt(1, codigo);
            rs = pst.executeQuery();
            while (rs.next()) {
                objINF = new ItemNotaFiscal();
                objINF.setCodigo(rs.getInt("id_item_nota_fiscal"));
                objINF.setItemPedido(ItemPedidoDAO.selectByIDFromNotaFiscal(rs.getInt("id_item_pedido")));
                objINF.setProduto(ProdutoDAO.selectByID(rs.getString("id_produto")));
                objINF.setQuantidade(rs.getInt("quantidade"));
                objINF.setSubtotal(rs.getDouble("subtotal"));
                al.add(objINF);
                objINF = null;
            }
        } catch (Exception e) {
            System.out.println("[ItemNotaFiscalDAO.selectByNotaFiscal]" + e.getMessage());
            al = null;
        } finally {
            DBConnection.closeResultSet(rs);
            DBConnection.closePreparedStatement(pst);
            DBConnection.closeConnection(c);
        }
        return al;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,7660.java,469,503
default,7660.java,510,544
----------------------------------------
    public static Node exampleDOMtoDOM(String sourceID, String xslID) throws TransformerException, TransformerConfigurationException, SAXException, IOException, ParserConfigurationException, MalformedURLException {
        TransformerFactory tfactory = TransformerFactory.newInstance();
        if (tfactory.getFeature(DOMSource.FEATURE)) {
            Templates templates;
            {
                System.setProperty("javax.xml.parsers.DocumentBuilderFactory", "com.icl.saxon.om.DocumentBuilderFactoryImpl");
                DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
                System.err.println("Using DocumentBuilderFactory " + dfactory.getClass());
                dfactory.setNamespaceAware(true);
                DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
                System.err.println("Using DocumentBuilder " + docBuilder.getClass());
                org.w3c.dom.Document outNode = docBuilder.newDocument();
                Node doc = docBuilder.parse(new InputSource(new File(xslID).toURL().toString()));
                System.err.println("Stylesheet document built OK");
                DOMSource dsource = new DOMSource(doc);
                dsource.setSystemId(new File(xslID).toURL().toString());
                templates = tfactory.newTemplates(dsource);
            }
            Transformer transformer = templates.newTransformer();
            DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
            org.w3c.dom.Document outNode = docBuilder.newDocument();
            Node doc = docBuilder.parse(new InputSource(new File(sourceID).toURL().toString()));
            System.err.println("Source document built OK");
            DOMSource ds = new DOMSource(doc);
            ds.setSystemId(new File(sourceID).toURL().toString());
            transformer.transform(ds, new DOMResult(outNode));
            System.err.println("Transformation done OK");
            Transformer serializer = tfactory.newTransformer();
            serializer.transform(new DOMSource(outNode), new StreamResult(System.out));
            return outNode;
        } else {
            throw new org.xml.sax.SAXNotSupportedException("DOM node processing not supported!");
        }
    }
----------------------------------------
    public static void exampleDOMtoDOMNew(String sourceID, String xslID) throws TransformerException, TransformerConfigurationException, SAXException, IOException, ParserConfigurationException, MalformedURLException {
        TransformerFactory tfactory = TransformerFactory.newInstance();
        if (tfactory.getFeature(DOMSource.FEATURE)) {
            Templates templates;
            {
                System.setProperty("javax.xml.parsers.DocumentBuilderFactory", "com.icl.saxon.om.DocumentBuilderFactoryImpl");
                DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
                System.err.println("Using DocumentBuilderFactory " + dfactory.getClass());
                dfactory.setNamespaceAware(true);
                DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
                System.err.println("Using DocumentBuilder " + docBuilder.getClass());
                org.w3c.dom.Document outNode = docBuilder.newDocument();
                Node doc = docBuilder.parse(new InputSource(new File(xslID).toURL().toString()));
                System.err.println("Stylesheet document built OK");
                DOMSource dsource = new DOMSource(doc);
                dsource.setSystemId(new File(xslID).toURL().toString());
                templates = tfactory.newTemplates(dsource);
            }
            Transformer transformer = templates.newTransformer();
            DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
            Node doc = docBuilder.parse(new InputSource(new File(sourceID).toURL().toString()));
            System.err.println("Source document built OK");
            DOMSource ds = new DOMSource(doc);
            DOMResult result = new DOMResult();
            transformer.transform(ds, result);
            System.err.println("Transformation done OK");
            Transformer serializer = tfactory.newTransformer();
            serializer.transform(new DOMSource(result.getNode()), new StreamResult(System.out));
            int k = result.getNode().getChildNodes().getLength();
            System.err.println("Result root has " + k + " children");
        } else {
            throw new org.xml.sax.SAXNotSupportedException("DOM node processing not supported!");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,11981.java,1105,1137
default,60868.java,1105,1137
----------------------------------------
    private byte[] showTasks(HTTPurl urlData) throws Exception {
        StringBuffer out = new StringBuffer(2048);
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "TaskList.html");
        HashMap<String, TaskCommand> tasks = store.getTaskList();
        String[] key = (String[]) tasks.keySet().toArray(new String[0]);
        Arrays.sort(key);
        for (int x = 0; x < key.length; x++) {
            TaskCommand taskCommand = (TaskCommand) tasks.get(key[x]);
            out.append("<tr>\n");
            if (taskCommand.getEnabled()) {
                out.append("<td align='center'><a href='/servlet/" + urlData.getServletClass() + "?action=17&name=" + URLEncoder.encode(key[x], "UTF-8") + "&enabled=false'><img border='0' alt='Yes' src='/images/tick.png' width='24' height='24'></a></td>");
            } else {
                out.append("<td align='center'><a href='/servlet/" + urlData.getServletClass() + "?action=17&name=" + URLEncoder.encode(key[x], "UTF-8") + "&enabled=true'><img border='0' alt='No' src='/images/stop.png' width='24' height='24'></a></td>");
            }
            out.append("<td nowrap>" + key[x] + "</td>");
            out.append("<td nowrap>" + new Boolean(taskCommand.getAutoRemove()).toString() + "</td>");
            out.append("<td nowrap>" + new Integer(taskCommand.getDelay()).toString() + "</td>");
            out.append("<td>" + taskCommand.getCommand() + "</td>");
            out.append("<td align='center' nowrap>");
            out.append("<a class='noUnder' " + "href='/servlet/" + urlData.getServletClass() + "?action=22&name=" + URLEncoder.encode(key[x], "UTF-8") + "'>");
            out.append("<img src='/images/edit.png' border='0' alt='Edit' title='Edit' width='24' height='24'></a> ");
            out.append("<a class='noUnder' onClick='return confirmAction(\"Delete\");' " + "href='/servlet/" + urlData.getServletClass() + "?action=10&name=" + URLEncoder.encode(key[x], "UTF-8") + "'>");
            out.append("<img src='/images/delete.png' border='0' alt='Delete' title='Delete' width='24' height='24'></a> ");
            out.append("</td>");
            out.append("</tr>\n");
        }
        template.replaceAll("$taskList", out.toString());
        template.replaceAll("$defEpgTaskSelect", getTaskSelect("Tasks.DefTask"));
        template.replaceAll("$preTaskSelect", getTaskSelect("Tasks.PreTask"));
        template.replaceAll("$startErrorSelect", getTaskSelect("Tasks.StartErrorTask"));
        template.replaceAll("$noDataErrorSelect", getTaskSelect("Tasks.NoDataErrorTask"));
        return template.getPageBytes();
    }
----------------------------------------
    private byte[] showTasks(HTTPurl urlData) throws Exception {
        StringBuffer out = new StringBuffer(2048);
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "TaskList.html");
        HashMap<String, TaskCommand> tasks = store.getTaskList();
        String[] key = (String[]) tasks.keySet().toArray(new String[0]);
        Arrays.sort(key);
        for (int x = 0; x < key.length; x++) {
            TaskCommand taskCommand = (TaskCommand) tasks.get(key[x]);
            out.append("<tr>\n");
            if (taskCommand.getEnabled()) {
                out.append("<td align='center'><a href='/servlet/" + urlData.getServletClass() + "?action=17&name=" + URLEncoder.encode(key[x], "UTF-8") + "&enabled=false'><img border='0' alt='Yes' src='/images/tick.png' width='24' height='24'></a></td>");
            } else {
                out.append("<td align='center'><a href='/servlet/" + urlData.getServletClass() + "?action=17&name=" + URLEncoder.encode(key[x], "UTF-8") + "&enabled=true'><img border='0' alt='No' src='/images/stop.png' width='24' height='24'></a></td>");
            }
            out.append("<td nowrap>" + key[x] + "</td>");
            out.append("<td nowrap>" + new Boolean(taskCommand.getAutoRemove()).toString() + "</td>");
            out.append("<td nowrap>" + new Integer(taskCommand.getDelay()).toString() + "</td>");
            out.append("<td>" + taskCommand.getCommand() + "</td>");
            out.append("<td align='center' nowrap>");
            out.append("<a class='noUnder' " + "href='/servlet/" + urlData.getServletClass() + "?action=22&name=" + URLEncoder.encode(key[x], "UTF-8") + "'>");
            out.append("<img src='/images/edit.png' border='0' alt='Edit' title='Edit' width='24' height='24'></a> ");
            out.append("<a class='noUnder' onClick='return confirmAction(\"Delete\");' " + "href='/servlet/" + urlData.getServletClass() + "?action=10&name=" + URLEncoder.encode(key[x], "UTF-8") + "'>");
            out.append("<img src='/images/delete.png' border='0' alt='Delete' title='Delete' width='24' height='24'></a> ");
            out.append("</td>");
            out.append("</tr>\n");
        }
        template.replaceAll("$taskList", out.toString());
        template.replaceAll("$defEpgTaskSelect", getTaskSelect("Tasks.DefTask"));
        template.replaceAll("$preTaskSelect", getTaskSelect("Tasks.PreTask"));
        template.replaceAll("$startErrorSelect", getTaskSelect("Tasks.StartErrorTask"));
        template.replaceAll("$noDataErrorSelect", getTaskSelect("Tasks.NoDataErrorTask"));
        return template.getPageBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2345442.java,8,40
selected,2576682.java,8,39
----------------------------------------
    public boolean download(String address, String localFileName) {
        OutputStream out = null;
        URLConnection conn = null;
        InputStream in = null;
        boolean result = false;
        try {
            URL url = new URL(address);
            out = new BufferedOutputStream(new FileOutputStream(localFileName));
            conn = url.openConnection();
            in = conn.getInputStream();
            byte[] buffer = new byte[1024];
            int numRead;
            long numWritten = 0;
            while ((numRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, numRead);
                numWritten += numRead;
            }
            result = true;
        } catch (Exception exception) {
            System.out.println(exception.toString());
        } finally {
            try {
                if (in != null) {
                    in.close();
                }
                if (out != null) {
                    out.close();
                }
            } catch (IOException ioe) {
            }
            return result;
        }
    }
----------------------------------------
    public boolean download(String address, String localFileName) {
        OutputStream out = null;
        URLConnection conn = null;
        InputStream in = null;
        try {
            URL url = new URL(address);
            out = new BufferedOutputStream(new FileOutputStream(localFileName));
            conn = url.openConnection();
            in = conn.getInputStream();
            byte[] buffer = new byte[1024];
            int numRead;
            long numWritten = 0;
            while ((numRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, numRead);
                numWritten += numRead;
            }
            return true;
        } catch (Exception exception) {
            exception.printStackTrace();
        } finally {
            try {
                if (in != null) {
                    in.close();
                }
                if (out != null) {
                    out.close();
                }
            } catch (IOException ioe) {
            }
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25960.java,765,796
default,21199.java,816,847
----------------------------------------
    private byte[] showStationList(HTTPurl urlData) throws Exception {
        int country = 0;
        int region = 0;
        try {
            country = Integer.parseInt(urlData.getParameter("country"));
            region = Integer.parseInt(urlData.getParameter("region"));
        } catch (Exception e) {
            throw new Exception("country or region code not valid: " + e.toString());
        }
        ChannelList list = new ChannelList(store.getProperty("path.data") + File.separator + "stationdata.list");
        StringBuffer buff = new StringBuffer(1024);
        Channel[] channelList = list.getStations(country, region);
        list.close();
        buff.append("<table><tr><td><ul>\n");
        for (int x = 0; x < channelList.length; x++) {
            if (channelList[x] != null) {
                buff.append("<li>\n");
                buff.append("<a href='/servlet/" + urlData.getServletClass() + "?action=04&freq=" + channelList[x].getFrequency());
                buff.append("&band=" + channelList[x].getBandWidth() + "&name=" + channelList[x].getName() + "' class='noUnder'>");
                buff.append(channelList[x].getName() + "</a>\n");
                buff.append("</li>\n");
            }
        }
        buff.append("<li>\n");
        buff.append("<a href='/servlet/" + urlData.getServletClass() + "?action=07&country=" + country);
        buff.append("&region=" + region + "' class='noUnder'>SCAN ALL</a>\n");
        buff.append("</li>\n");
        buff.append("</ul></td></tr></table>\n");
        PageTemplate template = new PageTemplate(store.getProperty("path.template").replace('\\', File.separatorChar) + File.separator + "channel-stationlist.html");
        template.replaceAll("$stations", buff.toString());
        return template.getPageBytes();
    }
----------------------------------------
    private byte[] showStationList(HTTPurl urlData) throws Exception {
        int country = 0;
        int region = 0;
        try {
            country = Integer.parseInt(urlData.getParameter("country"));
            region = Integer.parseInt(urlData.getParameter("region"));
        } catch (Exception e) {
            throw new Exception("country or region code not valid: " + e.toString());
        }
        ChannelList list = new ChannelList(store.getProperty("path.data") + File.separator + "stationdata.list");
        StringBuffer buff = new StringBuffer(1024);
        Channel[] channelList = list.getStations(country, region);
        list.close();
        buff.append("<table><tr><td><ul>\n");
        for (int x = 0; x < channelList.length; x++) {
            if (channelList[x] != null) {
                buff.append("<li>\n");
                buff.append("<a href='/servlet/" + urlData.getServletClass() + "?action=04&freq=" + channelList[x].getFrequency());
                buff.append("&band=" + channelList[x].getBandWidth() + "&name=" + channelList[x].getName() + "' class='noUnder'>");
                buff.append(channelList[x].getName() + "</a>\n");
                buff.append("</li>\n");
            }
        }
        buff.append("<li>\n");
        buff.append("<a href='/servlet/" + urlData.getServletClass() + "?action=07&country=" + country);
        buff.append("&region=" + region + "' class='noUnder'>SCAN ALL</a>\n");
        buff.append("</li>\n");
        buff.append("</ul></td></tr></table>\n");
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "channel-stationlist.html");
        template.replaceAll("$stations", buff.toString());
        return template.getPageBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1326963.java,128,158
selected,2668561.java,628,660
----------------------------------------
    private boolean _jspx_meth_html_005flink_005f0(PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.struts.taglib.html.LinkTag _jspx_th_html_005flink_005f0 = (org.apache.struts.taglib.html.LinkTag) _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.get(org.apache.struts.taglib.html.LinkTag.class);
        _jspx_th_html_005flink_005f0.setPageContext(_jspx_page_context);
        _jspx_th_html_005flink_005f0.setParent(null);
        _jspx_th_html_005flink_005f0.setStyleId("incluir");
        _jspx_th_html_005flink_005f0.setHref("login.do");
        int _jspx_eval_html_005flink_005f0 = _jspx_th_html_005flink_005f0.doStartTag();
        if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_html_005flink_005f0.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_html_005flink_005f0.doInitBody();
            }
            do {
                out.write("Início");
                int evalDoAfterBody = _jspx_th_html_005flink_005f0.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_html_005flink_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f0);
            return true;
        }
        _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f0);
        return false;
    }
----------------------------------------
    private boolean _jspx_meth_mytag_005fList_005f0(PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        com.zhongkai.web.tag.ListTag _jspx_th_mytag_005fList_005f0 = (com.zhongkai.web.tag.ListTag) _005fjspx_005ftagPool_005fmytag_005fList_0026_005ftable_005fname_005ffield.get(com.zhongkai.web.tag.ListTag.class);
        _jspx_th_mytag_005fList_005f0.setPageContext(_jspx_page_context);
        _jspx_th_mytag_005fList_005f0.setParent(null);
        _jspx_th_mytag_005fList_005f0.setField("actionKey");
        _jspx_th_mytag_005fList_005f0.setName("menuActionList");
        _jspx_th_mytag_005fList_005f0.setTable("Action");
        int _jspx_eval_mytag_005fList_005f0 = _jspx_th_mytag_005fList_005f0.doStartTag();
        if (_jspx_eval_mytag_005fList_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_mytag_005fList_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_mytag_005fList_005f0.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_mytag_005fList_005f0.doInitBody();
            }
            do {
                out.write("actionType=0 and roleId=");
                out.write((java.lang.String) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${role.roleId }", java.lang.String.class, (PageContext) _jspx_page_context, null, false));
                int evalDoAfterBody = _jspx_th_mytag_005fList_005f0.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_mytag_005fList_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_mytag_005fList_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fmytag_005fList_0026_005ftable_005fname_005ffield.reuse(_jspx_th_mytag_005fList_005f0);
            return true;
        }
        _005fjspx_005ftagPool_005fmytag_005fList_0026_005ftable_005fname_005ffield.reuse(_jspx_th_mytag_005fList_005f0);
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2108660.java,654,686
selected,2365821.java,575,605
----------------------------------------
    public static byte[] decode(byte[] source, int off, int len, int options) {
        byte[] DECODABET = getDecodabet(options);
        int len34 = len * 3 / 4;
        byte[] outBuff = new byte[len34];
        int outBuffPosn = 0;
        byte[] b4 = new byte[4];
        int b4Posn = 0;
        int i = 0;
        byte sbiCrop = 0;
        byte sbiDecode = 0;
        for (i = off; i < off + len; i++) {
            sbiCrop = (byte) (source[i] & 0x7f);
            sbiDecode = DECODABET[sbiCrop];
            if (sbiDecode >= WHITE_SPACE_ENC) {
                if (sbiDecode >= EQUALS_SIGN_ENC) {
                    b4[b4Posn++] = sbiCrop;
                    if (b4Posn > 3) {
                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);
                        b4Posn = 0;
                        if (sbiCrop == EQUALS_SIGN) {
                            break;
                        }
                    }
                }
            } else {
                System.err.println("Bad Base64 input character at " + i + ": " + source[i] + "(decimal)");
                return null;
            }
        }
        byte[] out = new byte[outBuffPosn];
        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
        return out;
    }
----------------------------------------
    public static byte[] decode(byte[] source, int off, int len, int options) {
        byte[] DECODABET = getDecodabet(options);
        int len34 = len * 3 / 4;
        byte[] outBuff = new byte[len34];
        int outBuffPosn = 0;
        byte[] b4 = new byte[4];
        int b4Posn = 0;
        int i = 0;
        byte sbiCrop = 0;
        byte sbiDecode = 0;
        for (i = off; i < off + len; i++) {
            sbiCrop = (byte) (source[i] & 0x7f);
            sbiDecode = DECODABET[sbiCrop];
            if (sbiDecode >= WHITE_SPACE_ENC) {
                if (sbiDecode >= EQUALS_SIGN_ENC) {
                    b4[b4Posn++] = sbiCrop;
                    if (b4Posn > 3) {
                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);
                        b4Posn = 0;
                        if (sbiCrop == EQUALS_SIGN) break;
                    }
                }
            } else {
                System.err.println("Bad Base64 input character at " + i + ": " + source[i] + "(decimal)");
                return null;
            }
        }
        byte[] out = new byte[outBuffPosn];
        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
        return out;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94308.java,51,82
default,49246.java,51,82
----------------------------------------
    static void write_file_test(boolean displayTime, boolean withSubDirs, boolean createDirs, int first, int iterations) {
        File f;
        FileOutputStream s;
        int i = 0, num;
        try {
            if (createDirs) {
                f = new File("tmp");
                if (!f.exists()) f.mkdir();
                f = new File("tmp/blobs");
                if (!f.exists()) f.mkdir();
                if (withSubDirs) {
                    for (i = 0; i < 100; i++) {
                        f = new File("tmp/blobs/dir" + i + "/");
                        if (!f.exists()) f.mkdir();
                    }
                }
            }
            long start = System.currentTimeMillis();
            for (i = 0; i < iterations; i++) {
                num = first + i;
                if (withSubDirs) f = new File("tmp/blobs/dir" + (num % 100) + "/blob" + num); else f = new File("tmp/blobs/blob" + num);
                f.createNewFile();
                s = new FileOutputStream(f);
                s.write("This is an example of an uploaded BLOB".getBytes());
                s.close();
            }
            long stop = System.currentTimeMillis();
            if (displayTime) printTime(start, stop, iterations);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
----------------------------------------
    static void write_file_test(boolean displayTime, boolean withSubDirs, boolean createDirs, int first, int iterations) {
        File f;
        FileOutputStream s;
        int i = 0, num;
        try {
            if (createDirs) {
                f = new File("tmp");
                if (!f.exists()) f.mkdir();
                f = new File("tmp/blobs");
                if (!f.exists()) f.mkdir();
                if (withSubDirs) {
                    for (i = 0; i < 100; i++) {
                        f = new File("tmp/blobs/dir" + i + "/");
                        if (!f.exists()) f.mkdir();
                    }
                }
            }
            long start = System.currentTimeMillis();
            for (i = 0; i < iterations; i++) {
                num = first + i;
                if (withSubDirs) f = new File("tmp/blobs/dir" + (num % 100) + "/blob" + num); else f = new File("tmp/blobs/blob" + num);
                f.createNewFile();
                s = new FileOutputStream(f);
                s.write("This is an example of an uploaded BLOB".getBytes());
                s.close();
            }
            long stop = System.currentTimeMillis();
            if (displayTime) printTime(start, stop, iterations);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,123451.java,355,387
default,36772.java,357,389
----------------------------------------
    public void TCPclient(Socket s) {
        try {
            int inLength;
            DataInputStream dataIn;
            DataOutputStream dataOut;
            byte[] in;
            InputStream is = s.getInputStream();
            dataIn = new DataInputStream(is);
            inLength = dataIn.readUnsignedShort();
            in = new byte[inLength];
            dataIn.readFully(in);
            Message query;
            byte[] response = null;
            try {
                query = new Message(in);
                response = generateReply(query, in, in.length, s);
                if (response == null) return;
            } catch (IOException e) {
                response = formerrMessage(in);
            }
            dataOut = new DataOutputStream(s.getOutputStream());
            dataOut.writeShort(response.length);
            dataOut.write(response);
        } catch (IOException e) {
            String addrString;
            System.out.println("TCPclient(" + s.getLocalAddress().getHostAddress() + "#" + s.getLocalPort() + "): " + e);
        } finally {
            try {
                s.close();
            } catch (IOException e) {
            }
        }
    }
----------------------------------------
    public void TCPclient(Socket s) {
        try {
            int inLength;
            DataInputStream dataIn;
            DataOutputStream dataOut;
            byte[] in;
            InputStream is = s.getInputStream();
            dataIn = new DataInputStream(is);
            inLength = dataIn.readUnsignedShort();
            in = new byte[inLength];
            dataIn.readFully(in);
            Message query;
            byte[] response = null;
            try {
                query = new Message(in);
                response = generateReply(query, in, in.length, s);
                if (response == null) return;
            } catch (IOException e) {
                response = formerrMessage(in);
            }
            dataOut = new DataOutputStream(s.getOutputStream());
            dataOut.writeShort(response.length);
            dataOut.write(response);
        } catch (IOException e) {
            String addrString;
            System.out.println("TCPclient(" + s.getLocalAddress().getHostAddress() + "#" + s.getLocalPort() + "): " + e);
        } finally {
            try {
                s.close();
            } catch (IOException e) {
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80614.java,254,285
default,105999.java,254,285
----------------------------------------
    private void examineFiles(File a, File b) {
        filesAreIdentical = true;
        filesAreBinary = false;
        if (a == null || b == null) filesAreIdentical = false; else if (a.length() != b.length()) filesAreIdentical = false;
        Reader inA = null, inB = null;
        try {
            if (a != null) inA = new BufferedReader(new FileReader(a));
            if (b != null) inB = new BufferedReader(new FileReader(b));
            int charA = -2, charB = -2;
            int count = 0;
            while (true) {
                if (inA != null && charA != -1) charA = inA.read();
                if (inB != null && charB != -1) charB = inB.read();
                if (charA != charB) filesAreIdentical = false;
                if (charA == 0 || charB == 0) {
                    filesAreBinary = true;
                    break;
                }
                if ((charA == -1 && charB == -1) || (count++ > 4096 && !filesAreIdentical)) break;
            }
        } catch (IOException ioe) {
        } finally {
            try {
                if (inA != null) inA.close();
            } catch (IOException i) {
            }
            try {
                if (inB != null) inB.close();
            } catch (IOException i) {
            }
        }
    }
----------------------------------------
    private void examineFiles(File a, File b) {
        filesAreIdentical = true;
        filesAreBinary = false;
        if (a == null || b == null) filesAreIdentical = false; else if (a.length() != b.length()) filesAreIdentical = false;
        Reader inA = null, inB = null;
        try {
            if (a != null) inA = new BufferedReader(new FileReader(a));
            if (b != null) inB = new BufferedReader(new FileReader(b));
            int charA = -2, charB = -2;
            int count = 0;
            while (true) {
                if (inA != null && charA != -1) charA = inA.read();
                if (inB != null && charB != -1) charB = inB.read();
                if (charA != charB) filesAreIdentical = false;
                if (charA == 0 || charB == 0) {
                    filesAreBinary = true;
                    break;
                }
                if ((charA == -1 && charB == -1) || (count++ > 4096 && !filesAreIdentical)) break;
            }
        } catch (IOException ioe) {
        } finally {
            try {
                if (inA != null) inA.close();
            } catch (IOException i) {
            }
            try {
                if (inB != null) inB.close();
            } catch (IOException i) {
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5567.java,358,389
default,36772.java,357,389
----------------------------------------
    public void TCPclient(Socket s) {
        try {
            int inLength;
            DataInputStream dataIn;
            DataOutputStream dataOut;
            byte[] in;
            InputStream is = s.getInputStream();
            dataIn = new DataInputStream(is);
            inLength = dataIn.readUnsignedShort();
            in = new byte[inLength];
            dataIn.readFully(in);
            Message query;
            byte[] response = null;
            try {
                query = new Message(in);
                response = generateReply(query, in, in.length, s);
                if (response == null) return;
            } catch (IOException e) {
                response = formerrMessage(in);
            }
            dataOut = new DataOutputStream(s.getOutputStream());
            dataOut.writeShort(response.length);
            dataOut.write(response);
        } catch (IOException e) {
            System.out.println("TCPclient(" + addrport(s.getLocalAddress(), s.getLocalPort()) + "): " + e);
        } finally {
            try {
                s.close();
            } catch (IOException e) {
            }
        }
    }
----------------------------------------
    public void TCPclient(Socket s) {
        try {
            int inLength;
            DataInputStream dataIn;
            DataOutputStream dataOut;
            byte[] in;
            InputStream is = s.getInputStream();
            dataIn = new DataInputStream(is);
            inLength = dataIn.readUnsignedShort();
            in = new byte[inLength];
            dataIn.readFully(in);
            Message query;
            byte[] response = null;
            try {
                query = new Message(in);
                response = generateReply(query, in, in.length, s);
                if (response == null) return;
            } catch (IOException e) {
                response = formerrMessage(in);
            }
            dataOut = new DataOutputStream(s.getOutputStream());
            dataOut.writeShort(response.length);
            dataOut.write(response);
        } catch (IOException e) {
            String addrString;
            System.out.println("TCPclient(" + s.getLocalAddress().getHostAddress() + "#" + s.getLocalPort() + "): " + e);
        } finally {
            try {
                s.close();
            } catch (IOException e) {
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,225359.java,151,181
selected,102108.java,1104,1136
----------------------------------------
    private boolean _jspx_meth_html_005flink_005f0(PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.struts.taglib.html.LinkTag _jspx_th_html_005flink_005f0 = (org.apache.struts.taglib.html.LinkTag) _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.get(org.apache.struts.taglib.html.LinkTag.class);
        _jspx_th_html_005flink_005f0.setPageContext(_jspx_page_context);
        _jspx_th_html_005flink_005f0.setParent(null);
        _jspx_th_html_005flink_005f0.setStyleId("incluir");
        _jspx_th_html_005flink_005f0.setHref("login.do");
        int _jspx_eval_html_005flink_005f0 = _jspx_th_html_005flink_005f0.doStartTag();
        if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_html_005flink_005f0.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_html_005flink_005f0.doInitBody();
            }
            do {
                out.write("Início");
                int evalDoAfterBody = _jspx_th_html_005flink_005f0.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_html_005flink_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f0);
            return true;
        }
        _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f0);
        return false;
    }
----------------------------------------
    private boolean _jspx_meth_html_005flink_005f4(javax.servlet.jsp.tagext.JspTag _jspx_th_c_005fif_005f1, PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.struts.taglib.html.LinkTag _jspx_th_html_005flink_005f4 = (org.apache.struts.taglib.html.LinkTag) _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fstyleClass_005fonclick_005fhref.get(org.apache.struts.taglib.html.LinkTag.class);
        _jspx_th_html_005flink_005f4.setPageContext(_jspx_page_context);
        _jspx_th_html_005flink_005f4.setParent((javax.servlet.jsp.tagext.Tag) _jspx_th_c_005fif_005f1);
        _jspx_th_html_005flink_005f4.setStyleId("linkEditar");
        _jspx_th_html_005flink_005f4.setHref("#");
        _jspx_th_html_005flink_005f4.setOnclick("salvar()");
        _jspx_th_html_005flink_005f4.setStyleClass("botao");
        int _jspx_eval_html_005flink_005f4 = _jspx_th_html_005flink_005f4.doStartTag();
        if (_jspx_eval_html_005flink_005f4 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_html_005flink_005f4 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_html_005flink_005f4.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_html_005flink_005f4.doInitBody();
            }
            do {
                out.write("Salvar");
                int evalDoAfterBody = _jspx_th_html_005flink_005f4.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_html_005flink_005f4 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_html_005flink_005f4.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fstyleClass_005fonclick_005fhref.reuse(_jspx_th_html_005flink_005f4);
            return true;
        }
        _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fstyleClass_005fonclick_005fhref.reuse(_jspx_th_html_005flink_005f4);
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1948930.java,41,71
selected,2119863.java,46,76
----------------------------------------
    private void zipDir(File zipDir, ZipOutputStream zos, String startingPath, PXBuildContext context) {
        try {
            String[] dirList = zipDir.list();
            byte[] readBuffer = new byte[2156];
            int bytesIn = 0;
            for (int i = 0; i < dirList.length; i++) {
                File f = new File(zipDir, dirList[i]);
                String entryPath = f.getPath();
                if (entryPath.startsWith(startingPath)) {
                    entryPath = entryPath.substring(startingPath.length(), entryPath.length());
                }
                if (f.isDirectory()) {
                    String filePath = entryPath;
                    zipDir(f, zos, startingPath, context);
                    continue;
                }
                FileInputStream fis = new FileInputStream(f);
                ZipEntry anEntry = new ZipEntry(entryPath);
                zos.putNextEntry(anEntry);
                while ((bytesIn = fis.read(readBuffer)) != -1) {
                    zos.write(readBuffer, 0, bytesIn);
                }
                fis.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
            NSDictionary info = new NSDictionary(new Object[] { e.getMessage() }, new String[] { NSError.LocalizedDescriptionKey });
            NSError message = new NSError("Pachyderm Build Domain", -1, info);
            context.appendBuildMessage(message);
        }
    }
----------------------------------------
    private void zipDir(File zipDir, ZipOutputStream zos, String startingPath, PXBuildContext context) {
        try {
            String[] dirList = zipDir.list();
            byte[] readBuffer = new byte[2156];
            int bytesIn = 0;
            for (int i = 0; i < dirList.length; i++) {
                File f = new File(zipDir, dirList[i]);
                String entryPath = f.getPath();
                if (entryPath.startsWith(startingPath)) {
                    entryPath = entryPath.substring(startingPath.length(), entryPath.length());
                }
                if (f.isDirectory()) {
                    @SuppressWarnings("unused") String filePath = entryPath;
                    zipDir(f, zos, startingPath, context);
                    continue;
                }
                FileInputStream fis = new FileInputStream(f);
                ZipEntry anEntry = new ZipEntry(entryPath);
                zos.putNextEntry(anEntry);
                while ((bytesIn = fis.read(readBuffer)) != -1) {
                    zos.write(readBuffer, 0, bytesIn);
                }
                fis.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
            NSDictionary info = new NSDictionary(new Object[] { e.getMessage() }, new String[] { NSError.LocalizedDescriptionKey });
            NSError message = new NSError("Pachyderm Build Domain", -1, info);
            context.appendBuildMessage(message);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,802295.java,181,213
selected,2039524.java,92,124
----------------------------------------
    private void saveNativesJarLocally(File localJarFile, URLConnection urlConnection) throws Exception {
        BufferedOutputStream out = null;
        ;
        InputStream in = null;
        try {
            out = new BufferedOutputStream(new FileOutputStream(localJarFile));
            int totalLength = urlConnection.getContentLength();
            in = urlConnection.getInputStream();
            byte[] buffer = new byte[1024];
            int len;
            int sum = 0;
            while ((len = in.read(buffer)) > 0) {
                out.write(buffer, 0, len);
                sum += len;
                int percent = (100 * sum / totalLength);
            }
            out.close();
            in.close();
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException ignore) {
                }
            }
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
----------------------------------------
    protected void downloadJar(URL downloadURL, File jarFile, IProgressListener pl) {
        BufferedOutputStream out = null;
        InputStream in = null;
        URLConnection urlConnection = null;
        try {
            urlConnection = downloadURL.openConnection();
            out = new BufferedOutputStream(new FileOutputStream(jarFile));
            in = urlConnection.getInputStream();
            int len = in.available();
            Log.log("downloading jar with size: " + urlConnection.getContentLength());
            if (len < 1) len = 1024;
            byte[] buffer = new byte[len];
            while ((len = in.read(buffer)) > 0) {
                out.write(buffer, 0, len);
            }
            out.close();
            in.close();
        } catch (Exception e) {
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException ignore) {
                }
            }
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109329.java,754,784
default,75028.java,663,694
----------------------------------------
    protected FB getFB(Element fbElem) {
        if (fbElem != null && fbElem.getName().equals("FB")) {
            List content = fbElem.getChildren();
            int size = content.size();
            String Name = fbElem.getAttributeValue("Name");
            String Type = fbElem.getAttributeValue("Type");
            String Comment = fbElem.getAttributeValue("Comment");
            String x = fbElem.getAttributeValue("x");
            String y = fbElem.getAttributeValue("y");
            Hashtable<String, Parameter> hashTable = new Hashtable<String, Parameter>(size);
            FB fb;
            if (size > 0) {
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    Parameter parameter = getParameter(currentElement);
                    hashTable.put(Name, parameter);
                }
                fb = new FB(Name, Type, Comment, x, y, hashTable);
            } else {
                fb = new FB(Name, Type, Comment, x, y, null);
            }
            return fb;
        } else {
            System.err.println("Invalid element input in getFB()");
            if (this.console != null) {
                console.setText("Invalid element input in getFB()");
            }
            return null;
        }
    }
----------------------------------------
    protected ECState getECState(Element ecStateElem) {
        if (ecStateElem != null && ecStateElem.getName().equals("ECState")) {
            List content = ecStateElem.getChildren();
            int size = content.size();
            String Name = ecStateElem.getAttributeValue("Name");
            String Comment = ecStateElem.getAttributeValue("Comment");
            String x = ecStateElem.getAttributeValue("x");
            String y = ecStateElem.getAttributeValue("y");
            Hashtable<Integer, ECAction> hashTable = new Hashtable<Integer, ECAction>(size);
            ECState ecState;
            if (size > 0) {
                Iterator iterator = content.iterator();
                int count = 0;
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    ECAction ecAction = getECAction(currentElement);
                    hashTable.put(new Integer(count), ecAction);
                    count++;
                }
                ecState = new ECState(Name, Comment, x, y, hashTable);
            } else {
                ecState = new ECState(Name, Comment, x, y, null);
            }
            return ecState;
        } else {
            System.err.println("Invalid element input in getECState()");
            if (this.console != null) {
                console.setText("Invalid element input in getECState()");
            }
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109329.java,497,525
default,75028.java,1210,1241
----------------------------------------
    protected AdapterDeclaration getAdapterDeclaration(Element adapterDeclarationElem) {
        if (adapterDeclarationElem != null && adapterDeclarationElem.getName().equals("Parameter")) {
            List content = adapterDeclarationElem.getChildren();
            int size = content.size();
            String Name = adapterDeclarationElem.getAttributeValue("Name");
            String Type = adapterDeclarationElem.getAttributeValue("Type");
            String Comment = adapterDeclarationElem.getAttributeValue("Comment");
            Hashtable<String, Parameter> hashTable = new Hashtable<String, Parameter>(size);
            AdapterDeclaration adapterDeclaration;
            if (size > 0) {
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    Parameter parameter = getParameter(currentElement);
                    hashTable.put(Name, parameter);
                }
                adapterDeclaration = new AdapterDeclaration(Name, Type, Comment, hashTable);
            } else {
                adapterDeclaration = new AdapterDeclaration(Name, Type, Comment, null);
            }
            return adapterDeclaration;
        } else {
            System.err.println("Invalid element input in getAdapterDeclaration()");
            if (this.console != null) {
                console.setText("Invalid element input in getAdapterDeclaration()");
            }
            return null;
        }
    }
----------------------------------------
    protected Service getService(Element serviceElem) {
        if (serviceElem != null && serviceElem.getName().equals("Service")) {
            List content = serviceElem.getChildren();
            int size = content.size();
            String RightInterface = serviceElem.getAttributeValue("RightInterface");
            String LeftInterface = serviceElem.getAttributeValue("LeftInterface");
            String Comment = serviceElem.getAttributeValue("Comment");
            if (size > 0) {
                Hashtable<String, ServiceSequence> hashTable = new Hashtable<String, ServiceSequence>(size);
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    ServiceSequence serviceSequence = getServiceSequence(currentElement);
                    hashTable.put(serviceSequence.getName(), serviceSequence);
                }
                Service service = new Service(RightInterface, LeftInterface, Comment, hashTable);
                return service;
            } else {
                System.err.println("Invalid child element size in getService()");
                if (this.console != null) {
                    console.setText("Invalid child element size in getService()");
                }
                return null;
            }
        } else {
            System.err.println("Invalid element input in getService()");
            if (this.console != null) {
                console.setText("Invalid element input in getService()");
            }
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,123461.java,426,457
default,63353.java,426,457
----------------------------------------
    static void printHeader() {
        pl("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        pl("<!DOCTYPE configuration SYSTEM \"../configuration.dtd\">");
        pl("<!--");
        pl("        	");
        pl("");
        pl("        Copyright  1990-2008 Sun Microsystems, Inc. All Rights Reserved.");
        pl("        DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER");
        pl("        ");
        pl("        This program is free software; you can redistribute it and/or");
        pl("        modify it under the terms of the GNU General Public License version");
        pl("        2 only, as published by the Free Software Foundation.");
        pl("        ");
        pl("        This program is distributed in the hope that it will be useful, but");
        pl("        WITHOUT ANY WARRANTY; without even the implied warranty of");
        pl("        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU");
        pl("        General Public License version 2 for more details (a copy is");
        pl("        included at /legal/license.txt).");
        pl("        ");
        pl("        You should have received a copy of the GNU General Public License");
        pl("        version 2 along with this work; if not, write to the Free Software");
        pl("        Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA");
        pl("        02110-1301 USA");
        pl("        ");
        pl("        Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa");
        pl("        Clara, CA 95054 or visit www.sun.com if you need additional");
        pl("        information or have any questions.");
        pl("-->");
        pl("<configuration>");
        pl("<skin>");
        pl("<skin_properties KeysClass=" + "\"com.sun.midp.chameleon.skins.SkinPropertiesIDs\">");
    }
----------------------------------------
    static void printHeader() {
        pl("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        pl("<!DOCTYPE configuration SYSTEM \"../configuration.dtd\">");
        pl("<!--");
        pl("        	");
        pl("");
        pl("        Copyright  1990-2007 Sun Microsystems, Inc. All Rights Reserved.");
        pl("        DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER");
        pl("        ");
        pl("        This program is free software; you can redistribute it and/or");
        pl("        modify it under the terms of the GNU General Public License version");
        pl("        2 only, as published by the Free Software Foundation.");
        pl("        ");
        pl("        This program is distributed in the hope that it will be useful, but");
        pl("        WITHOUT ANY WARRANTY; without even the implied warranty of");
        pl("        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU");
        pl("        General Public License version 2 for more details (a copy is");
        pl("        included at /legal/license.txt).");
        pl("        ");
        pl("        You should have received a copy of the GNU General Public License");
        pl("        version 2 along with this work; if not, write to the Free Software");
        pl("        Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA");
        pl("        02110-1301 USA");
        pl("        ");
        pl("        Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa");
        pl("        Clara, CA 95054 or visit www.sun.com if you need additional");
        pl("        information or have any questions.");
        pl("-->");
        pl("<configuration>");
        pl("<skin>");
        pl("<skin_properties KeysClass=" + "\"com.sun.midp.chameleon.skins.SkinPropertiesIDs\">");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,89968.java,346,377
default,50607.java,349,379
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,91489.java,16,45
default,47921.java,16,45
----------------------------------------
    public jnamed(String conffile) throws IOException {
        FileInputStream fs;
        try {
            fs = new FileInputStream(conffile);
        } catch (Exception e) {
            System.out.println("Cannot open " + conffile);
            return;
        }
        cache = null;
        znames = new Hashtable();
        TSIGs = new Hashtable();
        BufferedReader br = new BufferedReader(new InputStreamReader(fs));
        String line = null;
        while ((line = br.readLine()) != null) {
            StringTokenizer st = new StringTokenizer(line);
            if (!st.hasMoreTokens()) continue;
            String keyword = st.nextToken();
            if (!st.hasMoreTokens()) {
                System.out.println("Invalid line: " + line);
                continue;
            }
            if (keyword.equals("primary")) addZone(st.nextToken(), Zone.PRIMARY); else if (keyword.equals("cache")) cache = new Zone(st.nextToken(), Zone.CACHE, null); else if (keyword.equals("key")) addTSIG(st.nextToken(), st.nextToken());
        }
        if (cache == null) {
            System.out.println("no cache specified");
            System.exit(-1);
        }
        addUDP((short) 12345);
        addTCP((short) 12345);
    }
----------------------------------------
    public jnamed(String conffile) throws IOException {
        FileInputStream fs;
        try {
            fs = new FileInputStream(conffile);
        } catch (Exception e) {
            System.out.println("Cannot open " + conffile);
            return;
        }
        cache = null;
        znames = new Hashtable();
        TSIGs = new Hashtable();
        BufferedReader br = new BufferedReader(new InputStreamReader(fs));
        String line = null;
        while ((line = br.readLine()) != null) {
            StringTokenizer st = new StringTokenizer(line);
            if (!st.hasMoreTokens()) continue;
            String keyword = st.nextToken();
            if (!st.hasMoreTokens()) {
                System.out.println("Invalid line: " + line);
                continue;
            }
            if (keyword.equals("primary")) addZone(st.nextToken()); else if (keyword.equals("cache")) cache = new Cache(st.nextToken()); else if (keyword.equals("key")) addTSIG(st.nextToken(), st.nextToken());
        }
        if (cache == null) {
            System.out.println("no cache specified");
            System.exit(-1);
        }
        addUDP((short) 12345);
        addTCP((short) 12345);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76704.java,258,288
default,28942.java,258,288
----------------------------------------
    public boolean runCommand() {
        String cmd;
        String cmd_args[];
        if (macro.next()) {
            String cmd_arg_string = " ";
            cmd = macro.cmd();
            cmd_args = macro.args();
            for (int i = 0; i < cmd_args.length; i++) {
                cmd_arg_string += cmd_args[i] + " ";
            }
            jdp_console.writeOutput("\n");
            jdp_console.writeOutput("Macro line " + macro.currentLine() + ": " + cmd + cmd_arg_string);
        } else {
            jdp_console.readCommand(user);
            cmd = jdp_console.cmd();
            cmd_args = jdp_console.args();
        }
        if (!cmd.equals("")) {
            if (cmd.equals("quit") || cmd.equals("q")) {
                return true;
            } else {
                try {
                    return jdpCommand(cmd, cmd_args);
                } catch (Exception e) {
                    jdp_console.writeOutput("ERROR executing jdp command: " + e.getMessage());
                    jdp_console.writeOutput("email to jvm-coders or try again . . . ");
                }
            }
        }
        return false;
    }
----------------------------------------
    public boolean runCommand() {
        String cmd;
        String cmd_args[];
        if (macro.next()) {
            String cmd_arg_string = " ";
            cmd = macro.cmd();
            cmd_args = macro.args();
            for (int i = 0; i < cmd_args.length; i++) {
                cmd_arg_string += cmd_args[i] + " ";
            }
            jdp_console.writeOutput("\n");
            jdp_console.writeOutput("Macro line " + macro.currentLine() + ": " + cmd + cmd_arg_string);
        } else {
            jdp_console.readCommand(user);
            cmd = jdp_console.cmd();
            cmd_args = jdp_console.args();
        }
        if (!cmd.equals("")) {
            if (cmd.equals("quit") || cmd.equals("q")) {
                return true;
            } else {
                try {
                    return jdpCommand(cmd, cmd_args);
                } catch (Exception e) {
                    jdp_console.writeOutput("ERROR executing jdp command: " + e.getMessage());
                    jdp_console.writeOutput("email to jvm-coders or try again . . . ");
                }
            }
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,125766.java,17,46
default,100794.java,16,45
----------------------------------------
    public jnamed(String conffile) throws IOException {
        FileInputStream fs;
        try {
            fs = new FileInputStream(conffile);
        } catch (Exception e) {
            System.out.println("Cannot open " + conffile);
            return;
        }
        cache = null;
        znames = new Hashtable();
        TSIGs = new Hashtable();
        BufferedReader br = new BufferedReader(new InputStreamReader(fs));
        String line = null;
        while ((line = br.readLine()) != null) {
            StringTokenizer st = new StringTokenizer(line);
            if (!st.hasMoreTokens()) continue;
            String keyword = st.nextToken();
            if (!st.hasMoreTokens()) {
                System.out.println("Invalid line: " + line);
                continue;
            }
            if (keyword.equals("primary")) addZone(st.nextToken()); else if (keyword.equals("cache")) cache = new Cache(st.nextToken()); else if (keyword.equals("key")) addTSIG(st.nextToken(), st.nextToken());
        }
        if (cache == null) {
            System.out.println("no cache specified");
            System.exit(-1);
        }
        addUDP((short) 12345);
        addTCP((short) 12345);
    }
----------------------------------------
    public jnamed(String conffile) throws IOException {
        FileInputStream fs;
        try {
            fs = new FileInputStream(conffile);
        } catch (Exception e) {
            System.out.println("Cannot open " + conffile);
            return;
        }
        cache = null;
        znames = new Hashtable();
        TSIGs = new Hashtable();
        BufferedReader br = new BufferedReader(new InputStreamReader(fs));
        String line = null;
        while ((line = br.readLine()) != null) {
            StringTokenizer st = new StringTokenizer(line);
            if (!st.hasMoreTokens()) continue;
            String keyword = st.nextToken();
            if (!st.hasMoreTokens()) {
                System.out.println("Invalid line: " + line);
                continue;
            }
            if (keyword.equals("primary")) addZone(st.nextToken()); else if (keyword.equals("cache")) cache = new Cache(st.nextToken()); else if (keyword.equals("key")) addTSIG(st.nextToken(), st.nextToken());
        }
        if (cache == null) {
            System.out.println("no cache specified");
            System.exit(-1);
        }
        addUDP((short) 12345);
        addTCP((short) 12345);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24692.java,827,857
default,109831.java,827,857
----------------------------------------
    void processEvalRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("doing eval");
        PrintWriter old_out = out;
        StringWriter sw = new StringWriter();
        out = new PrintWriter(sw);
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) region.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
        out = old_out;
        if (DEBUG) System.out.println("doing eval: evaluating\n" + sw);
        LineNumberReader old_in = in;
        in = new LineNumberReader(new StringReader(sw.toString()));
        String inLine;
        for (inLine = readLine(); inLine != null; inLine = readLine()) {
            if (DEBUG) System.out.println("from input:" + inLine);
            if (!isTemplateLine(inLine)) {
                if (DEBUG) System.out.println("not template line, continuing...");
                out.print(inLine + "\n");
                continue;
            }
            Vector newRegion = buildTemplateRegion(inLine);
            processTemplateRegion(newRegion);
        }
        in = old_in;
    }
----------------------------------------
    void processEvalRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("doing eval");
        PrintWriter old_out = out;
        StringWriter sw = new StringWriter();
        out = new PrintWriter(sw);
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) region.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
        out = old_out;
        if (DEBUG) System.out.println("doing eval: evaluating\n" + sw);
        LineNumberReader old_in = in;
        in = new LineNumberReader(new StringReader(sw.toString()));
        String inLine;
        for (inLine = readLine(); inLine != null; inLine = readLine()) {
            if (DEBUG) System.out.println("from input:" + inLine);
            if (!isTemplateLine(inLine)) {
                if (DEBUG) System.out.println("not template line, continuing...");
                out.print(inLine + "\n");
                continue;
            }
            Vector newRegion = buildTemplateRegion(inLine);
            processTemplateRegion(newRegion);
        }
        in = old_in;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24692.java,827,857
default,109831.java,827,857
----------------------------------------
    void processEvalRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("doing eval");
        PrintWriter old_out = out;
        StringWriter sw = new StringWriter();
        out = new PrintWriter(sw);
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) region.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
        out = old_out;
        if (DEBUG) System.out.println("doing eval: evaluating\n" + sw);
        LineNumberReader old_in = in;
        in = new LineNumberReader(new StringReader(sw.toString()));
        String inLine;
        for (inLine = readLine(); inLine != null; inLine = readLine()) {
            if (DEBUG) System.out.println("from input:" + inLine);
            if (!isTemplateLine(inLine)) {
                if (DEBUG) System.out.println("not template line, continuing...");
                out.print(inLine + "\n");
                continue;
            }
            Vector newRegion = buildTemplateRegion(inLine);
            processTemplateRegion(newRegion);
        }
        in = old_in;
    }
----------------------------------------
    void processEvalRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("doing eval");
        PrintWriter old_out = out;
        StringWriter sw = new StringWriter();
        out = new PrintWriter(sw);
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) region.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
        out = old_out;
        if (DEBUG) System.out.println("doing eval: evaluating\n" + sw);
        LineNumberReader old_in = in;
        in = new LineNumberReader(new StringReader(sw.toString()));
        String inLine;
        for (inLine = readLine(); inLine != null; inLine = readLine()) {
            if (DEBUG) System.out.println("from input:" + inLine);
            if (!isTemplateLine(inLine)) {
                if (DEBUG) System.out.println("not template line, continuing...");
                out.print(inLine + "\n");
                continue;
            }
            Vector newRegion = buildTemplateRegion(inLine);
            processTemplateRegion(newRegion);
        }
        in = old_in;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109831.java,868,895
default,62165.java,868,893
----------------------------------------
    void processCondRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing argument in IF");
        String arg = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing operation in IF");
        String op = pst.nextToken();
        String[] value = new String[pst.countTokens()];
        for (int i = 0; i < value.length; i++) value[i] = pst.nextToken();
        if (DEBUG) {
            if (value.length > 0) System.out.println("doing conditional " + arg + " " + op + " " + value[0]); else System.out.println("doing conditional " + arg + " " + op + " <NO ARGUMENT TOKEN FOUND>");
        }
        Vector newRegion = (Vector) region.elementAt(1);
        if (!evaluateConditional(arg, op, value)) {
            if (region.size() > 2) newRegion = (Vector) region.elementAt(2); else newRegion = new Vector();
            if (DEBUG) System.out.println("condition is false");
        } else {
            if (DEBUG) System.out.println("condition is true");
        }
        for (int j = 0; j < newRegion.size(); j++) {
            try {
                String currentLine = (String) newRegion.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) newRegion.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
    }
----------------------------------------
    void processCondRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing argument in IF");
        String arg = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing operation in IF");
        String op = pst.nextToken();
        String[] value = new String[pst.countTokens()];
        for (int i = 0; i < value.length; i++) value[i] = pst.nextToken();
        if (DEBUG) System.out.println("doing conditional " + arg + " " + op + " " + value[0]);
        Vector newRegion = (Vector) region.elementAt(1);
        if (!evaluateConditional(arg, op, value)) {
            if (region.size() > 2) newRegion = (Vector) region.elementAt(2); else newRegion = new Vector();
            if (DEBUG) System.out.println("condition is false");
        } else {
            if (DEBUG) System.out.println("condition is true");
        }
        for (int j = 0; j < newRegion.size(); j++) {
            try {
                String currentLine = (String) newRegion.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) newRegion.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,56087.java,21,52
selected,1585280.java,24,55
----------------------------------------
    public static XSingleComponentFactory __getComponentFactory(String sImplementationName) {
        String regClassesList = getRegistrationClasses();
        StringTokenizer t = new StringTokenizer(regClassesList, " ");
        while (t.hasMoreTokens()) {
            String className = t.nextToken();
            if (className != null && className.length() != 0) {
                try {
                    Class regClass = Class.forName(className);
                    Method writeRegInfo = regClass.getDeclaredMethod("__getComponentFactory", new Class[] { String.class });
                    Object result = writeRegInfo.invoke(regClass, sImplementationName);
                    if (result != null) {
                        return (XSingleComponentFactory) result;
                    }
                } catch (ClassNotFoundException ex) {
                    ex.printStackTrace();
                } catch (ClassCastException ex) {
                    ex.printStackTrace();
                } catch (SecurityException ex) {
                    ex.printStackTrace();
                } catch (NoSuchMethodException ex) {
                    ex.printStackTrace();
                } catch (IllegalArgumentException ex) {
                    ex.printStackTrace();
                } catch (InvocationTargetException ex) {
                    ex.printStackTrace();
                } catch (IllegalAccessException ex) {
                    ex.printStackTrace();
                }
            }
        }
        return null;
    }
----------------------------------------
    public static XSingleComponentFactory __getComponentFactory(String sImplementationName) {
        String regClassesList = getRegistrationClasses();
        StringTokenizer t = new StringTokenizer(regClassesList, " ");
        while (t.hasMoreTokens()) {
            String className = t.nextToken();
            if (className != null && className.length() != 0) {
                try {
                    Class regClass = Class.forName(className);
                    Method writeRegInfo = regClass.getDeclaredMethod("__getComponentFactory", new Class[] { String.class });
                    Object result = writeRegInfo.invoke(regClass, sImplementationName);
                    if (result != null) {
                        return (XSingleComponentFactory) result;
                    }
                } catch (ClassNotFoundException ex) {
                    ex.printStackTrace();
                } catch (ClassCastException ex) {
                    ex.printStackTrace();
                } catch (SecurityException ex) {
                    ex.printStackTrace();
                } catch (NoSuchMethodException ex) {
                    ex.printStackTrace();
                } catch (IllegalArgumentException ex) {
                    ex.printStackTrace();
                } catch (InvocationTargetException ex) {
                    ex.printStackTrace();
                } catch (IllegalAccessException ex) {
                    ex.printStackTrace();
                }
            }
        }
        return null;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,552.java,349,379
default,24071.java,346,377
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62109.java,868,895
default,11822.java,868,893
----------------------------------------
    void processCondRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing argument in IF");
        String arg = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing operation in IF");
        String op = pst.nextToken();
        String[] value = new String[pst.countTokens()];
        for (int i = 0; i < value.length; i++) value[i] = pst.nextToken();
        if (DEBUG) {
            if (value.length > 0) System.out.println("doing conditional " + arg + " " + op + " " + value[0]); else System.out.println("doing conditional " + arg + " " + op + " <NO ARGUMENT TOKEN FOUND>");
        }
        Vector newRegion = (Vector) region.elementAt(1);
        if (!evaluateConditional(arg, op, value)) {
            if (region.size() > 2) newRegion = (Vector) region.elementAt(2); else newRegion = new Vector();
            if (DEBUG) System.out.println("condition is false");
        } else {
            if (DEBUG) System.out.println("condition is true");
        }
        for (int j = 0; j < newRegion.size(); j++) {
            try {
                String currentLine = (String) newRegion.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) newRegion.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
    }
----------------------------------------
    void processCondRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing argument in IF");
        String arg = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing operation in IF");
        String op = pst.nextToken();
        String[] value = new String[pst.countTokens()];
        for (int i = 0; i < value.length; i++) value[i] = pst.nextToken();
        if (DEBUG) System.out.println("doing conditional " + arg + " " + op + " " + value[0]);
        Vector newRegion = (Vector) region.elementAt(1);
        if (!evaluateConditional(arg, op, value)) {
            if (region.size() > 2) newRegion = (Vector) region.elementAt(2); else newRegion = new Vector();
            if (DEBUG) System.out.println("condition is false");
        } else {
            if (DEBUG) System.out.println("condition is true");
        }
        for (int j = 0; j < newRegion.size(); j++) {
            try {
                String currentLine = (String) newRegion.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) newRegion.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,58007.java,349,379
default,57607.java,362,393
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,26124.java,349,379
default,96347.java,346,377
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,13378.java,346,377
default,68839.java,346,377
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43887.java,362,393
default,31509.java,368,397
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        applyUIDSuffix(ds);
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2666453.java,240,269
selected,245970.java,17,48
----------------------------------------
    public void cosProcessTerminating(java.lang.String entity, tcg.syscontrol.cos.CosTerminationCodeEnum p_code) {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("cosProcessTerminating", true);
                    _os.write_string(entity);
                    tcg.syscontrol.cos.CosTerminationCodeEnumHelper.write(_os, p_code);
                    _is = _invoke(_os);
                    return;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("cosProcessTerminating", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                ICosProcessManagerOperations _localServant = (ICosProcessManagerOperations) _so.servant;
                try {
                    _localServant.cosProcessTerminating(entity, p_code);
                } finally {
                    _servant_postinvoke(_so);
                }
                return;
            }
        }
    }
----------------------------------------
    public void set_attribute_config_4(fr.esrf.Tango.AttributeConfig_3[] new_conf, fr.esrf.Tango.ClntIdent cl_ident) throws fr.esrf.Tango.DevFailed {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("set_attribute_config_4", true);
                    fr.esrf.Tango.AttributeConfigList_3Helper.write(_os, new_conf);
                    fr.esrf.Tango.ClntIdentHelper.write(_os, cl_ident);
                    _is = _invoke(_os);
                    return;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    if (_id.equals("IDL:Tango/DevFailed:1.0")) {
                        throw fr.esrf.Tango.DevFailedHelper.read(_ax.getInputStream());
                    } else throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("set_attribute_config_4", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                Device_4Operations _localServant = (Device_4Operations) _so.servant;
                try {
                    _localServant.set_attribute_config_4(new_conf, cl_ident);
                } finally {
                    _servant_postinvoke(_so);
                }
                return;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44688.java,376,406
default,48824.java,347,377
----------------------------------------
    private byte[] stopRunningTask(HTTPurl urlData) throws Exception {
        StringBuffer out = new StringBuffer(4096);
        String id = urlData.getParameter("id");
        String backURL = urlData.getCookie("backURL");
        try {
            backURL = URLDecoder.decode(backURL, "UTF-8");
        } catch (Exception e) {
        }
        if (backURL == null || backURL.length() == 0) backURL = "/servlet/" + urlData.getServletClass();
        ScheduleItem si = null;
        ThreadLock.getInstance().getLock();
        try {
            si = store.getScheduleItem(id);
            if (si != null && si.getState() == ScheduleItem.RUNNING) {
                si.abort();
                si.setStatus("Aborting");
                si.setState(ScheduleItem.ABORTED);
                si.log("Item marked for abortion");
            }
        } finally {
            ThreadLock.getInstance().releaseLock();
        }
        int counts = 10;
        while (si.getState() == ScheduleItem.ABORTED && counts > 0) {
            counts--;
            Thread.sleep(1000);
        }
        out.append("HTTP/1.0 302 Moved Temporarily\n");
        out.append("Location: " + backURL + "\n\n");
        return out.toString().getBytes();
    }
----------------------------------------
    private byte[] stopRunningTask(HTTPurl urlData) throws Exception {
        StringBuffer out = new StringBuffer(4096);
        String id = urlData.getParameter("id");
        String backURL = urlData.getCookie("backURL");
        try {
            backURL = URLDecoder.decode(backURL, "UTF-8");
        } catch (Exception e) {
        }
        if (backURL == null || backURL.length() == 0) backURL = "/servlet/" + urlData.getServletClass();
        ScheduleItem si = null;
        ThreadLock.getInstance().getLock();
        try {
            si = store.getScheduleItem(id);
            if (si != null && si.getState() == ScheduleItem.RUNNING) {
                si.abort();
                si.setStatus("Aborting");
                si.setState(ScheduleItem.ABORTED);
                si.log("Item marked for abortion");
            }
        } finally {
            ThreadLock.getInstance().releaseLock();
        }
        int counts = 10;
        while (si.getState() == ScheduleItem.ABORTED && counts > 0) {
            counts--;
            Thread.sleep(1000);
        }
        out.append("HTTP/1.0 302 Moved Temporarily\n");
        out.append("Location: " + backURL + "\n\n");
        return out.toString().getBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23528.java,519,547
default,10720.java,519,547
----------------------------------------
    void processCountRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing var name in COUNT");
        String var_name = pst.nextToken();
        int count = 0;
        while (pst.hasMoreTokens()) {
            String v_i = pst.nextToken();
            int dotdot = v_i.indexOf("..");
            if (dotdot != -1 && dotdot == v_i.lastIndexOf("..")) {
                int start = Integer.parseInt(v_i.substring(0, dotdot));
                int end = Integer.parseInt(v_i.substring(dotdot + 2));
                for (int j = start; j <= end; j++) count++;
            } else count++;
        }
        String value = Integer.toString(count);
        if (DEBUG) System.out.println("doing count with varname " + var_name + " on values :" + params.substring(var_name.length() + 1) + "; count=" + value);
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                String result = substitute(currentLine, var_name, value);
                out.print(result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt(j);
                Vector newRegion = substituteInRegion(oldRegion, var_name, value);
                processTemplateRegion(newRegion);
            }
        }
    }
----------------------------------------
    void processCountRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing var name in COUNT");
        String var_name = pst.nextToken();
        int count = 0;
        while (pst.hasMoreTokens()) {
            String v_i = pst.nextToken();
            int dotdot = v_i.indexOf("..");
            if (dotdot != -1 && dotdot == v_i.lastIndexOf("..")) {
                int start = Integer.parseInt(v_i.substring(0, dotdot));
                int end = Integer.parseInt(v_i.substring(dotdot + 2));
                for (int j = start; j <= end; j++) count++;
            } else count++;
        }
        String value = Integer.toString(count);
        if (DEBUG) System.out.println("doing count with varname " + var_name + " on values :" + params.substring(var_name.length() + 1) + "; count=" + value);
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                String result = substitute(currentLine, var_name, value);
                out.print(result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt(j);
                Vector newRegion = substituteInRegion(oldRegion, var_name, value);
                processTemplateRegion(newRegion);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,46669.java,1301,1329
default,28121.java,1061,1083
----------------------------------------
    private byte[] editTaskPage(HTTPurl urlData) throws Exception {
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "TaskEdit.html");
        String captcha = store.getProperty("security.captcha");
        if ("1".equals(captcha)) {
            template.replaceAll("$usingCAPTCHA$", "true");
        } else {
            template.replaceAll("$usingCAPTCHA$", "false");
        }
        String taskName = urlData.getParameter("name");
        HashMap<String, TaskCommand> tasks = store.getTaskList();
        TaskCommand task = (TaskCommand) tasks.get(taskName);
        if (task != null) {
            template.replaceAll("$taskName", taskName);
            String command = task.getCommand();
            command = command.replaceAll("\"", "&#34;");
            command = command.replaceAll("<", "&lt;");
            command = command.replaceAll(">", "&gt;");
            template.replaceAll("$taskCommand", command);
            template.replaceAll("$taskDelayFor", new Integer(task.getDelay()).toString());
            if (task.getAutoRemove()) template.replaceAll("$autoRemove", "checked"); else template.replaceAll("$autoRemove", "");
            template.replaceAll("$concurrentTasks", new Integer(task.getConcurrent()).toString());
            template.replaceAll("$timeToNextSchedule", new Integer(task.getTimeToNextSchedule()).toString());
            if (task.getWhenNotCapturing()) template.replaceAll("$whenNotCapturing", "checked"); else template.replaceAll("$whenNotCapturing", "");
        } else {
            String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass() + "?action=08\n\n";
            return out.getBytes();
        }
        return template.getPageBytes();
    }
----------------------------------------
    private byte[] editTaskPage(HTTPurl urlData) throws Exception {
        PageTemplate template = new PageTemplate(store.getProperty("path.template").replace('\\', File.separatorChar) + File.separator + "TaskEdit.html");
        String taskName = urlData.getParameter("name");
        HashMap<String, TaskCommand> tasks = store.getTaskList();
        TaskCommand task = (TaskCommand) tasks.get(taskName);
        if (task != null) {
            template.replaceAll("$taskName", taskName);
            String command = task.getCommand();
            command = command.replaceAll("\"", "&#34;");
            command = command.replaceAll("<", "&lt;");
            command = command.replaceAll(">", "&gt;");
            template.replaceAll("$taskCommand", command);
            template.replaceAll("$taskDelayFor", new Integer(task.getDelay()).toString());
            if (task.getAutoRemove()) template.replaceAll("$autoRemove", "checked"); else template.replaceAll("$autoRemove", "");
            template.replaceAll("$concurrentTasks", new Integer(task.getConcurrent()).toString());
            template.replaceAll("$timeToNextSchedule", new Integer(task.getTimeToNextSchedule()).toString());
            if (task.getWhenNotCapturing()) template.replaceAll("$whenNotCapturing", "checked"); else template.replaceAll("$whenNotCapturing", "");
        } else {
            String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass() + "?action=08\n\n";
            return out.getBytes();
        }
        return template.getPageBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,11981.java,1061,1083
default,94873.java,1300,1328
----------------------------------------
    private byte[] editTaskPage(HTTPurl urlData) throws Exception {
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "TaskEdit.html");
        String taskName = urlData.getParameter("name");
        HashMap<String, TaskCommand> tasks = store.getTaskList();
        TaskCommand task = (TaskCommand) tasks.get(taskName);
        if (task != null) {
            template.replaceAll("$taskName", taskName);
            String command = task.getCommand();
            command = command.replaceAll("\"", "&#34;");
            command = command.replaceAll("<", "&lt;");
            command = command.replaceAll(">", "&gt;");
            template.replaceAll("$taskCommand", command);
            template.replaceAll("$taskDelayFor", new Integer(task.getDelay()).toString());
            if (task.getAutoRemove()) template.replaceAll("$autoRemove", "checked"); else template.replaceAll("$autoRemove", "");
            template.replaceAll("$concurrentTasks", new Integer(task.getConcurrent()).toString());
            template.replaceAll("$timeToNextSchedule", new Integer(task.getTimeToNextSchedule()).toString());
            if (task.getWhenNotCapturing()) template.replaceAll("$whenNotCapturing", "checked"); else template.replaceAll("$whenNotCapturing", "");
        } else {
            String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass() + "?action=08\n\n";
            return out.getBytes();
        }
        return template.getPageBytes();
    }
----------------------------------------
    private byte[] editTaskPage(HTTPurl urlData) throws Exception {
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "TaskEdit.html");
        String captcha = store.getProperty("security.captcha");
        if ("1".equals(captcha)) {
            template.replaceAll("$usingCAPTCHA$", "true");
        } else {
            template.replaceAll("$usingCAPTCHA$", "false");
        }
        String taskName = urlData.getParameter("name");
        HashMap<String, TaskCommand> tasks = store.getTaskList();
        TaskCommand task = (TaskCommand) tasks.get(taskName);
        if (task != null) {
            template.replaceAll("$taskName", taskName);
            String command = task.getCommand();
            command = command.replaceAll("\"", "&#34;");
            command = command.replaceAll("<", "&lt;");
            command = command.replaceAll(">", "&gt;");
            template.replaceAll("$taskCommand", command);
            template.replaceAll("$taskDelayFor", new Integer(task.getDelay()).toString());
            if (task.getAutoRemove()) template.replaceAll("$autoRemove", "checked"); else template.replaceAll("$autoRemove", "");
            template.replaceAll("$concurrentTasks", new Integer(task.getConcurrent()).toString());
            template.replaceAll("$timeToNextSchedule", new Integer(task.getTimeToNextSchedule()).toString());
            if (task.getWhenNotCapturing()) template.replaceAll("$whenNotCapturing", "checked"); else template.replaceAll("$whenNotCapturing", "");
        } else {
            String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass() + "?action=08\n\n";
            return out.getBytes();
        }
        return template.getPageBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,119236.java,14,43
default,34761.java,14,43
----------------------------------------
    public void run() throws Exception {
        File absJar = createJar(new File("abs.jar").getAbsoluteFile(), "j.A");
        File relJar = createJar(new File("rel.jar"), "j.R");
        File absDir = createDir(new File("abs.dir").getAbsoluteFile(), "d.A");
        File relDir = createDir(new File("rel.dir"), "d.R");
        File absTestFile = writeFile(new File("AbsTest.java").getAbsoluteFile(), "class AbsTest { class Inner { } }");
        File relTestFile = writeFile(new File("RelTest.java"), "class RelTest { class Inner { } }");
        File relTest2File = writeFile(new File("p/RelTest2.java"), "package p; class RelTest2 { class Inner { } }");
        File mainFile = writeFile(new File("Main.java"), "class Main { j.A ja; j.R jr; d.A da; d.R dr; }" + "");
        String sourcePath = createPath(absJar, relJar, absDir, relDir);
        File outDir = new File("classes");
        outDir.mkdirs();
        String[] args = { "-sourcepath", sourcePath, "-d", outDir.getPath(), absTestFile.getPath(), relTestFile.getPath(), relTest2File.getPath(), mainFile.getPath() };
        System.err.println("compile: " + Arrays.asList(args));
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        int rc = com.sun.tools.javac.Main.compile(args, pw);
        pw.close();
        if (rc != 0) {
            System.err.println(sw.toString());
            throw new Exception("unexpected exit from javac: " + rc);
        }
        Set<File> expect = getFiles(outDir, "d/A.class", "d/A$Inner.class", "d/R.class", "d/R$Inner.class", "j/A.class", "j/A$Inner.class", "j/R.class", "j/R$Inner.class", "AbsTest.class", "AbsTest$Inner.class", "RelTest.class", "RelTest$Inner.class", "p/RelTest2.class", "p/RelTest2$Inner.class", "Main.class");
        Set<File> found = findFiles(outDir);
        if (!found.equals(expect)) {
            if (found.containsAll(expect)) throw new Exception("unexpected files found: " + diff(found, expect)); else if (expect.containsAll(found)) throw new Exception("expected files not found: " + diff(expect, found));
        }
        for (File f : found) verifySourceFileAttribute(f);
        if (errors > 0) throw new Exception(errors + " errors occurred");
    }
----------------------------------------
    public void run() throws Exception {
        File absJar = createJar(new File("abs.jar").getAbsoluteFile(), "j.A");
        File relJar = createJar(new File("rel.jar"), "j.R");
        File absDir = createDir(new File("abs.dir").getAbsoluteFile(), "d.A");
        File relDir = createDir(new File("rel.dir"), "d.R");
        File absTestFile = writeFile(new File("AbsTest.java").getAbsoluteFile(), "class AbsTest { class Inner { } }");
        File relTestFile = writeFile(new File("RelTest.java"), "class RelTest { class Inner { } }");
        File relTest2File = writeFile(new File("p/RelTest2.java"), "package p; class RelTest2 { class Inner { } }");
        File mainFile = writeFile(new File("Main.java"), "class Main { j.A ja; j.R jr; d.A da; d.R dr; }" + "");
        String sourcePath = createPath(absJar, relJar, absDir, relDir);
        File outDir = new File("classes");
        outDir.mkdirs();
        String[] args = { "-sourcepath", sourcePath, "-d", outDir.getPath(), absTestFile.getPath(), relTestFile.getPath(), relTest2File.getPath(), mainFile.getPath() };
        System.err.println("compile: " + Arrays.asList(args));
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        int rc = com.sun.tools.javac.Main.compile(args, pw);
        pw.close();
        if (rc != 0) {
            System.err.println(sw.toString());
            throw new Exception("unexpected exit from javac: " + rc);
        }
        Set<File> expect = getFiles(outDir, "d/A.class", "d/A$Inner.class", "d/R.class", "d/R$Inner.class", "j/A.class", "j/A$Inner.class", "j/R.class", "j/R$Inner.class", "AbsTest.class", "AbsTest$Inner.class", "RelTest.class", "RelTest$Inner.class", "p/RelTest2.class", "p/RelTest2$Inner.class", "Main.class");
        Set<File> found = findFiles(outDir);
        if (!found.equals(expect)) {
            if (found.containsAll(expect)) throw new Exception("unexpected files found: " + diff(found, expect)); else if (expect.containsAll(found)) throw new Exception("expected files not found: " + diff(expect, found));
        }
        for (File f : found) verifySourceFileAttribute(f);
        if (errors > 0) throw new Exception(errors + " errors occurred");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44688.java,376,406
default,109645.java,376,406
----------------------------------------
    private byte[] stopRunningTask(HTTPurl urlData) throws Exception {
        StringBuffer out = new StringBuffer(4096);
        String id = urlData.getParameter("id");
        String backURL = urlData.getCookie("backURL");
        try {
            backURL = URLDecoder.decode(backURL, "UTF-8");
        } catch (Exception e) {
        }
        if (backURL == null || backURL.length() == 0) backURL = "/servlet/" + urlData.getServletClass();
        ScheduleItem si = null;
        ThreadLock.getInstance().getLock();
        try {
            si = store.getScheduleItem(id);
            if (si != null && si.getState() == ScheduleItem.RUNNING) {
                si.abort();
                si.setStatus("Aborting");
                si.setState(ScheduleItem.ABORTED);
                si.log("Item marked for abortion");
            }
        } finally {
            ThreadLock.getInstance().releaseLock();
        }
        int counts = 10;
        while (si.getState() == ScheduleItem.ABORTED && counts > 0) {
            counts--;
            Thread.sleep(1000);
        }
        out.append("HTTP/1.0 302 Moved Temporarily\n");
        out.append("Location: " + backURL + "\n\n");
        return out.toString().getBytes();
    }
----------------------------------------
    private byte[] stopRunningTask(HTTPurl urlData) throws Exception {
        StringBuffer out = new StringBuffer(4096);
        String id = urlData.getParameter("id");
        String backURL = urlData.getCookie("backURL");
        try {
            backURL = URLDecoder.decode(backURL, "UTF-8");
        } catch (Exception e) {
        }
        if (backURL == null || backURL.length() == 0) backURL = "/servlet/" + urlData.getServletClass();
        ScheduleItem si = null;
        ThreadLock.getInstance().getLock();
        try {
            si = store.getScheduleItem(id);
            if (si != null && si.getState() == ScheduleItem.RUNNING) {
                si.abort();
                si.setStatus("Aborting");
                si.setState(ScheduleItem.ABORTED);
                si.log("Item marked for abortion");
            }
        } finally {
            ThreadLock.getInstance().releaseLock();
        }
        int counts = 10;
        while (si.getState() == ScheduleItem.ABORTED && counts > 0) {
            counts--;
            Thread.sleep(1000);
        }
        out.append("HTTP/1.0 302 Moved Temporarily\n");
        out.append("Location: " + backURL + "\n\n");
        return out.toString().getBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4072.java,647,676
default,5170.java,709,737
----------------------------------------
    public static String[] varParseField(String name) {
        String remain;
        String thisfield = name;
        int dot1, dot2, bracket;
        int numfield = varCountField(name);
        String fields[] = new String[numfield];
        remain = name;
        if (numfield == 0) {
            return null;
        }
        for (int i = 0; i < numfield; i++) {
            dot1 = remain.indexOf('.');
            dot2 = remain.indexOf('.', dot1 + 1);
            if (dot1 != -1 && dot2 != -1) {
                thisfield = remain.substring(dot1 + 1, dot2);
                remain = remain.substring(dot1 + 1);
            } else if (dot1 != -1 && dot2 == -1) {
                thisfield = remain.substring(dot1 + 1);
            } else {
                System.out.println("ERROR: parsing " + name);
            }
            bracket = thisfield.indexOf('[');
            if (bracket != -1) {
                fields[i] = thisfield.substring(0, bracket);
            } else {
                fields[i] = thisfield;
            }
        }
        return fields;
    }
----------------------------------------
    public static String[] varParseFieldDimension(String name) {
        String remain;
        String thisfield = name;
        int dot1, dot2, bracket;
        int numfield = varCountField(name);
        String fields[] = new String[numfield];
        remain = name;
        if (numfield == 0) {
            return null;
        }
        for (int i = 0; i < numfield; i++) {
            dot1 = remain.indexOf('.');
            dot2 = remain.indexOf('.', dot1 + 1);
            fields[i] = "";
            if (dot1 != -1 && dot2 != -1) {
                thisfield = remain.substring(dot1 + 1, dot2);
                remain = remain.substring(dot1 + 1);
            } else if (dot1 != -1 && dot2 == -1) {
                thisfield = remain.substring(dot1 + 1);
            } else {
                System.out.println("ERROR: parsing " + name);
            }
            bracket = thisfield.indexOf('[');
            if (bracket != -1) {
                fields[i] = thisfield.substring(bracket);
            }
        }
        return fields;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,26124.java,349,379
default,5224.java,349,379
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33579.java,32,62
default,33579.java,32,62
----------------------------------------
    public SubscribeTest(String testAppAbsPath, int jobNumber, int maxMessageForAJob, String mainMonitorURL, int delay, boolean portalEmul) {
        System.out.println("SubscribeTest(" + testAppAbsPath + ", " + jobNumber + ", " + maxMessageForAJob + ", " + mainMonitorURL + ", " + delay + ", " + portalEmul + ") called");
        String path = "" + this.getClass().getClassLoader().getResource(".");
        this.traceFilesDir = path.substring(path.indexOf(":") + 1, path.length()) + "testTraces/";
        File tracesDir = new File(this.traceFilesDir);
        if (!tracesDir.exists()) {
            try {
                tracesDir.mkdirs();
            } catch (Exception ex) {
                System.out.println("Failed to create dir: " + tracesDir.getAbsolutePath());
                ex.printStackTrace();
            }
        }
        this.testAppAbsPath = testAppAbsPath;
        this.jobNumber = jobNumber;
        this.finishedJobs = 0;
        this.maxMessageForAJob = maxMessageForAJob;
        this.mainMonitorURL = mainMonitorURL;
        this.mappings = new Hashtable();
        this.delay = delay;
        this.portalEmul = portalEmul;
        if (portalEmul) {
            try {
                this.tfm = TraceFileMonitor.getInstance(this.traceFilesDir);
            } catch (Exception ex) {
                ex.printStackTrace();
                System.exit(0);
            }
        }
        this.run();
    }
----------------------------------------
    public SubscribeTest(String testAppAbsPath, int jobNumber, int maxMessageForAJob, String mainMonitorURL, int delay, boolean portalEmul) {
        System.out.println("SubscribeTest(" + testAppAbsPath + ", " + jobNumber + ", " + maxMessageForAJob + ", " + mainMonitorURL + ", " + delay + ", " + portalEmul + ") called");
        String path = "" + this.getClass().getClassLoader().getResource(".");
        this.traceFilesDir = path.substring(path.indexOf(":") + 1, path.length()) + "testTraces/";
        File tracesDir = new File(this.traceFilesDir);
        if (!tracesDir.exists()) {
            try {
                tracesDir.mkdirs();
            } catch (Exception ex) {
                System.out.println("Failed to create dir: " + tracesDir.getAbsolutePath());
                ex.printStackTrace();
            }
        }
        this.testAppAbsPath = testAppAbsPath;
        this.jobNumber = jobNumber;
        this.finishedJobs = 0;
        this.maxMessageForAJob = maxMessageForAJob;
        this.mainMonitorURL = mainMonitorURL;
        this.mappings = new Hashtable();
        this.delay = delay;
        this.portalEmul = portalEmul;
        if (portalEmul) {
            try {
                this.tfm = TraceFileMonitor.getInstance(this.traceFilesDir);
            } catch (Exception ex) {
                ex.printStackTrace();
                System.exit(0);
            }
        }
        this.run();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,46669.java,1301,1329
default,46669.java,1301,1329
----------------------------------------
    private byte[] editTaskPage(HTTPurl urlData) throws Exception {
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "TaskEdit.html");
        String captcha = store.getProperty("security.captcha");
        if ("1".equals(captcha)) {
            template.replaceAll("$usingCAPTCHA$", "true");
        } else {
            template.replaceAll("$usingCAPTCHA$", "false");
        }
        String taskName = urlData.getParameter("name");
        HashMap<String, TaskCommand> tasks = store.getTaskList();
        TaskCommand task = (TaskCommand) tasks.get(taskName);
        if (task != null) {
            template.replaceAll("$taskName", taskName);
            String command = task.getCommand();
            command = command.replaceAll("\"", "&#34;");
            command = command.replaceAll("<", "&lt;");
            command = command.replaceAll(">", "&gt;");
            template.replaceAll("$taskCommand", command);
            template.replaceAll("$taskDelayFor", new Integer(task.getDelay()).toString());
            if (task.getAutoRemove()) template.replaceAll("$autoRemove", "checked"); else template.replaceAll("$autoRemove", "");
            template.replaceAll("$concurrentTasks", new Integer(task.getConcurrent()).toString());
            template.replaceAll("$timeToNextSchedule", new Integer(task.getTimeToNextSchedule()).toString());
            if (task.getWhenNotCapturing()) template.replaceAll("$whenNotCapturing", "checked"); else template.replaceAll("$whenNotCapturing", "");
        } else {
            String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass() + "?action=08\n\n";
            return out.getBytes();
        }
        return template.getPageBytes();
    }
----------------------------------------
    private byte[] editTaskPage(HTTPurl urlData) throws Exception {
        PageTemplate template = new PageTemplate(store.getProperty("path.template") + File.separator + "TaskEdit.html");
        String captcha = store.getProperty("security.captcha");
        if ("1".equals(captcha)) {
            template.replaceAll("$usingCAPTCHA$", "true");
        } else {
            template.replaceAll("$usingCAPTCHA$", "false");
        }
        String taskName = urlData.getParameter("name");
        HashMap<String, TaskCommand> tasks = store.getTaskList();
        TaskCommand task = (TaskCommand) tasks.get(taskName);
        if (task != null) {
            template.replaceAll("$taskName", taskName);
            String command = task.getCommand();
            command = command.replaceAll("\"", "&#34;");
            command = command.replaceAll("<", "&lt;");
            command = command.replaceAll(">", "&gt;");
            template.replaceAll("$taskCommand", command);
            template.replaceAll("$taskDelayFor", new Integer(task.getDelay()).toString());
            if (task.getAutoRemove()) template.replaceAll("$autoRemove", "checked"); else template.replaceAll("$autoRemove", "");
            template.replaceAll("$concurrentTasks", new Integer(task.getConcurrent()).toString());
            template.replaceAll("$timeToNextSchedule", new Integer(task.getTimeToNextSchedule()).toString());
            if (task.getWhenNotCapturing()) template.replaceAll("$whenNotCapturing", "checked"); else template.replaceAll("$whenNotCapturing", "");
        } else {
            String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass() + "?action=08\n\n";
            return out.getBytes();
        }
        return template.getPageBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,9693.java,349,379
default,98798.java,349,379
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,419020.java,628,658
selected,753625.java,491,521
----------------------------------------
    public static byte[] decode(byte[] source, int off, int len, int options) {
        byte[] DECODABET = getDecodabet(options);
        int len34 = len * 3 / 4;
        byte[] outBuff = new byte[len34];
        int outBuffPosn = 0;
        byte[] b4 = new byte[4];
        int b4Posn = 0;
        int i = 0;
        byte sbiCrop = 0;
        byte sbiDecode = 0;
        for (i = off; i < off + len; i++) {
            sbiCrop = (byte) (source[i] & 0x7f);
            sbiDecode = DECODABET[sbiCrop];
            if (sbiDecode >= WHITE_SPACE_ENC) {
                if (sbiDecode >= EQUALS_SIGN_ENC) {
                    b4[b4Posn++] = sbiCrop;
                    if (b4Posn > 3) {
                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);
                        b4Posn = 0;
                        if (sbiCrop == EQUALS_SIGN) break;
                    }
                }
            } else {
                System.err.println("Bad Base64 input character at " + i + ": " + source[i] + "(decimal)");
                return null;
            }
        }
        byte[] out = new byte[outBuffPosn];
        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
        return out;
    }
----------------------------------------
    public static byte[] decode(byte[] source, int off, int len, int options) {
        byte[] DECODABET = getDecodabet(options);
        int len34 = len * 3 / 4;
        byte[] outBuff = new byte[len34];
        int outBuffPosn = 0;
        byte[] b4 = new byte[4];
        int b4Posn = 0;
        int i = 0;
        byte sbiCrop = 0;
        byte sbiDecode = 0;
        for (i = off; i < off + len; i++) {
            sbiCrop = (byte) (source[i] & 0x7f);
            sbiDecode = DECODABET[sbiCrop];
            if (sbiDecode >= WHITE_SPACE_ENC) {
                if (sbiDecode >= EQUALS_SIGN_ENC) {
                    b4[b4Posn++] = sbiCrop;
                    if (b4Posn > 3) {
                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);
                        b4Posn = 0;
                        if (sbiCrop == EQUALS_SIGN) break;
                    }
                }
            } else {
                System.err.println("Bad Base64 input character at " + i + ": " + source[i] + "(decimal)");
                return null;
            }
        }
        byte[] out = new byte[outBuffPosn];
        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
        return out;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2348022.java,222,252
selected,1490133.java,230,260
----------------------------------------
    private boolean _jspx_meth_html_005flink_005f1(PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.struts.taglib.html.LinkTag _jspx_th_html_005flink_005f1 = (org.apache.struts.taglib.html.LinkTag) _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.get(org.apache.struts.taglib.html.LinkTag.class);
        _jspx_th_html_005flink_005f1.setPageContext(_jspx_page_context);
        _jspx_th_html_005flink_005f1.setParent(null);
        _jspx_th_html_005flink_005f1.setStyleId("incluir");
        _jspx_th_html_005flink_005f1.setHref("cadastroUsuario.do");
        int _jspx_eval_html_005flink_005f1 = _jspx_th_html_005flink_005f1.doStartTag();
        if (_jspx_eval_html_005flink_005f1 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_html_005flink_005f1 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_html_005flink_005f1.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_html_005flink_005f1.doInitBody();
            }
            do {
                out.write("Lista de Usuários");
                int evalDoAfterBody = _jspx_th_html_005flink_005f1.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_html_005flink_005f1 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_html_005flink_005f1.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f1);
            return true;
        }
        _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f1);
        return false;
    }
----------------------------------------
    private boolean _jspx_meth_html_005flink_005f0(PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.struts.taglib.html.LinkTag _jspx_th_html_005flink_005f0 = (org.apache.struts.taglib.html.LinkTag) _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.get(org.apache.struts.taglib.html.LinkTag.class);
        _jspx_th_html_005flink_005f0.setPageContext(_jspx_page_context);
        _jspx_th_html_005flink_005f0.setParent(null);
        _jspx_th_html_005flink_005f0.setStyleId("incluir");
        _jspx_th_html_005flink_005f0.setHref("login.do");
        int _jspx_eval_html_005flink_005f0 = _jspx_th_html_005flink_005f0.doStartTag();
        if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.pushBody();
                _jspx_th_html_005flink_005f0.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);
                _jspx_th_html_005flink_005f0.doInitBody();
            }
            do {
                out.write("Início");
                int evalDoAfterBody = _jspx_th_html_005flink_005f0.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
            if (_jspx_eval_html_005flink_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {
                out = _jspx_page_context.popBody();
            }
        }
        if (_jspx_th_html_005flink_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f0);
            return true;
        }
        _005fjspx_005ftagPool_005fhtml_005flink_005fstyleId_005fhref.reuse(_jspx_th_html_005flink_005f0);
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1526748.java,131,161
selected,2382371.java,132,162
----------------------------------------
    public boolean addFrame(BufferedImage im) {
        if ((im == null) || !started) {
            return false;
        }
        boolean ok = true;
        try {
            if (!sizeSet) {
                setSize(im.getWidth(), im.getHeight());
            }
            image = im;
            getImagePixels();
            analyzePixels();
            if (firstFrame) {
                writeLSD();
                writePalette();
                if (repeat >= 0) {
                    writeNetscapeExt();
                }
            }
            writeGraphicCtrlExt();
            writeImageDesc();
            if (!firstFrame) {
                writePalette();
            }
            writePixels();
            firstFrame = false;
        } catch (Exception e) {
            ok = false;
        }
        return ok;
    }
----------------------------------------
    public boolean addFrame(BufferedImage im) {
        if ((im == null) || !started) {
            return false;
        }
        boolean ok = true;
        try {
            if (!sizeSet) {
                setSize(im.getWidth(), im.getHeight());
            }
            image = im;
            getImagePixels();
            analyzePixels();
            if (firstFrame) {
                writeLSD();
                writePalette();
                if (repeat >= 0) {
                    writeNetscapeExt();
                }
            }
            writeGraphicCtrlExt();
            writeImageDesc();
            if (!firstFrame) {
                writePalette();
            }
            writePixels();
            firstFrame = false;
        } catch (IOException e) {
            ok = false;
        }
        return ok;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33936.java,353,383
default,113657.java,353,383
----------------------------------------
    private void send(HttpServletRequest req, HttpServletResponse res, ServletOutputStream out, HttpSession ssn) throws IOException {
        String to = req.getParameter("to");
        String cc = req.getParameter("cc");
        String subj = req.getParameter("subject");
        String text = req.getParameter("text");
        try {
            MailUserData mud = getMUD(ssn);
            if (mud == null) throw new Exception("trying to send, but not logged in");
            Message msg = new MimeMessage(mud.getSession());
            InternetAddress[] toAddrs = null, ccAddrs = null;
            if (to != null) {
                toAddrs = InternetAddress.parse(to, false);
                msg.setRecipients(Message.RecipientType.TO, toAddrs);
            } else throw new MessagingException("No \"To\" address specified");
            if (cc != null) {
                ccAddrs = InternetAddress.parse(cc, false);
                msg.setRecipients(Message.RecipientType.CC, ccAddrs);
            }
            if (subj != null) msg.setSubject(subj);
            URLName u = mud.getURLName();
            msg.setFrom(new InternetAddress(u.getUsername() + "@" + u.getHost()));
            if (text != null) msg.setText(text);
            Transport.send(msg);
            out.println("<h1>Message sent successfully</h1></body></html>");
            out.close();
        } catch (Exception mex) {
            out.println("<h1>Error sending message.</h1>");
            out.println(mex.toString());
            out.println("<br></body></html>");
        }
    }
----------------------------------------
    private void send(HttpServletRequest req, HttpServletResponse res, ServletOutputStream out, HttpSession ssn) throws IOException {
        String to = req.getParameter("to");
        String cc = req.getParameter("cc");
        String subj = req.getParameter("subject");
        String text = req.getParameter("text");
        try {
            MailUserData mud = getMUD(ssn);
            if (mud == null) throw new Exception("trying to send, but not logged in");
            Message msg = new MimeMessage(mud.getSession());
            InternetAddress[] toAddrs = null, ccAddrs = null;
            if (to != null) {
                toAddrs = InternetAddress.parse(to, false);
                msg.setRecipients(Message.RecipientType.TO, toAddrs);
            } else throw new MessagingException("No \"To\" address specified");
            if (cc != null) {
                ccAddrs = InternetAddress.parse(cc, false);
                msg.setRecipients(Message.RecipientType.CC, ccAddrs);
            }
            if (subj != null) msg.setSubject(subj);
            URLName u = mud.getURLName();
            msg.setFrom(new InternetAddress(u.getUsername() + "@" + u.getHost()));
            if (text != null) msg.setText(text);
            Transport.send(msg);
            out.println("<h1>Message sent successfully</h1></body></html>");
            out.close();
        } catch (Exception mex) {
            out.println("<h1>Error sending message.</h1>");
            out.println(mex.toString());
            out.println("<br></body></html>");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114236.java,901,931
default,48824.java,347,377
----------------------------------------
    private byte[] stopRunningTask(HTTPurl urlData) throws Exception {
        String backURL = urlData.getCookie("backURL");
        try {
            backURL = URLDecoder.decode(backURL, "UTF-8");
        } catch (Exception e) {
        }
        if (backURL == null || backURL.length() == 0) backURL = "/servlet/ApplyTransformRes?xml=root&xsl=kb-buttons";
        StringBuffer out = new StringBuffer(4096);
        String id = urlData.getParameter("id");
        ScheduleItem si = null;
        ThreadLock.getInstance().getLock();
        try {
            si = store.getScheduleItem(id);
            if (si != null && si.getState() == ScheduleItem.RUNNING) {
                si.abort();
                si.setStatus("Aborting");
                si.setState(ScheduleItem.ABORTED);
                si.log("Item marked for abortion");
            }
        } finally {
            ThreadLock.getInstance().releaseLock();
        }
        int counts = 10;
        while (si.getState() == ScheduleItem.ABORTED && counts > 0) {
            counts--;
            Thread.sleep(1000);
        }
        out.append("HTTP/1.0 302 Moved Temporarily\n");
        out.append("Location: " + backURL + "\n\n");
        return out.toString().getBytes();
    }
----------------------------------------
    private byte[] stopRunningTask(HTTPurl urlData) throws Exception {
        StringBuffer out = new StringBuffer(4096);
        String id = urlData.getParameter("id");
        String backURL = urlData.getCookie("backURL");
        try {
            backURL = URLDecoder.decode(backURL, "UTF-8");
        } catch (Exception e) {
        }
        if (backURL == null || backURL.length() == 0) backURL = "/servlet/" + urlData.getServletClass();
        ScheduleItem si = null;
        ThreadLock.getInstance().getLock();
        try {
            si = store.getScheduleItem(id);
            if (si != null && si.getState() == ScheduleItem.RUNNING) {
                si.abort();
                si.setStatus("Aborting");
                si.setState(ScheduleItem.ABORTED);
                si.log("Item marked for abortion");
            }
        } finally {
            ThreadLock.getInstance().releaseLock();
        }
        int counts = 10;
        while (si.getState() == ScheduleItem.ABORTED && counts > 0) {
            counts--;
            Thread.sleep(1000);
        }
        out.append("HTTP/1.0 302 Moved Temporarily\n");
        out.append("Location: " + backURL + "\n\n");
        return out.toString().getBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,74458.java,292,317
selected,1165351.java,34,64
----------------------------------------
    public void CopyFile(File source, File destination) throws Exception {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fis = new FileInputStream(source);
            fos = new FileOutputStream(destination);
            byte[] buffer = new byte[4096];
            int read;
            while ((read = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, read);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fis != null) {
                    fis.close();
                }
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
----------------------------------------
    public void run() {
        OutputStream out = null;
        URLConnection conn = null;
        InputStream in = null;
        try {
            URL url = new URL(address);
            out = new BufferedOutputStream(new FileOutputStream(fileName));
            conn = url.openConnection();
            in = conn.getInputStream();
            byte[] buffer = new byte[1024];
            int numRead;
            long numWritten = 0;
            while ((numRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, numRead);
                numWritten += numRead;
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        } finally {
            try {
                if (in != null) {
                    in.close();
                }
                if (out != null) {
                    out.close();
                }
            } catch (IOException ioe) {
            }
        }
        downMonit.downloadFinish();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1923478.java,761,790
selected,845917.java,749,777
----------------------------------------
    protected DataInputStream readS3BinaryHeader(String location, String path, Properties props) throws IOException {
        InputStream inputStream;
        if (location != null && location.equals("letrucimpossibleetquinexistepas")) inputStream = new java.io.FileInputStream(path); else inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new IOException("Can't open " + path);
        }
        DataInputStream dis = new DataInputStream(new BufferedInputStream(inputStream));
        String id = readWord(dis);
        if (!id.equals("s3")) {
            throw new IOException("Not proper s3 binary file " + location + path);
        }
        String name;
        while ((name = readWord(dis)) != null) {
            if (!name.equals("endhdr")) {
                String value = readWord(dis);
                props.setProperty(name, value);
            } else {
                break;
            }
        }
        int byteOrderMagic = dis.readInt();
        if (byteOrderMagic == BYTE_ORDER_MAGIC) {
            swap = false;
        } else if (byteSwap(byteOrderMagic) == BYTE_ORDER_MAGIC) {
            swap = true;
        } else {
            throw new IOException("Corrupt S3 file " + location + path);
        }
        return dis;
    }
----------------------------------------
    protected DataInputStream readS3BinaryHeader(String location, String path, Properties props) throws IOException {
        InputStream inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new IOException("Can't open " + path);
        }
        DataInputStream dis = new DataInputStream(new BufferedInputStream(inputStream));
        String id = readWord(dis);
        if (!id.equals("s3")) {
            throw new IOException("Not proper s3 binary file " + location + path);
        }
        String name;
        while ((name = readWord(dis)) != null) {
            if (!name.equals("endhdr")) {
                String value = readWord(dis);
                props.setProperty(name, value);
            } else {
                break;
            }
        }
        int byteOrderMagic = dis.readInt();
        if (byteOrderMagic == BYTE_ORDER_MAGIC) {
            swap = false;
        } else if (byteSwap(byteOrderMagic) == BYTE_ORDER_MAGIC) {
            swap = true;
        } else {
            throw new IOException("Corrupt S3 file " + location + path);
        }
        return dis;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,74079.java,51,81
default,46472.java,51,81
----------------------------------------
    private void parse(File f) {
        Pattern keyPat = Pattern.compile(" *// *key: *([^ ]+) *");
        Pattern optPat = Pattern.compile(" *// *options: *(.*)");
        Pattern runPat = Pattern.compile(" *// *run: *(.*)");
        Pattern javaPat = Pattern.compile(" *@?[A-Za-z].*");
        try {
            String[] lines = read(f).split("[\r\n]+");
            for (String line : lines) {
                Matcher keyMatch = keyPat.matcher(line);
                if (keyMatch.matches()) {
                    foundInfo(f);
                    declaredKeys.add(keyMatch.group(1));
                    continue;
                }
                Matcher optMatch = optPat.matcher(line);
                if (optMatch.matches()) {
                    foundInfo(f);
                    options = Arrays.asList(optMatch.group(1).trim().split(" +"));
                    continue;
                }
                Matcher runMatch = runPat.matcher(line);
                if (runMatch.matches()) {
                    foundInfo(f);
                    runOpts = Arrays.asList(runMatch.group(1).trim().split(" +"));
                }
                if (javaPat.matcher(line).matches()) break;
            }
        } catch (IOException e) {
            throw new Error(e);
        }
    }
----------------------------------------
    private void parse(File f) {
        Pattern keyPat = Pattern.compile(" *// *key: *([^ ]+) *");
        Pattern optPat = Pattern.compile(" *// *options: *(.*)");
        Pattern runPat = Pattern.compile(" *// *run: *(.*)");
        Pattern javaPat = Pattern.compile(" *@?[A-Za-z].*");
        try {
            String[] lines = read(f).split("[\r\n]+");
            for (String line : lines) {
                Matcher keyMatch = keyPat.matcher(line);
                if (keyMatch.matches()) {
                    foundInfo(f);
                    declaredKeys.add(keyMatch.group(1));
                    continue;
                }
                Matcher optMatch = optPat.matcher(line);
                if (optMatch.matches()) {
                    foundInfo(f);
                    options = Arrays.asList(optMatch.group(1).trim().split(" +"));
                    continue;
                }
                Matcher runMatch = runPat.matcher(line);
                if (runMatch.matches()) {
                    foundInfo(f);
                    runOpts = Arrays.asList(runMatch.group(1).trim().split(" +"));
                }
                if (javaPat.matcher(line).matches()) break;
            }
        } catch (IOException e) {
            throw new Error(e);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,58007.java,349,379
default,74778.java,318,346
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1285424.java,761,790
selected,2653397.java,761,790
----------------------------------------
    protected DataInputStream readS3BinaryHeader(String location, String path, Properties props) throws IOException {
        InputStream inputStream;
        if (location != null && location.equals("letrucimpossibleetquinexistepas")) inputStream = new java.io.FileInputStream(path); else inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new IOException("Can't open " + path);
        }
        DataInputStream dis = new DataInputStream(new BufferedInputStream(inputStream));
        String id = readWord(dis);
        if (!id.equals("s3")) {
            throw new IOException("Not proper s3 binary file " + location + path);
        }
        String name;
        while ((name = readWord(dis)) != null) {
            if (!name.equals("endhdr")) {
                String value = readWord(dis);
                props.setProperty(name, value);
            } else {
                break;
            }
        }
        int byteOrderMagic = dis.readInt();
        if (byteOrderMagic == BYTE_ORDER_MAGIC) {
            swap = false;
        } else if (byteSwap(byteOrderMagic) == BYTE_ORDER_MAGIC) {
            swap = true;
        } else {
            throw new IOException("Corrupt S3 file " + location + path);
        }
        return dis;
    }
----------------------------------------
    protected DataInputStream readS3BinaryHeader(String location, String path, Properties props) throws IOException {
        InputStream inputStream;
        if (location != null && location.equals("letrucimpossibleetquinexistepas")) inputStream = new java.io.FileInputStream(path); else inputStream = getClass().getResourceAsStream(path);
        if (inputStream == null) {
            throw new IOException("Can't open " + path);
        }
        DataInputStream dis = new DataInputStream(new BufferedInputStream(inputStream));
        String id = readWord(dis);
        if (!id.equals("s3")) {
            throw new IOException("Not proper s3 binary file " + location + path);
        }
        String name;
        while ((name = readWord(dis)) != null) {
            if (!name.equals("endhdr")) {
                String value = readWord(dis);
                props.setProperty(name, value);
            } else {
                break;
            }
        }
        int byteOrderMagic = dis.readInt();
        if (byteOrderMagic == BYTE_ORDER_MAGIC) {
            swap = false;
        } else if (byteSwap(byteOrderMagic) == BYTE_ORDER_MAGIC) {
            swap = true;
        } else {
            throw new IOException("Corrupt S3 file " + location + path);
        }
        return dis;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,102885.java,874,902
default,54081.java,876,904
----------------------------------------
        private void emitSet(String opcode, boolean[][] testsPerformed, int level) {
            if (emitters.isEmpty()) {
            } else if (isSingleton()) emitSingleton(opcode, testsPerformed, level); else {
                SplitRecord rec = split();
                if (DEBUG) {
                    for (int i = 0; i < level; i++) System.err.print("  ");
                    System.err.println("split of " + opcode + "[" + rec.argument + "] for " + encoding[rec.test]);
                }
                if (testsPerformed[rec.argument][rec.test] == true) {
                    System.err.println("repeated split of " + opcode + "[" + rec.argument + "] for " + encoding[rec.test]);
                    System.err.println(this);
                    System.exit(-1);
                }
                testsPerformed[rec.argument][rec.test] = true;
                EmitterSet[] splits = makeSplit(rec);
                emitTab(level);
                emit("if (");
                emitTest(rec.argument, rec.test);
                emit(") {\n");
                splits[0].emitSet(opcode, testsPerformed, level + 1);
                emit("\n");
                emitTab(level);
                emit("} else {\n");
                splits[1].emitSet(opcode, testsPerformed, level + 1);
                emitTab(level);
                emit("}\n");
                testsPerformed[rec.argument][rec.test] = false;
            }
        }
----------------------------------------
        private void emitSet(String opcode, boolean[][] testsPerformed, int level) {
            if (emitters.isEmpty()) {
            } else if (isSingleton()) emitSingleton(opcode, testsPerformed, level); else {
                SplitRecord rec = split();
                if (DEBUG) {
                    for (int i = 0; i < level; i++) System.err.print("  ");
                    System.err.println("split of " + opcode + "[" + rec.argument + "] for " + encoding[rec.test]);
                }
                if (testsPerformed[rec.argument][rec.test] == true) {
                    System.err.println("repeated split of " + opcode + "[" + rec.argument + "] for " + encoding[rec.test]);
                    System.err.println(this);
                    System.exit(1);
                }
                testsPerformed[rec.argument][rec.test] = true;
                EmitterSet[] splits = makeSplit(rec);
                emitTab(level);
                emit("if (");
                emitTest(rec.argument, rec.test);
                emit(") {\n");
                splits[0].emitSet(opcode, testsPerformed, level + 1);
                emit("\n");
                emitTab(level);
                emit("} else {\n");
                splits[1].emitSet(opcode, testsPerformed, level + 1);
                emitTab(level);
                emit("}\n");
                testsPerformed[rec.argument][rec.test] = false;
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,130704.java,74,103
default,8341.java,74,103
----------------------------------------
    protected Element getLangElement(String name) {
        NodeList nl = root.getElementsByTagName(name);
        Element deflang_el = null;
        for (int i = 0; i < nl.getLength(); i++) {
            Element e = (Element) nl.item(i);
            if (e.getAttribute("lang").equals(lang)) return e;
            if (e.getAttribute("lang").equals(DEFAULT_LANG)) deflang_el = e;
        }
        changed = true;
        if (deflang_el != null) {
            Element e = (Element) deflang_el.cloneNode(true);
            e.setAttribute("lang", lang);
            root.appendChild(e);
            return e;
        }
        Element e = doc.createElement(name);
        e.setAttribute("lang", DEFAULT_LANG);
        String defaultValue = dvp.getDefaultValue(name);
        if (defaultValue != null) {
            Text t = doc.createTextNode(defaultValue);
            e.appendChild(t);
        }
        root.appendChild(e);
        if (!lang.equals(DEFAULT_LANG)) {
            e = (Element) e.cloneNode(true);
            e.setAttribute("lang", lang);
            root.appendChild(e);
        }
        return e;
    }
----------------------------------------
    protected Element getLangElement(String name) {
        NodeList nl = root.getElementsByTagName(name);
        Element deflang_el = null;
        for (int i = 0; i < nl.getLength(); i++) {
            Element e = (Element) nl.item(i);
            if (e.getAttribute("lang").equals(lang)) return e;
            if (e.getAttribute("lang").equals(DEFAULT_LANG)) deflang_el = e;
        }
        changed = true;
        if (deflang_el != null) {
            Element e = (Element) deflang_el.cloneNode(true);
            e.setAttribute("lang", lang);
            root.appendChild(e);
            return e;
        }
        Element e = doc.createElement(name);
        e.setAttribute("lang", DEFAULT_LANG);
        String defaultValue = dvp.getDefaultValue(name);
        if (defaultValue != null) {
            Text t = doc.createTextNode(defaultValue);
            e.appendChild(t);
        }
        root.appendChild(e);
        if (!lang.equals(DEFAULT_LANG)) {
            e = (Element) e.cloneNode(true);
            e.setAttribute("lang", lang);
            root.appendChild(e);
        }
        return e;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76704.java,543,573
default,28942.java,539,569
----------------------------------------
    private void goToMainMethod() {
        breakpoint bp = null;
        try {
            bp = user.bmap.findBreakpoint("VM.debugBreakpoint", null, user.reg.hardwareIP());
        } catch (BmapMultipleException e1) {
            jdp_console.writeOutput(e1.getMessage());
        } catch (BmapNotFoundException e2) {
            jdp_console.writeOutput(e2.getMessage());
        }
        user.bpset.setBreakpoint(bp);
        user.enableIgnoreOtherBreakpointTrap();
        user.pcontinue(0, PRINTASSEMBLY, true);
        refreshEnvironment();
        if (dejavu) {
            System.out.println("An extra continue for Dejavu ...");
            user.pcontinue(0, PRINTASSEMBLY, true);
            refreshEnvironment();
        }
        refreshEnvironment();
        breakpoint main_bp;
        if (dejavu) {
            main_bp = setDejaVuMainBreakpoint();
        } else {
            main_bp = setMainBreakpoint();
        }
        user.bpset.clearBreakpoint(bp);
        user.disableIgnoreOtherBreakpointTrap();
        user.pcontinue(0, PRINTASSEMBLY, true);
        refreshEnvironment();
        user.bpset.clearBreakpoint(main_bp);
    }
----------------------------------------
    private void goToMainMethod() {
        breakpoint bp = null;
        try {
            bp = user.bmap.findBreakpoint("VM.debugBreakpoint", null, user.reg.hardwareIP());
        } catch (BmapMultipleException e1) {
            jdp_console.writeOutput(e1.getMessage());
        } catch (BmapNotFoundException e2) {
            jdp_console.writeOutput(e2.getMessage());
        }
        user.bpset.setBreakpoint(bp);
        user.enableIgnoreOtherBreakpointTrap();
        user.pcontinue(0, PRINTNONE, true);
        refreshEnvironment();
        if (dejavu) {
            System.out.println("An extra continue for Dejavu ...");
            user.pcontinue(0, PRINTASSEMBLY, true);
            refreshEnvironment();
        }
        refreshEnvironment();
        breakpoint main_bp;
        if (dejavu) {
            main_bp = setDejaVuMainBreakpoint();
        } else {
            main_bp = setMainBreakpoint();
        }
        user.bpset.clearBreakpoint(bp);
        user.disableIgnoreOtherBreakpointTrap();
        user.pcontinue(0, PRINTASSEMBLY, true);
        refreshEnvironment();
        user.bpset.clearBreakpoint(main_bp);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109329.java,896,926
default,72773.java,1041,1069
----------------------------------------
    protected LD getLD(Element ldElem) {
        if (ldElem != null && ldElem.getName().equals("LD")) {
            List content = ldElem.getChildren();
            int size = content.size();
            if (size > 0) {
                Hashtable<Integer, Rung> hashTable = new Hashtable<Integer, Rung>(size);
                Iterator iterator = content.iterator();
                int count = 0;
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    Rung rung = getRung(currentElement);
                    hashTable.put(new Integer(count), rung);
                    count++;
                }
                LD ld = new LD(hashTable);
                return ld;
            } else {
                System.err.println("Invalid child element size in getLD()");
                if (this.console != null) {
                    console.setText("Invalid child element size in getLD()");
                }
                return null;
            }
        } else {
            System.err.println("Invalid element input in getLD()");
            if (this.console != null) {
                console.setText("Invalid element input in getLD()");
            }
            return null;
        }
    }
----------------------------------------
    protected AdapterConnections getAdapterConnections(Element adapterConnectionsElem) {
        if (adapterConnectionsElem != null && adapterConnectionsElem.getName().equals("AdapterConnections")) {
            List content = adapterConnectionsElem.getChildren();
            int size = content.size();
            if (size > 0) {
                Hashtable<String, Connection> hashTable = new Hashtable<String, Connection>(size);
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    Connection connection = getConnection(currentElement);
                    hashTable.put(connection.getSource() + connection.getDestination(), connection);
                }
                AdapterConnections adapterConnections = new AdapterConnections(hashTable);
                return adapterConnections;
            } else {
                System.err.println("Invalid child element size in getAdapterConnections()");
                if (this.console != null) {
                    console.setText("Invalid child element size in getAdapterConnections()");
                }
                return null;
            }
        } else {
            System.err.println("Invalid element input in getAdapterConnections()");
            if (this.console != null) {
                console.setText("Invalid element input in getAdapterConnections()");
            }
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109329.java,754,784
default,72773.java,497,525
----------------------------------------
    protected FB getFB(Element fbElem) {
        if (fbElem != null && fbElem.getName().equals("FB")) {
            List content = fbElem.getChildren();
            int size = content.size();
            String Name = fbElem.getAttributeValue("Name");
            String Type = fbElem.getAttributeValue("Type");
            String Comment = fbElem.getAttributeValue("Comment");
            String x = fbElem.getAttributeValue("x");
            String y = fbElem.getAttributeValue("y");
            Hashtable<String, Parameter> hashTable = new Hashtable<String, Parameter>(size);
            FB fb;
            if (size > 0) {
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    Parameter parameter = getParameter(currentElement);
                    hashTable.put(Name, parameter);
                }
                fb = new FB(Name, Type, Comment, x, y, hashTable);
            } else {
                fb = new FB(Name, Type, Comment, x, y, null);
            }
            return fb;
        } else {
            System.err.println("Invalid element input in getFB()");
            if (this.console != null) {
                console.setText("Invalid element input in getFB()");
            }
            return null;
        }
    }
----------------------------------------
    protected AdapterDeclaration getAdapterDeclaration(Element adapterDeclarationElem) {
        if (adapterDeclarationElem != null && adapterDeclarationElem.getName().equals("Parameter")) {
            List content = adapterDeclarationElem.getChildren();
            int size = content.size();
            String Name = adapterDeclarationElem.getAttributeValue("Name");
            String Type = adapterDeclarationElem.getAttributeValue("Type");
            String Comment = adapterDeclarationElem.getAttributeValue("Comment");
            Hashtable<String, Parameter> hashTable = new Hashtable<String, Parameter>(size);
            AdapterDeclaration adapterDeclaration;
            if (size > 0) {
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    Parameter parameter = getParameter(currentElement);
                    hashTable.put(Name, parameter);
                }
                adapterDeclaration = new AdapterDeclaration(Name, Type, Comment, hashTable);
            } else {
                adapterDeclaration = new AdapterDeclaration(Name, Type, Comment, null);
            }
            return adapterDeclaration;
        } else {
            System.err.println("Invalid element input in getAdapterDeclaration()");
            if (this.console != null) {
                console.setText("Invalid element input in getAdapterDeclaration()");
            }
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109329.java,617,646
default,72773.java,451,479
----------------------------------------
    protected InternalVars getInternalVars(Element internalVarsElem) {
        if (internalVarsElem != null && internalVarsElem.getName().equals("InternalVars")) {
            List content = internalVarsElem.getChildren();
            int size = content.size();
            if (size > 0) {
                Hashtable<String, FBVarDeclaration> hashTable = new Hashtable<String, FBVarDeclaration>(size);
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    FBVarDeclaration varDeclaration = getVarDeclaration(currentElement);
                    hashTable.put(varDeclaration.getName(), varDeclaration);
                }
                InternalVars internalVars = new InternalVars(hashTable);
                return internalVars;
            } else {
                System.err.println("Invalid child element size in getInternalVars()");
                if (this.console != null) {
                    console.setText("Invalid child element size in getInternalVars()");
                }
                return null;
            }
        } else {
            System.err.println("Invalid element input in getInternalVars()");
            System.exit(0);
            if (this.console != null) {
                console.setText("Invalid element input in getInternalVars()");
            }
            return null;
        }
    }
----------------------------------------
    protected FBOutputVars getOutputVars(Element outputVarsElem) {
        if (outputVarsElem != null && outputVarsElem.getName().equals("OutputVars")) {
            List content = outputVarsElem.getChildren();
            int size = content.size();
            if (size > 0) {
                Hashtable<String, FBVarDeclaration> hashTable = new Hashtable<String, FBVarDeclaration>(size);
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    FBVarDeclaration varDeclaration = getVarDeclaration(currentElement);
                    hashTable.put(varDeclaration.getName(), varDeclaration);
                }
                FBOutputVars outputVars = new FBOutputVars(hashTable);
                return outputVars;
            } else {
                System.err.println("Invalid child element size in getOutputVars()");
                if (this.console != null) {
                    console.setText("Invalid child element size in getOutputVars()");
                }
                return null;
            }
        } else {
            System.err.println("Invalid element input in getOutputVars()");
            if (this.console != null) {
                console.setText("Invalid element input in getOutputVars()");
            }
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2666453.java,80,109
selected,2666453.java,503,532
----------------------------------------
    public void cosProcessStatusChanged(java.lang.String entity, tcg.syscontrol.cos.CosProcessStatusEnum status) {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("cosProcessStatusChanged", true);
                    _os.write_string(entity);
                    tcg.syscontrol.cos.CosProcessStatusEnumHelper.write(_os, status);
                    _is = _invoke(_os);
                    return;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("cosProcessStatusChanged", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                ICosProcessManagerOperations _localServant = (ICosProcessManagerOperations) _so.servant;
                try {
                    _localServant.cosProcessStatusChanged(entity, status);
                } finally {
                    _servant_postinvoke(_so);
                }
                return;
            }
        }
    }
----------------------------------------
    public void cosUpdateCorbaServerOperationMode(java.lang.String uniqueKey, tcg.syscontrol.cos.CosOperationModeEnum operationMode) {
        while (true) {
            if (!this._is_local()) {
                org.omg.CORBA.portable.InputStream _is = null;
                try {
                    org.omg.CORBA.portable.OutputStream _os = _request("cosUpdateCorbaServerOperationMode", true);
                    _os.write_string(uniqueKey);
                    tcg.syscontrol.cos.CosOperationModeEnumHelper.write(_os, operationMode);
                    _is = _invoke(_os);
                    return;
                } catch (org.omg.CORBA.portable.RemarshalException _rx) {
                } catch (org.omg.CORBA.portable.ApplicationException _ax) {
                    String _id = _ax.getId();
                    throw new RuntimeException("Unexpected exception " + _id);
                } finally {
                    this._releaseReply(_is);
                }
            } else {
                org.omg.CORBA.portable.ServantObject _so = _servant_preinvoke("cosUpdateCorbaServerOperationMode", _opsClass);
                if (_so == null) throw new org.omg.CORBA.UNKNOWN("local invocations not supported!");
                ICosProcessManagerOperations _localServant = (ICosProcessManagerOperations) _so.servant;
                try {
                    _localServant.cosUpdateCorbaServerOperationMode(uniqueKey, operationMode);
                } finally {
                    _servant_postinvoke(_so);
                }
                return;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,11447.java,519,548
selected,2271740.java,435,464
----------------------------------------
    private void readSOAPResponse(Xtvd xtvd) throws DataDirectException {
        try {
            log.write(sdf.format(new Date()));
            log.write("\tReading response from server");
            log.write(SOAPRequest.END_OF_LINE);
        } catch (IOException ioex) {
            ioex.printStackTrace();
        }
        try {
            if (httpConnection.getResponseCode() == HttpURLConnection.HTTP_OK) {
                try {
                    BufferedReader reader = getReader();
                    Parser parser = ParserFactory.getXtvdParser(reader, xtvd);
                    parser.setLog(log);
                    parser.parseXTVD();
                    reader.close();
                    log.write(sdf.format(new Date()));
                    log.write("\tFinished reading response from server");
                    log.write(SOAPRequest.END_OF_LINE);
                    log.flush();
                } catch (Throwable t) {
                    throw new DataDirectException(t.getMessage(), t);
                }
            } else {
                processError();
            }
        } catch (IOException ioex) {
            throw new DataDirectException(ioex.getMessage(), ioex);
        }
    }
----------------------------------------
    private void readSOAPResponse(Writer writer) throws DataDirectException {
        try {
            log.write(sdf.format(new Date()));
            log.write("\tReading response from server");
            log.write(SOAPRequest.END_OF_LINE);
        } catch (IOException ioex) {
            ioex.printStackTrace();
        }
        try {
            if (httpConnection.getResponseCode() == HttpURLConnection.HTTP_OK) {
                try {
                    BufferedReader reader = getReader();
                    Parser parser = ParserFactory.getWriterParser(reader, writer);
                    parser.setLog(log);
                    parser.parseXTVD();
                    reader.close();
                    log.write(sdf.format(new Date()));
                    log.write("\tFinished reading response from server");
                    log.write(SOAPRequest.END_OF_LINE);
                    log.flush();
                } catch (Throwable t) {
                    throw new DataDirectException(t.getMessage(), t);
                }
            } else {
                processError();
            }
        } catch (IOException ioex) {
            throw new DataDirectException(ioex.getMessage(), ioex);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76704.java,1000,1029
default,40635.java,964,988
----------------------------------------
    public void doMemoryReadRaw(String command, String[] args) {
        StringBuffer ret = new StringBuffer();
        ret.append("Actual memory (breakpoints shown as is):\n");
        int addr, count;
        switch(args.length) {
            case 0:
                jdp_console.writeOutput(ret.toString());
                printHelp(command);
                break;
            case 1:
                try {
                    addr = parseHex32(args[0]);
                    ret.append(user.mem.printRaw(addr, 5));
                } catch (NumberFormatException e) {
                    ret.append("bad address: " + args[0] + "\n");
                }
                jdp_console.writeOutput(ret.toString());
                break;
            default:
                try {
                    addr = parseHex32(args[0]);
                    count = Integer.parseInt(args[1]);
                    ret.append(user.mem.printRaw(addr, count));
                } catch (NumberFormatException e) {
                    ret.append("bad address or count: " + args[0] + ", " + args[1] + "\n");
                }
                jdp_console.writeOutput(ret.toString());
                break;
        }
    }
----------------------------------------
    public void doMemoryRead(String command, String[] args) {
        int addr, count;
        switch(args.length) {
            case 0:
                printHelp(command);
                break;
            case 1:
                try {
                    addr = parseHex32(args[0]);
                    jdp_console.writeOutput(user.mem.print(addr, 5));
                } catch (NumberFormatException e) {
                    jdp_console.writeOutput("bad address: " + args[0]);
                }
                break;
            default:
                try {
                    addr = parseHex32(args[0]);
                    count = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.print(addr, count));
                } catch (NumberFormatException e) {
                    jdp_console.writeOutput("bad address or count: " + args[0] + ", " + args[1]);
                }
                break;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,604968.java,59,86
selected,604968.java,88,117
----------------------------------------
    public int chmod(String path, int mode) throws FuseException {
        try {
            File f = resolvePath(path);
            int ftype = this.getFtype(path);
            if (ftype == FuseFtype.TYPE_SYMLINK || ftype == FuseFtype.TYPE_DIR) {
                Path p = Paths.get(f.getPath());
                try {
                    Files.setAttribute(p, "unix:mode", Integer.valueOf(mode));
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new FuseException("access denied for " + path).initErrno(FuseException.EACCES);
                } finally {
                    path = null;
                }
            } else {
                MetaDataDedupFile mf = MetaFileStore.getMF(f);
                try {
                    mf.setMode(mode);
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new FuseException("access denied for " + path).initErrno(FuseException.EACCES);
                } finally {
                }
            }
        } finally {
        }
        return 0;
    }
----------------------------------------
    public int chown(String path, int uid, int gid) throws FuseException {
        try {
            File f = resolvePath(path);
            int ftype = this.getFtype(path);
            if (ftype == FuseFtype.TYPE_SYMLINK || ftype == FuseFtype.TYPE_DIR) {
                Path p = Paths.get(f.getPath());
                try {
                    Files.setAttribute(p, "unix:uid", Integer.valueOf(uid));
                    Files.setAttribute(p, "unix:gid", Integer.valueOf(gid));
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new FuseException("access denied for " + path).initErrno(FuseException.EACCES);
                } finally {
                    path = null;
                }
            } else {
                MetaDataDedupFile mf = MetaFileStore.getMF(f);
                try {
                    mf.setOwner_id(uid);
                    mf.setGroup_id(gid);
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new FuseException("access denied for " + path).initErrno(FuseException.EACCES);
                } finally {
                }
            }
        } finally {
        }
        return 0;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1262287.java,557,584
selected,472295.java,553,580
----------------------------------------
    private Pool createSenonePool(float distFloor, float varianceFloor) {
        Pool pool = new Pool("senones");
        int numMixtureWeights = mixtureWeightsPool.size();
        int numMeans = meansPool.size();
        int numVariances = variancePool.size();
        int numGaussiansPerSenone = mixtureWeightsPool.getFeature(NUM_GAUSSIANS_PER_STATE, 0);
        int numSenones = mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        int whichGaussian = 0;
        logger.fine("NG " + numGaussiansPerSenone);
        logger.fine("NS " + numSenones);
        logger.fine("NMIX " + numMixtureWeights);
        logger.fine("NMNS " + numMeans);
        logger.fine("NMNS " + numVariances);
        assert numGaussiansPerSenone > 0;
        assert numMixtureWeights == numSenones;
        assert numVariances == numSenones * numGaussiansPerSenone;
        assert numMeans == numSenones * numGaussiansPerSenone;
        for (int i = 0; i < numSenones; i++) {
            MixtureComponent[] mixtureComponents = new MixtureComponent[numGaussiansPerSenone];
            for (int j = 0; j < numGaussiansPerSenone; j++) {
                mixtureComponents[j] = new MixtureComponent(logMath, (float[]) meansPool.get(whichGaussian), (float[][]) meanTransformationMatrixPool.get(0), (float[]) meanTransformationVectorPool.get(0), (float[]) variancePool.get(whichGaussian), (float[][]) varianceTransformationMatrixPool.get(0), (float[]) varianceTransformationVectorPool.get(0), distFloor, varianceFloor);
                whichGaussian++;
            }
            Senone senone = new GaussianMixture(logMath, (float[]) mixtureWeightsPool.get(i), mixtureComponents, i);
            pool.put(i, senone);
        }
        return pool;
    }
----------------------------------------
    private Pool createSenonePool(float distFloor, float varianceFloor) {
        Pool pool = new Pool("senones");
        int numMixtureWeights = mixtureWeightsPool.size();
        int numMeans = meansPool.size();
        int numVariances = variancePool.size();
        int numGaussiansPerSenone = mixtureWeightsPool.getFeature(NUM_GAUSSIANS_PER_STATE, 0);
        int numSenones = mixtureWeightsPool.getFeature(NUM_SENONES, 0);
        int whichGaussian = 0;
        logger.fine("NG " + numGaussiansPerSenone);
        logger.fine("NS " + numSenones);
        logger.fine("NMIX " + numMixtureWeights);
        logger.fine("NMNS " + numMeans);
        logger.fine("NMNS " + numVariances);
        assert numGaussiansPerSenone > 0;
        assert numMixtureWeights == numSenones;
        assert numVariances == numSenones * numGaussiansPerSenone;
        assert numMeans == numSenones * numGaussiansPerSenone;
        for (int i = 0; i < numSenones; i++) {
            MixtureComponent[] mixtureComponents = new MixtureComponent[numGaussiansPerSenone];
            for (int j = 0; j < numGaussiansPerSenone; j++) {
                mixtureComponents[j] = new MixtureComponent(logMath, (float[]) meansPool.get(whichGaussian), (float[][]) meanTransformationMatrixPool.get(0), (float[]) meanTransformationVectorPool.get(0), (float[]) variancePool.get(whichGaussian), (float[][]) varianceTransformationMatrixPool.get(0), (float[]) varianceTransformationVectorPool.get(0), distFloor, varianceFloor);
                whichGaussian++;
            }
            Senone senone = new GaussianMixture(logMath, (float[]) mixtureWeightsPool.get(i), mixtureComponents, i);
            pool.put(i, senone);
        }
        return pool;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2236931.java,180,209
selected,1929102.java,174,202
----------------------------------------
    public static String getData(String url) {
        try {
            u = new URL(url);
            uc = (HttpURLConnection) u.openConnection();
            uc.setDoOutput(true);
            uc.setRequestProperty("Host", "www.mediafire.com");
            uc.setRequestProperty("Connection", "keep-alive");
            uc.setRequestProperty("Referer", "http://mediafire.com/");
            uc.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.112 Safari/535.1");
            uc.setRequestProperty("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
            uc.setRequestProperty("Accept-Encoding", "html");
            uc.setRequestProperty("Accept-Language", "en-US,en;q=0.8");
            uc.setRequestProperty("Accept-Charset", "ISO-8859-1,utf-8;q=0.7,*;q=0.3");
            uc.setRequestProperty("Cookie", ukeycookie + ";" + skeycookie + ";" + usercookie);
            uc.setRequestMethod("GET");
            uc.setInstanceFollowRedirects(false);
            br = new BufferedReader(new InputStreamReader(uc.getInputStream()));
            String temp = "", k = "";
            while ((temp = br.readLine()) != null) {
                k += temp;
            }
            br.close();
            u = null;
            uc = null;
            return k;
        } catch (Exception e) {
            System.out.println("exception : " + e.toString());
            return "";
        }
    }
----------------------------------------
    public static String getData(String url) {
        try {
            u = new URL(url);
            uc = (HttpURLConnection) u.openConnection();
            uc.setDoOutput(true);
            uc.setRequestProperty("Host", "www.rapidshare.com");
            uc.setRequestProperty("Connection", "keep-alive");
            uc.setRequestProperty("Referer", "http://rapidshare.com/");
            uc.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.112 Safari/535.1");
            uc.setRequestProperty("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
            uc.setRequestProperty("Accept-Encoding", "html");
            uc.setRequestProperty("Accept-Language", "en-US,en;q=0.8");
            uc.setRequestProperty("Accept-Charset", "ISO-8859-1,utf-8;q=0.7,*;q=0.3");
            uc.setRequestMethod("GET");
            uc.setInstanceFollowRedirects(false);
            br = new BufferedReader(new InputStreamReader(uc.getInputStream()));
            String temp = "", k = "";
            while ((temp = br.readLine()) != null) {
                k += temp;
            }
            br.close();
            u = null;
            uc = null;
            return k;
        } catch (Exception e) {
            System.out.println("exception : " + e.toString());
            return "";
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1896463.java,363,390
selected,2220325.java,397,426
----------------------------------------
    private final int renderMain(OpenGLCapabilities glCaps, OpenGLStatesCache statesCache, RenderOptions options, boolean isScissorEnabled, boolean isClipperEnabled, View view, RenderPass renderPass, long frameId, int nameOffset, long nanoTime, long nanoStep, RenderMode renderMode) throws Throwable {
        X3DLog.debug("Rendering ", 2, " bins");
        int triangles = 0;
        ProfileTimer.startProfile(X3DLog.LOG_CHANNEL, "CanvasPeerImpl::Drawing Main Scene");
        final RenderBinProvider binProvider = renderPass.getRenderBinProvider();
        if (binProvider.getOpaqueBin().size() > 0) {
            if (!statesCache.enabled || !statesCache.depthTestEnabled) {
                GL11.glEnable(GL11.GL_DEPTH_TEST);
                statesCache.depthTestEnabled = true;
            }
            triangles += drawBin(statesCache, glCaps, options, isScissorEnabled, isClipperEnabled, binProvider.getOpaqueBin(), view, frameId, nameOffset, nanoTime, nanoStep, renderMode);
            nameOffset += binProvider.getOpaqueBin().size();
        }
        if (binProvider.getTransparentBin().size() > 0) {
            triangles += drawBin(statesCache, glCaps, options, isScissorEnabled, isClipperEnabled, binProvider.getTransparentBin(), view, frameId, nameOffset, nanoTime, nanoStep, renderMode);
            nameOffset += binProvider.getTransparentBin().size();
        }
        ProfileTimer.endProfile();
        if (!statesCache.enabled || !statesCache.depthTestEnabled) {
            GL11.glEnable(GL11.GL_DEPTH_TEST);
            statesCache.depthTestEnabled = true;
        }
        if ((renderMode != RenderMode.PICKING) && ((shotCreator == null) || (shotCreator.getFormat() == ScreenshotCreator.Format.RGB))) {
            triangles += shadowPeer.drawShadows(view, renderPass.getShadowCasterLight(), binProvider.getShadowsBin(), frameId);
        }
        getCanvasPeer().addTriangles(triangles);
        return (nameOffset);
    }
----------------------------------------
    private final int renderMain(GL gl, OpenGLCapabilities glCaps, OpenGLStatesCache statesCache, RenderOptions options, boolean isScissorEnabled, boolean isClipperEnabled, View view, RenderPass renderPass, long frameId, int nameOffset, long nanoTime, long nanoStep, RenderMode renderMode) throws Throwable {
        X3DLog.debug("Rendering opaque and transparent bin");
        int triangles = 0;
        ProfileTimer.startProfile(X3DLog.LOG_CHANNEL, "CanvasPeerImpl::Drawing Main Scene");
        final RenderBinProvider binProvider = renderPass.getRenderBinProvider();
        if (binProvider.getOpaqueBin().size() > 0) {
            if (!statesCache.enabled || !statesCache.depthTestEnabled) {
                gl.glEnable(GL.GL_DEPTH_TEST);
                statesCache.depthTestEnabled = true;
            }
            triangles += drawBin(gl, statesCache, glCaps, options, isScissorEnabled, isClipperEnabled, binProvider.getOpaqueBin(), view, frameId, nameOffset, nanoTime, nanoStep, renderMode);
            nameOffset += binProvider.getOpaqueBin().size();
        }
        if (binProvider.getTransparentBin().size() > 0) {
            triangles += drawBin(gl, statesCache, glCaps, options, isScissorEnabled, isClipperEnabled, binProvider.getTransparentBin(), view, frameId, nameOffset, nanoTime, nanoStep, renderMode);
            nameOffset += binProvider.getTransparentBin().size();
        }
        ProfileTimer.endProfile();
        if ((renderMode == RenderMode.PICKING)) {
            if (!statesCache.enabled || !statesCache.depthTestEnabled) {
                gl.glEnable(GL.GL_DEPTH_TEST);
                statesCache.depthTestEnabled = true;
            }
        }
        if ((renderMode != RenderMode.PICKING) && ((shotCreator == null) || (shotCreator.getFormat() == ScreenshotCreator.Format.RGB))) {
            triangles += shadowPeer.drawShadows(gl, view, renderPass.getShadowCasterLight(), binProvider.getShadowsBin(), frameId);
        }
        getCanvasPeer().addTriangles(triangles);
        return (nameOffset);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126039.java,44,73
default,42661.java,44,73
----------------------------------------
    public ImageDisplay(ImageDisplayApplet applet, GraphicsConfiguration gc) {
        this.applet = applet;
        if (applet == null) {
            frame = new JFrame(gc);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        }
        setLayout(new BorderLayout());
        setPreferredSize(new Dimension(PREFERRED_WIDTH, PREFERRED_HEIGHT));
        Action openAction = new AbstractAction("Open File", new ImageIcon(getClass().getResource("/open.gif"))) {

            public void actionPerformed(ActionEvent e) {
                if (filechooser == null) {
                    filechooser = new JFileChooser();
                    filechooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
                }
                if (filechooser.showOpenDialog(ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {
                    open(filechooser.getSelectedFile());
                }
            }
        };
        JToolBar bar = new JToolBar();
        bar.add(new ToolBarButton(openAction));
        add(bar, BorderLayout.NORTH);
        if (applet == null) {
            frame.setTitle("Image Display - Control Panel");
            frame.getContentPane().add(this, BorderLayout.CENTER);
            frame.pack();
            frame.show();
        }
    }
----------------------------------------
    public ImageDisplay(ImageDisplayApplet applet, GraphicsConfiguration gc) {
        this.applet = applet;
        if (applet == null) {
            frame = new JFrame(gc);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        }
        setLayout(new BorderLayout());
        setPreferredSize(new Dimension(PREFERRED_WIDTH, PREFERRED_HEIGHT));
        Action openAction = new AbstractAction("Open File", new ImageIcon(getClass().getResource("/open.gif"))) {

            public void actionPerformed(ActionEvent e) {
                if (filechooser == null) {
                    filechooser = new JFileChooser();
                    filechooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
                }
                if (filechooser.showOpenDialog(ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {
                    open(filechooser.getSelectedFile());
                }
            }
        };
        JToolBar bar = new JToolBar();
        bar.add(new ToolBarButton(openAction));
        add(bar, BorderLayout.NORTH);
        if (applet == null) {
            frame.setTitle("Image Display - Control Panel");
            frame.getContentPane().add(this, BorderLayout.CENTER);
            frame.pack();
            frame.show();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,753625.java,1071,1099
selected,1494993.java,1148,1176
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (suspendEncoding) {
                super.out.write(theByte);
                return;
            }
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(encode3to4(b4, buffer, bufferLength, options));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    }
                } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (suspendEncoding) {
                super.out.write(theByte);
                return;
            }
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(encode3to4(b4, buffer, bufferLength, options));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    }
                } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90813.java,874,902
default,28942.java,874,902
----------------------------------------
    public void doSetBreakpoint(String command, String[] args) {
        breakpoint bp = null;
        if (args.length != 0) {
            try {
                int addr = parseHex32(args[0]);
                jdp_console.writeOutput("Caution: setting breakpoint at raw address. \n  If the code is moved by GC, the breakpoint will be lost \n  and the trap instruction will be left in the code.");
                bp = new breakpoint(addr);
            } catch (NumberFormatException e) {
                String sig = null;
                if (args.length >= 2) {
                    sig = args[1];
                }
                try {
                    bp = user.bmap.findBreakpoint(args[0], sig, user.reg.hardwareIP());
                } catch (BmapMultipleException e1) {
                    jdp_console.writeOutput(e1.getMessage());
                } catch (BmapNotFoundException e2) {
                    jdp_console.writeOutput(e2.getMessage());
                }
            }
            if (bp != null) {
                user.bpset.setBreakpoint(bp);
                jdp_console.writeOutput("breakpoint at: " + bp.toString(user.bmap));
            }
        } else {
            jdp_console.writeOutput(user.bpset.list());
            Platform.printbp();
        }
    }
----------------------------------------
    public void doSetBreakpoint(String command, String[] args) {
        breakpoint bp = null;
        if (args.length != 0) {
            try {
                int addr = parseHex32(args[0]);
                jdp_console.writeOutput("Caution: setting breakpoint at raw address. \n  If the code is moved by GC, the breakpoint will be lost \n  and the trap instruction will be left in the code.");
                bp = new breakpoint(addr);
            } catch (NumberFormatException e) {
                String sig = null;
                if (args.length >= 2) {
                    sig = args[1];
                }
                try {
                    bp = user.bmap.findBreakpoint(args[0], sig, user.reg.hardwareIP());
                } catch (BmapMultipleException e1) {
                    jdp_console.writeOutput(e1.getMessage());
                } catch (BmapNotFoundException e2) {
                    jdp_console.writeOutput(e2.getMessage());
                }
            }
            if (bp != null) {
                user.bpset.setBreakpoint(bp);
                jdp_console.writeOutput("breakpoint at: " + bp.toString(user.bmap));
            }
        } else {
            jdp_console.writeOutput(user.bpset.list());
            Platform.printbp();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,768110.java,604,631
selected,2640744.java,464,491
----------------------------------------
    private void computeFieldInfo() {
        primBytes = 0;
        objFields = 0;
        for (int i = 0; i < fields.length; i++) {
            switch(fields[i].getTypeCode()) {
                case 'B':
                case 'Z':
                    primBytes += 1;
                    break;
                case 'C':
                case 'S':
                    primBytes += 2;
                    break;
                case 'I':
                case 'F':
                    primBytes += 4;
                    break;
                case 'J':
                case 'D':
                    primBytes += 8;
                    break;
                case 'L':
                case '[':
                    objFields += 1;
                    break;
            }
        }
    }
----------------------------------------
    private void computeFieldInfo() {
        primBytes = 0;
        objFields = 0;
        for (int i = 0; i < fields.length; i++) {
            switch(fields[i].getTypeCode()) {
                case 'B':
                case 'Z':
                    primBytes += 1;
                    break;
                case 'C':
                case 'S':
                    primBytes += 2;
                    break;
                case 'I':
                case 'F':
                    primBytes += 4;
                    break;
                case 'J':
                case 'D':
                    primBytes += 8;
                    break;
                case 'L':
                case '[':
                    objFields += 1;
                    break;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2640664.java,1070,1098
selected,2108660.java,1254,1282
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (suspendEncoding) {
                super.out.write(theByte);
                return;
            }
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(encode3to4(b4, buffer, bufferLength, options));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    }
                } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (suspendEncoding) {
                super.out.write(theByte);
                return;
            }
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(encode3to4(b4, buffer, bufferLength, options));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    }
                } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2510322.java,1073,1101
selected,1483221.java,1147,1175
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (suspendEncoding) {
                super.out.write(theByte);
                return;
            }
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(encode3to4(b4, buffer, bufferLength, options));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    }
                } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (suspendEncoding) {
                super.out.write(theByte);
                return;
            }
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(encode3to4(b4, buffer, bufferLength, options));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    }
                } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,89117.java,381,408
default,108650.java,783,810
----------------------------------------
    public void saveTaskList(StringBuffer output) throws Exception {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        DOMImplementation di = db.getDOMImplementation();
        Document doc = di.createDocument("", "tasks", null);
        Element root = doc.getDocumentElement();
        String[] keys = (String[]) tasks.keySet().toArray(new String[0]);
        for (int x = 0; x < keys.length; x++) {
            TaskCommand taskData = (TaskCommand) tasks.get(keys[x]);
            taskData.addXML(doc, root);
        }
        ByteArrayOutputStream buff = new ByteArrayOutputStream();
        TransformerFactory factory = TransformerFactory.newInstance();
        Transformer transformer = factory.newTransformer();
        transformer.setOutputProperty(OutputKeys.METHOD, "xml");
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        Source source = new DOMSource(doc);
        Result result = new StreamResult(buff);
        transformer.transform(source, result);
        if (output != null) {
            output.append(buff.toString());
        } else {
            FileWriter out = new FileWriter(this.getProperty("path.data") + File.separator + "Tasks.xml");
            out.write(buff.toString());
            out.close();
            System.out.println("Tasks.xml saved.");
        }
    }
----------------------------------------
    public void saveChannels(StringBuffer output) throws Exception {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        DOMImplementation di = db.getDOMImplementation();
        Document doc = di.createDocument("", "channels", null);
        Element root = doc.getDocumentElement();
        String[] keys = (String[]) channels.keySet().toArray(new String[0]);
        for (int x = 0; x < keys.length; x++) {
            Channel chan = (Channel) channels.get(keys[x]);
            root.appendChild(chan.getXML(doc));
        }
        ByteArrayOutputStream buff = new ByteArrayOutputStream();
        TransformerFactory factory = TransformerFactory.newInstance();
        Transformer transformer = factory.newTransformer();
        transformer.setOutputProperty(OutputKeys.METHOD, "xml");
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        Source source = new DOMSource(doc);
        Result result = new StreamResult(buff);
        transformer.transform(source, result);
        if (output != null) {
            output.append(buff.toString());
        } else {
            FileWriter out = new FileWriter(this.getProperty("path.data") + File.separator + "Channels.xml");
            out.write(buff.toString());
            out.close();
            System.out.println("Channels.xml saved.");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2296872.java,1417,1443
selected,2296872.java,1417,1443
----------------------------------------
    public static byte[] HexStringToBytes(String hexString, boolean handleDirty) throws Exception {
        if (handleDirty) {
            if (hexString.isEmpty()) {
                return Helpers.EmptyBytes;
            }
            StringBuilder stripped = new StringBuilder(hexString.length());
            char c;
            for (int i = 0; i < hexString.length(); i++) {
                c = hexString.charAt(i);
                if (IsHexDigit(c)) {
                    stripped.append(c);
                }
            }
            hexString = stripped.toString();
            if (hexString.length() % 2 != 0) {
                hexString = hexString.substring(0, hexString.length() - 1);
            }
        }
        int byteLength = hexString.length() / 2;
        byte[] bytes = new byte[byteLength];
        int j = 0;
        for (int i = 0; i < bytes.length; i++) {
            bytes[i] = HexToByte(hexString.substring(j, 2));
            j += 2;
        }
        return bytes;
    }
----------------------------------------
    public static byte[] HexStringToBytes(String hexString, boolean handleDirty) throws Exception {
        if (handleDirty) {
            if (hexString.isEmpty()) {
                return Helpers.EmptyBytes;
            }
            StringBuilder stripped = new StringBuilder(hexString.length());
            char c;
            for (int i = 0; i < hexString.length(); i++) {
                c = hexString.charAt(i);
                if (IsHexDigit(c)) {
                    stripped.append(c);
                }
            }
            hexString = stripped.toString();
            if (hexString.length() % 2 != 0) {
                hexString = hexString.substring(0, hexString.length() - 1);
            }
        }
        int byteLength = hexString.length() / 2;
        byte[] bytes = new byte[byteLength];
        int j = 0;
        for (int i = 0; i < bytes.length; i++) {
            bytes[i] = HexToByte(hexString.substring(j, 2));
            j += 2;
        }
        return bytes;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73461.java,50,78
default,25156.java,50,78
----------------------------------------
    public static AudioInputStream getConvertedStream2(AudioInputStream sourceStream, AudioFormat.Encoding targetEncoding) throws Exception {
        AudioFormat sourceFormat = sourceStream.getFormat();
        if (!quiet) {
            System.out.println("Input format: " + sourceFormat);
        }
        AudioFormat targetFormat = new AudioFormat(targetEncoding, sourceFormat.getSampleRate(), AudioSystem.NOT_SPECIFIED, sourceFormat.getChannels(), AudioSystem.NOT_SPECIFIED, AudioSystem.NOT_SPECIFIED, false);
        AudioInputStream targetStream = null;
        if (!AudioSystem.isConversionSupported(targetFormat, sourceFormat)) {
            if (DEBUG && !quiet) {
                System.out.println("Direct conversion not possible.");
                System.out.println("Trying with intermediate PCM format.");
            }
            AudioFormat intermediateFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, sourceFormat.getSampleRate(), 16, sourceFormat.getChannels(), 2 * sourceFormat.getChannels(), sourceFormat.getSampleRate(), false);
            if (AudioSystem.isConversionSupported(intermediateFormat, sourceFormat)) {
                sourceStream = AudioSystem.getAudioInputStream(intermediateFormat, sourceStream);
            }
        }
        targetStream = AudioSystem.getAudioInputStream(targetFormat, sourceStream);
        if (targetStream == null) {
            throw new Exception("conversion not supported");
        }
        if (!quiet) {
            if (DEBUG) {
                System.out.println("Got converted AudioInputStream: " + targetStream.getClass().getName());
            }
            System.out.println("Output format: " + targetStream.getFormat());
        }
        return targetStream;
    }
----------------------------------------
    public static AudioInputStream getConvertedStream2(AudioInputStream sourceStream, AudioFormat.Encoding targetEncoding) throws Exception {
        AudioFormat sourceFormat = sourceStream.getFormat();
        if (!quiet) {
            System.out.println("Input format: " + sourceFormat);
        }
        AudioFormat targetFormat = new AudioFormat(targetEncoding, sourceFormat.getSampleRate(), AudioSystem.NOT_SPECIFIED, sourceFormat.getChannels(), AudioSystem.NOT_SPECIFIED, AudioSystem.NOT_SPECIFIED, false);
        AudioInputStream targetStream = null;
        if (!AudioSystem.isConversionSupported(targetFormat, sourceFormat)) {
            if (DEBUG && !quiet) {
                System.out.println("Direct conversion not possible.");
                System.out.println("Trying with intermediate PCM format.");
            }
            AudioFormat intermediateFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, sourceFormat.getSampleRate(), 16, sourceFormat.getChannels(), 2 * sourceFormat.getChannels(), sourceFormat.getSampleRate(), false);
            if (AudioSystem.isConversionSupported(intermediateFormat, sourceFormat)) {
                sourceStream = AudioSystem.getAudioInputStream(intermediateFormat, sourceStream);
            }
        }
        targetStream = AudioSystem.getAudioInputStream(targetFormat, sourceStream);
        if (targetStream == null) {
            throw new Exception("conversion not supported");
        }
        if (!quiet) {
            if (DEBUG) {
                System.out.println("Got converted AudioInputStream: " + targetStream.getClass().getName());
            }
            System.out.println("Output format: " + targetStream.getFormat());
        }
        return targetStream;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1931054.java,1155,1183
selected,2339370.java,1075,1103
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (suspendEncoding) {
                super.out.write(theByte);
                return;
            }
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(encode3to4(b4, buffer, bufferLength, options));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    }
                } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (suspendEncoding) {
                super.out.write(theByte);
                return;
            }
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(encode3to4(b4, buffer, bufferLength, options));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    }
                } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1631513.java,416,444
selected,1631513.java,454,481
----------------------------------------
    public void subscribeDirect(Collection wanted) {
        if (subscriptions == null) {
            subscriptions = new ArrayList();
        }
        if (wanted.isEmpty()) {
            return;
        }
        Iterator it = wanted.iterator();
        while (it.hasNext()) {
            try {
                Subscribe subscribeReq = new Subscribe();
                OfferType offer = (OfferType) it.next();
                subscribeReq.setOfferId(offer.getOfferId());
                Logger.instance().log(Logger.DEBUG, loggerPrefix, "TwICESubscriber.subscribeDirect", "subscribing directly to offer id " + offer.getOfferId());
                TwICEUtil.setRequestHeader((Stub) syndicator, createIceHeader(null));
                SubscriptionType subscription = syndicator.subscribe(subscribeReq);
                Logger.instance().log(Logger.DEBUG, loggerPrefix, "TwICESubscriber.subscribeDirect", "subscribed successfully to offer id " + offer.getOfferId());
                subscription.setCurrentState(new Token("ICE-INITIAL"));
                subscriptions.add(subscription);
                store();
            } catch (StatusCode sc) {
                IceFault fault = new IceFault(sc.getCode().intValue(), null);
                Logger.instance().log(Logger.ERROR, loggerPrefix, "TwICESubscriber.subscribeDirect", fault.toString());
            } catch (Exception e) {
                Logger.instance().log(Logger.ERROR, loggerPrefix, "TwICESubscriber.subscribeDirect", e);
            }
        }
        return;
    }
----------------------------------------
    public void subscribeFull(Collection wanted) {
        if (subscriptions == null) {
            subscriptions = new ArrayList();
        }
        if (wanted.isEmpty()) {
            return;
        }
        Iterator it = wanted.iterator();
        while (it.hasNext()) {
            try {
                Subscribe subscribeReq = new Subscribe();
                OfferType offer = (OfferType) it.next();
                subscribeReq.setOffer(offer);
                Logger.instance().log(Logger.DEBUG, loggerPrefix, "TwICESubscriber.subscribeFull", "subscribing to offer id " + offer.getOfferId());
                TwICEUtil.setRequestHeader((Stub) syndicator, createIceHeader(null));
                SubscriptionType subscription = syndicator.subscribe(subscribeReq);
                Logger.instance().log(Logger.DEBUG, loggerPrefix, "TwICESubscriber.subscribeFull", "subscribed successfully to offer id " + offer.getOfferId());
                subscriptions.add(subscription);
                store();
            } catch (StatusCode sc) {
                IceFault fault = new IceFault(sc.getCode().intValue(), null);
                Logger.instance().log(Logger.ERROR, loggerPrefix, "TwICESubscriber.subscribeFull", fault.toString());
            } catch (Exception e) {
                Logger.instance().log(Logger.ERROR, loggerPrefix, "TwICESubscriber.subscribeFull", e);
            }
        }
        return;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53491.java,384,412
default,10598.java,384,412
----------------------------------------
    public void serveUDP(short port) {
        try {
            DatagramSocket sock = new DatagramSocket(port);
            while (true) {
                short udpLength = 512;
                DatagramPacket dp = new DatagramPacket(new byte[512], 512);
                try {
                    sock.receive(dp);
                } catch (InterruptedIOException e) {
                    continue;
                }
                byte[] in = new byte[dp.getLength()];
                System.arraycopy(dp.getData(), 0, in, 0, in.length);
                Message query, response;
                try {
                    query = new Message(in);
                    response = generateReply(query, in, null);
                    if (response == null) continue;
                } catch (IOException e) {
                    response = formerrMessage(in);
                }
                byte[] out = response.toWire();
                dp = new DatagramPacket(out, out.length, dp.getAddress(), dp.getPort());
                sock.send(dp);
            }
        } catch (IOException e) {
            System.out.println("serveUDP: " + e);
        }
    }
----------------------------------------
    public void serveUDP(short port) {
        try {
            DatagramSocket sock = new DatagramSocket(port);
            while (true) {
                short udpLength = 512;
                DatagramPacket dp = new DatagramPacket(new byte[512], 512);
                try {
                    sock.receive(dp);
                } catch (InterruptedIOException e) {
                    continue;
                }
                byte[] in = new byte[dp.getLength()];
                System.arraycopy(dp.getData(), 0, in, 0, in.length);
                Message query, response;
                try {
                    query = new Message(in);
                    response = generateReply(query, in, null);
                    if (response == null) continue;
                } catch (IOException e) {
                    response = formerrMessage(in);
                }
                byte[] out = response.toWire();
                dp = new DatagramPacket(out, out.length, dp.getAddress(), dp.getPort());
                sock.send(dp);
            }
        } catch (IOException e) {
            System.out.println("serveUDP: " + e);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2429982.java,1147,1175
selected,1944537.java,858,881
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (suspendEncoding) {
                super.out.write(theByte);
                return;
            }
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(encode3to4(b4, buffer, bufferLength, options));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    }
                } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
        public void write(int theByte) throws java.io.IOException {
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) {
                    out.write(Base64.encode3to4(buffer, bufferLength));
                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    }
                    position = 0;
                }
            } else {
                if (DECODABET[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) {
                        out.write(Base64.decode4to3(buffer));
                        position = 0;
                    }
                } else if (DECODABET[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException("Invalid character in Base64 data.");
                }
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122366.java,868,893
default,11822.java,868,893
----------------------------------------
    void processCondRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing argument in IF");
        String arg = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing operation in IF");
        String op = pst.nextToken();
        String[] value = new String[pst.countTokens()];
        for (int i = 0; i < value.length; i++) value[i] = pst.nextToken();
        if (DEBUG) System.out.println("doing conditional " + arg + " " + op + " " + value[0]);
        Vector newRegion = (Vector) region.elementAt(1);
        if (!evaluateConditional(arg, op, value)) {
            if (region.size() > 2) newRegion = (Vector) region.elementAt(2); else newRegion = new Vector();
            if (DEBUG) System.out.println("condition is false");
        } else {
            if (DEBUG) System.out.println("condition is true");
        }
        for (int j = 0; j < newRegion.size(); j++) {
            try {
                String currentLine = (String) newRegion.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) newRegion.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
    }
----------------------------------------
    void processCondRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing argument in IF");
        String arg = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing operation in IF");
        String op = pst.nextToken();
        String[] value = new String[pst.countTokens()];
        for (int i = 0; i < value.length; i++) value[i] = pst.nextToken();
        if (DEBUG) System.out.println("doing conditional " + arg + " " + op + " " + value[0]);
        Vector newRegion = (Vector) region.elementAt(1);
        if (!evaluateConditional(arg, op, value)) {
            if (region.size() > 2) newRegion = (Vector) region.elementAt(2); else newRegion = new Vector();
            if (DEBUG) System.out.println("condition is false");
        } else {
            if (DEBUG) System.out.println("condition is true");
        }
        for (int j = 0; j < newRegion.size(); j++) {
            try {
                String currentLine = (String) newRegion.elementAt(j);
                out.print(currentLine + "\n");
            } catch (ClassCastException e) {
                Vector tmpRegion = (Vector) newRegion.elementAt(j);
                processTemplateRegion(tmpRegion);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2180542.java,1057,1083
selected,2334770.java,1236,1262
----------------------------------------
        public int read(byte[] b, int off, int len) throws IOException {
            if (b == null) {
                throw new NullPointerException();
            } else if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)) {
                throw new IndexOutOfBoundsException();
            } else if (len == 0) {
                return 0;
            }
            if (rangePosition >= range[range.length - 2] + range[range.length - 1]) {
                return -1;
            }
            for (int k = 0; k < range.length; k += 2) {
                int start = range[k];
                int end = start + range[k + 1];
                if (rangePosition < start) rangePosition = start;
                if (rangePosition >= start && rangePosition < end) {
                    int lenf = Math.min(len, end - rangePosition);
                    if (raf == null) System.arraycopy(bout, rangePosition, b, off, lenf); else {
                        raf.seek(rangePosition);
                        raf.readFully(b, off, lenf);
                    }
                    rangePosition += lenf;
                    return lenf;
                }
            }
            return -1;
        }
----------------------------------------
        public int read(byte[] b, int off, int len) throws IOException {
            if (b == null) {
                throw new NullPointerException();
            } else if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)) {
                throw new IndexOutOfBoundsException();
            } else if (len == 0) {
                return 0;
            }
            if (rangePosition >= range[range.length - 2] + range[range.length - 1]) {
                return -1;
            }
            for (int k = 0; k < range.length; k += 2) {
                int start = range[k];
                int end = start + range[k + 1];
                if (rangePosition < start) rangePosition = start;
                if (rangePosition >= start && rangePosition < end) {
                    int lenf = Math.min(len, end - rangePosition);
                    if (raf == null) System.arraycopy(bout, rangePosition, b, off, lenf); else {
                        raf.seek(rangePosition);
                        raf.readFully(b, off, lenf);
                    }
                    rangePosition += lenf;
                    return lenf;
                }
            }
            return -1;
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,36821.java,557,585
default,75028.java,343,371
----------------------------------------
    protected Plugs getPlugs(Element plugsElem) {
        if (plugsElem != null && plugsElem.getName().equals("AdapterDeclaration")) {
            List content = plugsElem.getChildren();
            int size = content.size();
            if (size > 0) {
                Hashtable<String, AdapterDeclaration> hashTable = new Hashtable<String, AdapterDeclaration>(size);
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    AdapterDeclaration adapterDeclaration = getAdapterDeclaration(currentElement);
                    hashTable.put(adapterDeclaration.getName(), adapterDeclaration);
                }
                Plugs plugs = new Plugs(hashTable);
                return plugs;
            } else {
                System.err.println("Invalid child element size in getPlugs()");
                if (this.console != null) {
                    console.setText("Invalid child element size in getPlugs()");
                }
                return null;
            }
        } else {
            System.err.println("Invalid element input in getPlugs()");
            if (this.console != null) {
                console.setText("Invalid element input in getPlugs()");
            }
            return null;
        }
    }
----------------------------------------
    protected FBEventInputs getEventInputs(Element eventInputsElem) {
        if (eventInputsElem != null && eventInputsElem.getName().equals("EventInputs")) {
            List content = eventInputsElem.getChildren();
            int size = content.size();
            if (size > 0) {
                Hashtable<String, FBEvent> hashTable = new Hashtable<String, FBEvent>(size);
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    FBEvent event = getEvent(currentElement);
                    hashTable.put(event.getName(), event);
                }
                FBEventInputs eventInputs = new FBEventInputs(hashTable);
                return eventInputs;
            } else {
                System.err.println("Invalid child element size in getEventInputs()");
                if (this.console != null) {
                    console.setText("Invalid child element size in getEventInputs()");
                }
                return null;
            }
        } else {
            System.err.println("Invalid element input in getEventInputs()");
            if (this.console != null) {
                console.setText("Invalid element input in getEventInputs()");
            }
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109329.java,1041,1069
default,75028.java,1041,1069
----------------------------------------
    protected AdapterConnections getAdapterConnections(Element adapterConnectionsElem) {
        if (adapterConnectionsElem != null && adapterConnectionsElem.getName().equals("AdapterConnections")) {
            List content = adapterConnectionsElem.getChildren();
            int size = content.size();
            if (size > 0) {
                Hashtable<String, Connection> hashTable = new Hashtable<String, Connection>(size);
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    Connection connection = getConnection(currentElement);
                    hashTable.put(connection.getSource() + connection.getDestination(), connection);
                }
                AdapterConnections adapterConnections = new AdapterConnections(hashTable);
                return adapterConnections;
            } else {
                System.err.println("Invalid child element size in getAdapterConnections()");
                if (this.console != null) {
                    console.setText("Invalid child element size in getAdapterConnections()");
                }
                return null;
            }
        } else {
            System.err.println("Invalid element input in getAdapterConnections()");
            if (this.console != null) {
                console.setText("Invalid element input in getAdapterConnections()");
            }
            return null;
        }
    }
----------------------------------------
    protected AdapterConnections getAdapterConnections(Element adapterConnectionsElem) {
        if (adapterConnectionsElem != null && adapterConnectionsElem.getName().equals("AdapterConnections")) {
            List content = adapterConnectionsElem.getChildren();
            int size = content.size();
            if (size > 0) {
                Hashtable<String, Connection> hashTable = new Hashtable<String, Connection>(size);
                Iterator iterator = content.iterator();
                while (iterator.hasNext()) {
                    Element currentElement = (Element) iterator.next();
                    Connection connection = getConnection(currentElement);
                    hashTable.put(connection.getSource() + connection.getDestination(), connection);
                }
                AdapterConnections adapterConnections = new AdapterConnections(hashTable);
                return adapterConnections;
            } else {
                System.err.println("Invalid child element size in getAdapterConnections()");
                if (this.console != null) {
                    console.setText("Invalid child element size in getAdapterConnections()");
                }
                return null;
            }
        } else {
            System.err.println("Invalid element input in getAdapterConnections()");
            if (this.console != null) {
                console.setText("Invalid element input in getAdapterConnections()");
            }
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,82554.java,770,795
default,62165.java,770,795
----------------------------------------
    void processJoinRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing var name in JOIN");
        String var_name = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing separators in JOIN");
        String sep = pst.nextToken();
        int numValues = pst.countTokens();
        String value = "";
        if (pst.hasMoreTokens()) {
            value = pst.nextToken();
            for (int i = 1; i < numValues; i++) value += sep + pst.nextToken();
        }
        if (DEBUG) System.out.println("doing join with varname " + var_name + " and value=\"" + value + "\"");
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                String result = substitute(currentLine, var_name, value);
                out.print(result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt(j);
                Vector newRegion = substituteInRegion(oldRegion, var_name, value);
                processTemplateRegion(newRegion);
            }
        }
    }
----------------------------------------
    void processJoinRegion(Vector region) throws IOException {
        if (DEBUG) System.out.println("params=\"" + params + "\"");
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing var name in JOIN");
        String var_name = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing separators in JOIN");
        String sep = pst.nextToken();
        int numValues = pst.countTokens();
        String value = "";
        if (pst.hasMoreTokens()) {
            value = pst.nextToken();
            for (int i = 1; i < numValues; i++) value += sep + pst.nextToken();
        }
        if (DEBUG) System.out.println("doing join with varname " + var_name + " and value=\"" + value + "\"");
        for (int j = 1; j < region.size(); j++) {
            try {
                String currentLine = (String) region.elementAt(j);
                String result = substitute(currentLine, var_name, value);
                out.print(result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt(j);
                Vector newRegion = substituteInRegion(oldRegion, var_name, value);
                processTemplateRegion(newRegion);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1352239.java,145,172
selected,1281364.java,827,853
----------------------------------------
    public static String replaceIgnoreCase(String line, String oldString, String newString, int[] count) {
        if (line == null) {
            return null;
        }
        String lcLine = line.toLowerCase();
        String lcOldString = oldString.toLowerCase();
        int i = 0;
        if ((i = lcLine.indexOf(lcOldString, i)) >= 0) {
            int counter = 1;
            char[] line2 = line.toCharArray();
            char[] newString2 = newString.toCharArray();
            int oLength = oldString.length();
            StringBuffer buf = new StringBuffer(line2.length);
            buf.append(line2, 0, i).append(newString2);
            i += oLength;
            int j = i;
            while ((i = lcLine.indexOf(lcOldString, i)) > 0) {
                counter++;
                buf.append(line2, j, i - j).append(newString2);
                i += oLength;
                j = i;
            }
            buf.append(line2, j, line2.length - j);
            count[0] = counter;
            return buf.toString();
        }
        return line;
    }
----------------------------------------
    public static final String replace(final String line, final String oldString, final String newString, final int[] count) {
        if (line == null) {
            return null;
        }
        int i = 0;
        if ((i = line.indexOf(oldString, i)) >= 0) {
            int counter = 0;
            counter++;
            final char[] line2 = line.toCharArray();
            final char[] newString2 = newString.toCharArray();
            final int oLength = oldString.length();
            final StringBuffer buf = new StringBuffer(line2.length);
            buf.append(line2, 0, i).append(newString2);
            i += oLength;
            int j = i;
            while ((i = line.indexOf(oldString, i)) > 0) {
                counter++;
                buf.append(line2, j, i - j).append(newString2);
                i += oLength;
                j = i;
            }
            buf.append(line2, j, line2.length - j);
            count[0] = counter;
            return buf.toString();
        }
        return line;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1687011.java,1542,1569
selected,1216117.java,1530,1557
----------------------------------------
    public void visitAssignop(JCAssignOp tree) {
        OperatorSymbol operator = (OperatorSymbol) tree.operator;
        Item l;
        if (operator.opcode == string_add) {
            makeStringBuffer(tree.pos());
            l = genExpr(tree.lhs, tree.lhs.type);
            if (l.width() > 0) {
                code.emitop0(dup_x1 + 3 * (l.width() - 1));
            }
            l.load();
            appendString(tree.lhs);
            appendStrings(tree.rhs);
            bufferToString(tree.pos());
        } else {
            l = genExpr(tree.lhs, tree.lhs.type);
            if ((tree.getTag() == JCTree.PLUS_ASG || tree.getTag() == JCTree.MINUS_ASG) && l instanceof LocalItem && tree.lhs.type.tag <= INT && tree.rhs.type.tag <= INT && tree.rhs.type.constValue() != null) {
                int ival = ((Number) tree.rhs.type.constValue()).intValue();
                if (tree.getTag() == JCTree.MINUS_ASG) ival = -ival;
                ((LocalItem) l).incr(ival);
                result = l;
                return;
            }
            l.duplicate();
            l.coerce(operator.type.getParameterTypes().head).load();
            completeBinop(tree.lhs, tree.rhs, operator).coerce(tree.lhs.type);
        }
        result = items.makeAssignItem(l);
    }
----------------------------------------
    public void visitAssignop(JCAssignOp tree) {
        OperatorSymbol operator = (OperatorSymbol) tree.operator;
        Item l;
        if (operator.opcode == string_add) {
            makeStringBuffer(tree.pos());
            l = genExpr(tree.lhs, tree.lhs.type);
            if (l.width() > 0) {
                code.emitop0(dup_x1 + 3 * (l.width() - 1));
            }
            l.load();
            appendString(tree.lhs);
            appendStrings(tree.rhs);
            bufferToString(tree.pos());
        } else {
            l = genExpr(tree.lhs, tree.lhs.type);
            if ((tree.getTag() == JCTree.PLUS_ASG || tree.getTag() == JCTree.MINUS_ASG) && l instanceof LocalItem && tree.lhs.type.tag <= INT && tree.rhs.type.tag <= INT && tree.rhs.type.constValue() != null) {
                int ival = ((Number) tree.rhs.type.constValue()).intValue();
                if (tree.getTag() == JCTree.MINUS_ASG) ival = -ival;
                ((LocalItem) l).incr(ival);
                result = l;
                return;
            }
            l.duplicate();
            l.coerce(operator.type.getParameterTypes().head).load();
            completeBinop(tree.lhs, tree.rhs, operator).coerce(tree.lhs.type);
        }
        result = items.makeAssignItem(l);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28942.java,774,801
default,28942.java,774,801
----------------------------------------
    public void doShortFrame(String command, String[] args) {
        int from, to;
        try {
            switch(args.length) {
                case 0:
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(0, 20));
                    break;
                case 1:
                    if (args[0].length() == 8) {
                        int fp = parseHex32(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(fp));
                    } else {
                        from = Integer.parseInt(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(from, from));
                    }
                    break;
                case 2:
                    from = Integer.parseInt(args[0]);
                    to = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(from, to));
                    break;
                default:
                    printHelp(command);
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("bad stack frame numbers (decimal) or frame pointer value (hex)");
        }
    }
----------------------------------------
    public void doShortFrame(String command, String[] args) {
        int from, to;
        try {
            switch(args.length) {
                case 0:
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(0, 20));
                    break;
                case 1:
                    if (args[0].length() == 8) {
                        int fp = parseHex32(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(fp));
                    } else {
                        from = Integer.parseInt(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(from, from));
                    }
                    break;
                case 2:
                    from = Integer.parseInt(args[0]);
                    to = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(from, to));
                    break;
                default:
                    printHelp(command);
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("bad stack frame numbers (decimal) or frame pointer value (hex)");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40635.java,774,801
default,113905.java,763,790
----------------------------------------
    public void doShortFrame(String command, String[] args) {
        int from, to;
        try {
            switch(args.length) {
                case 0:
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(0, 20));
                    break;
                case 1:
                    if (args[0].length() == 8) {
                        int fp = parseHex32(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(fp));
                    } else {
                        from = Integer.parseInt(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(from, from));
                    }
                    break;
                case 2:
                    from = Integer.parseInt(args[0]);
                    to = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(from, to));
                    break;
                default:
                    printHelp(command);
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("bad stack frame numbers (decimal) or frame pointer value (hex)");
        }
    }
----------------------------------------
    public void doShortFrame(String command, String[] args) {
        int from, to;
        try {
            switch(args.length) {
                case 0:
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(0, 20));
                    break;
                case 1:
                    if (args[0].startsWith("0x") || args[0].startsWith("0X") || args[0].length() == 8) {
                        int fp = parseHex32(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(fp));
                    } else {
                        from = Integer.parseInt(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(from, from));
                    }
                    break;
                case 2:
                    from = Integer.parseInt(args[0]);
                    to = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(from, to));
                    break;
                default:
                    printHelp(command);
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("bad stack frame numbers (decimal) or frame pointer value (hex)");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88262.java,1304,1331
default,90813.java,1278,1303
----------------------------------------
    public void doThread(String command, String[] args) {
        int threadID, threadPointer;
        try {
            switch(args.length) {
                case 0:
                    threadID = user.reg.getContextThreadID();
                    if (threadID != 0) jdp_console.writeOutput("context had been set to thread: " + threadID);
                    threadID = user.reg.registerToTPIndex(user.reg.hardwareTP());
                    jdp_console.writeOutput("setting context to executing thread: " + threadID);
                    user.reg.setContextThreadID(threadID);
                    break;
                case 1:
                    if (args[0].equalsIgnoreCase("off")) {
                        user.reg.setContextThreadID(0);
                    } else {
                        threadID = Integer.parseInt(args[0]);
                        user.reg.setContextThreadID(threadID);
                    }
                    break;
                default:
                    printHelp(command);
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("invalid thread ID");
        } catch (Exception e1) {
            jdp_console.writeOutput(e1.getMessage());
        }
    }
----------------------------------------
    public void doThread(String command, String[] args) {
        int threadID, threadPointer;
        try {
            switch(args.length) {
                case 0:
                    threadID = user.reg.threadPointerToIndex(user.reg.hardwareTP());
                    jdp_console.writeOutput("context of executing thread: " + threadID);
                    user.reg.setContextThreadID(threadID);
                    break;
                case 1:
                    if (args[0].equalsIgnoreCase("off")) {
                        user.reg.setContextThreadID(0);
                    } else {
                        threadID = Integer.parseInt(args[0]);
                        user.reg.setContextThreadID(threadID);
                    }
                    break;
                default:
                    printHelp(command);
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("invalid thread ID");
        } catch (Exception e1) {
            jdp_console.writeOutput(e1.getMessage());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,120042.java,556,583
default,9256.java,682,709
----------------------------------------
    private boolean initFilter() {
        boolean ret = false;
        if (hInfo.getFilterFile().length() > 0) {
            try {
                DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
                docFactory.setValidating(false);
                docFactory.setNamespaceAware(false);
                DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
                xmlFilter = docBuilder.parse(new File(hInfo.getFilterFile()));
                docFactory = null;
                docBuilder = null;
                ret = true;
            } catch (IllegalArgumentException iae) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getFilterFile() + " is not valid. Reason: " + iae.getMessage());
            } catch (IOException ie) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getFilterFile() + "is not valid. Reason: " + ie.getMessage());
            } catch (SAXException se) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getFilterFile() + "is not valid. Reason: " + se.getMessage());
            } catch (FactoryConfigurationError fce) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getFilterFile() + "is not valid. Reason: " + fce.getMessage());
            } catch (ParserConfigurationException pce) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getFilterFile() + "is not valid. Reason: " + pce.getMessage());
            }
        } else {
            ret = true;
        }
        return ret;
    }
----------------------------------------
    private boolean initNormalize() {
        boolean ret = false;
        if (hInfo.getNormalizeFile().length() > 0) {
            try {
                DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
                docFactory.setValidating(false);
                docFactory.setNamespaceAware(false);
                DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
                xmlNormalize = docBuilder.parse(new File(hInfo.getNormalizeFile()));
                docFactory = null;
                docBuilder = null;
                ret = true;
            } catch (IllegalArgumentException iae) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getNormalizeFile() + " is not valid. Reason: " + iae.getMessage());
            } catch (IOException ie) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getNormalizeFile() + "is not valid. Reason: " + ie.getMessage());
            } catch (SAXException se) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getNormalizeFile() + "is not valid. Reason: " + se.getMessage());
            } catch (FactoryConfigurationError fce) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getNormalizeFile() + "is not valid. Reason: " + fce.getMessage());
            } catch (ParserConfigurationException pce) {
                writeHistory(STATUS_FAILED, "The " + hInfo.getNormalizeFile() + "is not valid. Reason: " + pce.getMessage());
            }
        } else {
            ret = true;
        }
        return ret;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132935.java,149,170
default,85252.java,120,147
----------------------------------------
    private void inlineMakeObject(String rType, String rTypeObject) {
        _insert("\n");
        if (!rType.equals(rTypeObject)) {
            _insert("    ");
            _insert(rTypeObject);
            _insert(" object_");
            _insert(rType);
            _insert(" = new ");
            _insert(rTypeObject);
            _insert("( value_");
            _insert(rType);
            _insert(" );\n");
        } else {
            _insert("    ");
            _insert(rTypeObject);
            _insert(" object_");
            _insert(rType);
            _insert(" = value_");
            _insert(rType);
            _insert(";\n");
        }
    }
----------------------------------------
    private void inlineObjectValue(String rType, String rTypeObject) {
        _insert("\n    ");
        _insert(rTypeObject);
        _insert(" object_");
        _insert(rType);
        _insert(" = (");
        _insert(rTypeObject);
        _insert(") object;\n");
        if (!rType.equals(rTypeObject)) {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(".");
            _insert(rType);
            _insert("Value();\n");
        } else {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(";\n");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132935.java,149,170
default,118575.java,120,147
----------------------------------------
    private void inlineMakeObject(String rType, String rTypeObject) {
        _insert("\n");
        if (!rType.equals(rTypeObject)) {
            _insert("    ");
            _insert(rTypeObject);
            _insert(" object_");
            _insert(rType);
            _insert(" = new ");
            _insert(rTypeObject);
            _insert("( value_");
            _insert(rType);
            _insert(" );\n");
        } else {
            _insert("    ");
            _insert(rTypeObject);
            _insert(" object_");
            _insert(rType);
            _insert(" = value_");
            _insert(rType);
            _insert(";\n");
        }
    }
----------------------------------------
    private void inlineObjectValue(String rType, String rTypeObject) {
        _insert("\n    ");
        _insert(rTypeObject);
        _insert(" object_");
        _insert(rType);
        _insert(" = (");
        _insert(rTypeObject);
        _insert(") object;\n");
        if (!rType.equals(rTypeObject)) {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(".");
            _insert(rType);
            _insert("Value();\n");
        } else {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(";\n");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40635.java,738,765
default,113905.java,763,790
----------------------------------------
    public void doFullFrame(String command, String[] args) {
        int from, to;
        try {
            switch(args.length) {
                case 0:
                    jdp_console.writeOutput(user.mem.printJVMstackTraceFull(0, 20));
                    break;
                case 1:
                    if (args[0].length() == 8) {
                        int fp = parseHex32(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTraceFull(fp));
                    } else {
                        from = Integer.parseInt(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTraceFull(from, from));
                    }
                    break;
                case 2:
                    from = Integer.parseInt(args[0]);
                    to = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.printJVMstackTraceFull(from, to));
                    break;
                default:
                    printHelp(command);
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("bad stack frame numbers (decimal) or frame pointer value (hex)");
        }
    }
----------------------------------------
    public void doShortFrame(String command, String[] args) {
        int from, to;
        try {
            switch(args.length) {
                case 0:
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(0, 20));
                    break;
                case 1:
                    if (args[0].startsWith("0x") || args[0].startsWith("0X") || args[0].length() == 8) {
                        int fp = parseHex32(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(fp));
                    } else {
                        from = Integer.parseInt(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstackTrace(from, from));
                    }
                    break;
                case 2:
                    from = Integer.parseInt(args[0]);
                    to = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.printJVMstackTrace(from, to));
                    break;
                default:
                    printHelp(command);
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput("bad stack frame numbers (decimal) or frame pointer value (hex)");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1931054.java,874,900
selected,927691.java,754,780
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1325210.java,488,514
selected,1325210.java,417,443
----------------------------------------
    public static int copyChars(int limit, Reader in, Writer out, int bufSize) throws IOException {
        if (limit == -1) {
            copyChars(in, out, bufSize);
            return -1;
        }
        if (limit < 0) {
            throw new IllegalArgumentException("Error limit:" + limit);
        }
        if (limit == 0) {
            return 0;
        }
        bufSize = bufSize <= 0 ? DEFAULT_BUFSIZE : bufSize;
        char[] buf = new char[limit > bufSize ? bufSize : limit];
        int allCount = 0;
        int leftCount = limit;
        int readCount = in.read(buf);
        while (readCount > 0) {
            out.write(buf, 0, readCount);
            allCount += readCount;
            leftCount -= readCount;
            if (allCount >= limit) {
                break;
            }
            readCount = in.read(buf, 0, buf.length > leftCount ? leftCount : buf.length);
        }
        return allCount;
    }
----------------------------------------
    public static int copyStream(int limit, InputStream in, OutputStream out, int bufSize) throws IOException {
        if (limit == -1) {
            copyStream(in, out, bufSize);
            return -1;
        }
        if (limit < 0) {
            throw new IllegalArgumentException("Error limit:" + limit);
        }
        if (limit == 0) {
            return 0;
        }
        bufSize = bufSize <= 0 ? DEFAULT_BUFSIZE : bufSize;
        byte[] buf = new byte[limit > bufSize ? bufSize : limit];
        int allCount = 0;
        int leftCount = limit;
        int readCount = in.read(buf);
        while (readCount > 0) {
            out.write(buf, 0, readCount);
            allCount += readCount;
            leftCount -= readCount;
            if (allCount >= limit) {
                break;
            }
            readCount = in.read(buf, 0, buf.length > leftCount ? leftCount : buf.length);
        }
        return allCount;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,964253.java,771,797
selected,1561076.java,839,865
----------------------------------------
    public static byte[] decodeFromFile(String filename) {
        byte[] decodedData = null;
        Base64.InputStream bis = null;
        try {
            java.io.File file = new java.io.File(filename);
            byte[] buffer = null;
            int length = 0;
            int numBytes = 0;
            if (file.length() > Integer.MAX_VALUE) {
                System.err.println("File is too big for this convenience method (" + file.length() + " bytes).");
                return null;
            }
            buffer = new byte[(int) file.length()];
            bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);
            while ((numBytes = bis.read(buffer, length, 4096)) >= 0) length += numBytes;
            decodedData = new byte[length];
            System.arraycopy(buffer, 0, decodedData, 0, length);
        } catch (java.io.IOException e) {
            System.err.println("Error decoding from file " + filename);
        } finally {
            try {
                bis.close();
            } catch (Exception e) {
            }
        }
        return decodedData;
    }
----------------------------------------
    public static byte[] decodeFromFile(String filename) {
        byte[] decodedData = null;
        Base64.InputStream bis = null;
        try {
            java.io.File file = new java.io.File(filename);
            byte[] buffer = null;
            int length = 0;
            int numBytes = 0;
            if (file.length() > Integer.MAX_VALUE) {
                System.err.println("File is too big for this convenience method (" + file.length() + " bytes).");
                return null;
            }
            buffer = new byte[(int) file.length()];
            bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);
            while ((numBytes = bis.read(buffer, length, 4096)) >= 0) length += numBytes;
            decodedData = new byte[length];
            System.arraycopy(buffer, 0, decodedData, 0, length);
        } catch (java.io.IOException e) {
            System.err.println("Error decoding from file " + filename);
        } finally {
            try {
                bis.close();
            } catch (Exception e) {
            }
        }
        return decodedData;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,707943.java,873,899
selected,2430560.java,838,864
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2524607.java,419,443
selected,592501.java,353,379
----------------------------------------
    public static boolean copyFile(File fileIn, File fileOut, int bufsize) throws IOException {
        FileInputStream in = null;
        FileOutputStream out = null;
        boolean result = false;
        try {
            in = new FileInputStream(fileIn);
            out = new FileOutputStream(fileOut);
            copyPipe(in, out, bufsize);
            result = true;
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException ioex) {
                }
            }
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ioex) {
                }
            }
        }
        return result;
    }
----------------------------------------
    public static void writeFile(File file, InputStream stream) throws Exception {
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try {
            bis = new BufferedInputStream(stream);
            bos = new BufferedOutputStream(new FileOutputStream(file));
            byte[] buffer = new byte[1024];
            int read = -1;
            while ((read = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, read);
            }
            bos.flush();
        } finally {
            if (bis != null) {
                try {
                    bis.close();
                } catch (IOException e) {
                }
            }
            if (bos != null) {
                try {
                    bos.close();
                } catch (IOException e) {
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1483221.java,836,862
selected,244622.java,873,899
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,101935.java,612,638
default,128066.java,612,638
----------------------------------------
    private void zeroJ2NThreadCounts(int threadPointer) throws Exception {
        if (threadPointer == 0) return;
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NYieldCount");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NLockFailureCount");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NTotalYieldDuration");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NTotalLockDuration");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
    }
----------------------------------------
    private void zeroJ2NThreadCounts(int threadPointer) throws Exception {
        if (threadPointer == 0) return;
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NYieldCount");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NLockFailureCount");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NTotalYieldDuration");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NTotalLockDuration");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,101935.java,866,892
default,104653.java,886,912
----------------------------------------
    private String wakeupQueueToString(int queuePointer) {
        String result = "";
        int count = 0;
        int fieldOffset;
        int thisProxyPointer, thisThreadPointer;
        VM_Field field;
        try {
            field = bmap.findVMField("VM_ProxyWakeupQueue", "head");
            thisProxyPointer = mem.read(queuePointer + field.getOffset());
            while (thisProxyPointer != 0) {
                field = bmap.findVMField("VM_Proxy", "thread");
                thisThreadPointer = mem.read(thisProxyPointer + field.getOffset());
                if (thisThreadPointer != 0) {
                    result += "   " + threadToString(thisThreadPointer) + "\n";
                    count++;
                }
                field = bmap.findVMField("VM_Proxy", "wakeupNext");
                thisProxyPointer = mem.read(thisProxyPointer + field.getOffset());
            }
        } catch (BmapNotFoundException e) {
            return "ERROR: cannot find VM_ThreadQueue.head or tail, has VM_ThreadQueue been changed?";
        }
        String heading = "";
        heading += "  ID  VM_Thread   top stack frame\n";
        heading += "  -- -----------  -----------------\n";
        return "Threads in queue:  " + count + "\n" + heading + result;
    }
----------------------------------------
    private String wakeupQueueToString(int queuePointer) {
        String result = "";
        int count = 0;
        int fieldOffset;
        int thisProxyPointer, thisThreadPointer;
        VM_Field field;
        try {
            field = bmap.findVMField("VM_ProxyWakeupQueue", "head");
            thisProxyPointer = mem.read(queuePointer + field.getOffset());
            while (thisProxyPointer != 0) {
                field = bmap.findVMField("VM_Proxy", "thread");
                thisThreadPointer = mem.read(thisProxyPointer + field.getOffset());
                if (thisThreadPointer != 0) {
                    result += "   " + threadToString(thisThreadPointer) + "\n";
                    count++;
                }
                field = bmap.findVMField("VM_Proxy", "wakeupNext");
                thisProxyPointer = mem.read(thisProxyPointer + field.getOffset());
            }
        } catch (BmapNotFoundException e) {
            return "ERROR: cannot find VM_ThreadQueue.head or tail, has VM_ThreadQueue been changed?";
        }
        String heading = "";
        heading += "  ID  VM_Thread   top stack frame\n";
        heading += "  -- -----------  -----------------\n";
        return "Threads in queue:  " + count + "\n" + heading + result;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1607771.java,874,900
selected,364540.java,871,897
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1483221.java,836,862
selected,183804.java,788,814
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16883.java,889,915
selected,183804.java,788,814
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,127646.java,889,915
default,35737.java,956,982
----------------------------------------
    private String wakeupQueueToString(int queuePointer) {
        String result = "";
        int count = 0;
        int fieldOffset;
        int thisProxyPointer, thisThreadPointer;
        VM_Field field;
        try {
            field = bmap.findVMField("com.ibm.JikesRVM.VM_ProxyWakeupQueue", "head");
            thisProxyPointer = mem.read(queuePointer + field.getOffset());
            while (thisProxyPointer != 0) {
                field = bmap.findVMField("com.ibm.JikesRVM.VM_Proxy", "thread");
                thisThreadPointer = mem.read(thisProxyPointer + field.getOffset());
                if (thisThreadPointer != 0) {
                    result += "   " + threadToString(thisThreadPointer) + "\n";
                    count++;
                }
                field = bmap.findVMField("com.ibm.JikesRVM.VM_Proxy", "wakeupNext");
                thisProxyPointer = mem.read(thisProxyPointer + field.getOffset());
            }
        } catch (BmapNotFoundException e) {
            return "ERROR: cannot find VM_ThreadQueue.head or tail, has VM_ThreadQueue been changed?";
        }
        String heading = "";
        heading += "  ID  VM_Thread   top stack frame\n";
        heading += "  -- -----------  -----------------\n";
        return "Threads in queue:  " + count + "\n" + heading + result;
    }
----------------------------------------
    private String wakeupQueueToString(int queuePointer) {
        String result = "";
        int count = 0;
        int fieldOffset;
        int thisProxyPointer, thisThreadPointer;
        VM_Field field;
        try {
            field = bmap.findVMField("com.ibm.JikesRVM.VM_ProxyWakeupQueue", "head");
            thisProxyPointer = mem.read(queuePointer + field.getOffset());
            while (thisProxyPointer != 0) {
                field = bmap.findVMField("com.ibm.JikesRVM.VM_Proxy", "thread");
                thisThreadPointer = mem.read(thisProxyPointer + field.getOffset());
                if (thisThreadPointer != 0) {
                    result += "   " + threadToString(thisThreadPointer) + "\n";
                    count++;
                }
                field = bmap.findVMField("com.ibm.JikesRVM.VM_Proxy", "wakeupNext");
                thisProxyPointer = mem.read(thisProxyPointer + field.getOffset());
            }
        } catch (BmapNotFoundException e) {
            return "ERROR: cannot find VM_ThreadQueue.head or tail, has VM_ThreadQueue been changed?";
        }
        String heading = "";
        heading += "  ID  VM_Thread   top stack frame\n";
        heading += "  -- -----------  -----------------\n";
        return "Threads in queue:  " + count + "\n" + heading + result;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,964253.java,838,864
default,126904.java,836,862
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,964253.java,535,561
selected,2348309.java,452,478
----------------------------------------
    private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset, int options) {
        byte[] DECODABET = getDecodabet(options);
        if (source[srcOffset + 2] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);
            destination[destOffset] = (byte) (outBuff >>> 16);
            return 1;
        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);
            destination[destOffset] = (byte) (outBuff >>> 16);
            destination[destOffset + 1] = (byte) (outBuff >>> 8);
            return 2;
        } else {
            try {
                int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF));
                destination[destOffset] = (byte) (outBuff >> 16);
                destination[destOffset + 1] = (byte) (outBuff >> 8);
                destination[destOffset + 2] = (byte) (outBuff);
                return 3;
            } catch (Exception e) {
                System.out.println("" + source[srcOffset] + ": " + (DECODABET[source[srcOffset]]));
                System.out.println("" + source[srcOffset + 1] + ": " + (DECODABET[source[srcOffset + 1]]));
                System.out.println("" + source[srcOffset + 2] + ": " + (DECODABET[source[srcOffset + 2]]));
                System.out.println("" + source[srcOffset + 3] + ": " + (DECODABET[source[srcOffset + 3]]));
                return -1;
            }
        }
    }
----------------------------------------
    private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset, int options) {
        byte[] DECODABET = getDecodabet(options);
        if (source[srcOffset + 2] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);
            destination[destOffset] = (byte) (outBuff >>> 16);
            return 1;
        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);
            destination[destOffset] = (byte) (outBuff >>> 16);
            destination[destOffset + 1] = (byte) (outBuff >>> 8);
            return 2;
        } else {
            try {
                int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF));
                destination[destOffset] = (byte) (outBuff >> 16);
                destination[destOffset + 1] = (byte) (outBuff >> 8);
                destination[destOffset + 2] = (byte) (outBuff);
                return 3;
            } catch (Exception e) {
                System.out.println("" + source[srcOffset] + ": " + (DECODABET[source[srcOffset]]));
                System.out.println("" + source[srcOffset + 1] + ": " + (DECODABET[source[srcOffset + 1]]));
                System.out.println("" + source[srcOffset + 2] + ": " + (DECODABET[source[srcOffset + 2]]));
                System.out.println("" + source[srcOffset + 3] + ": " + (DECODABET[source[srcOffset + 3]]));
                return -1;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1802351.java,874,900
selected,2215261.java,838,864
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,753625.java,596,622
selected,1511595.java,676,702
----------------------------------------
    public static Object decodeToObject(String encodedObject) {
        byte[] objBytes = decode(encodedObject);
        java.io.ByteArrayInputStream bais = null;
        java.io.ObjectInputStream ois = null;
        Object obj = null;
        try {
            bais = new java.io.ByteArrayInputStream(objBytes);
            ois = new java.io.ObjectInputStream(bais);
            obj = ois.readObject();
        } catch (java.io.IOException e) {
            e.printStackTrace();
            obj = null;
        } catch (java.lang.ClassNotFoundException e) {
            e.printStackTrace();
            obj = null;
        } finally {
            try {
                bais.close();
            } catch (Exception e) {
            }
            try {
                ois.close();
            } catch (Exception e) {
            }
        }
        return obj;
    }
----------------------------------------
    public static Object decodeToObject(String encodedObject) {
        byte[] objBytes = decode(encodedObject);
        java.io.ByteArrayInputStream bais = null;
        java.io.ObjectInputStream ois = null;
        Object obj = null;
        try {
            bais = new java.io.ByteArrayInputStream(objBytes);
            ois = new java.io.ObjectInputStream(bais);
            obj = ois.readObject();
        } catch (java.io.IOException e) {
            e.printStackTrace();
            obj = null;
        } catch (java.lang.ClassNotFoundException e) {
            e.printStackTrace();
            obj = null;
        } finally {
            try {
                bais.close();
            } catch (Exception e) {
            }
            try {
                ois.close();
            } catch (Exception e) {
            }
        }
        return obj;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1511595.java,676,702
default,16883.java,695,721
----------------------------------------
    public static Object decodeToObject(String encodedObject) {
        byte[] objBytes = decode(encodedObject);
        java.io.ByteArrayInputStream bais = null;
        java.io.ObjectInputStream ois = null;
        Object obj = null;
        try {
            bais = new java.io.ByteArrayInputStream(objBytes);
            ois = new java.io.ObjectInputStream(bais);
            obj = ois.readObject();
        } catch (java.io.IOException e) {
            e.printStackTrace();
            obj = null;
        } catch (java.lang.ClassNotFoundException e) {
            e.printStackTrace();
            obj = null;
        } finally {
            try {
                bais.close();
            } catch (Exception e) {
            }
            try {
                ois.close();
            } catch (Exception e) {
            }
        }
        return obj;
    }
----------------------------------------
    public static Object decodeToObject(String encodedObject) {
        byte[] objBytes = decode(encodedObject);
        java.io.ByteArrayInputStream bais = null;
        java.io.ObjectInputStream ois = null;
        Object obj = null;
        try {
            bais = new java.io.ByteArrayInputStream(objBytes);
            ois = new java.io.ObjectInputStream(bais);
            obj = ois.readObject();
        } catch (java.io.IOException e) {
            e.printStackTrace();
            obj = null;
        } catch (java.lang.ClassNotFoundException e) {
            e.printStackTrace();
            obj = null;
        } finally {
            try {
                bais.close();
            } catch (Exception e) {
            }
            try {
                ois.close();
            } catch (Exception e) {
            }
        }
        return obj;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2512321.java,263,289
selected,114964.java,1034,1059
----------------------------------------
    private boolean _jspx_meth_c_005fif_005f0(PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.taglibs.standard.tag.rt.core.IfTag _jspx_th_c_005fif_005f0 = (org.apache.taglibs.standard.tag.rt.core.IfTag) _005fjspx_005ftagPool_005fc_005fif_0026_005ftest.get(org.apache.taglibs.standard.tag.rt.core.IfTag.class);
        _jspx_th_c_005fif_005f0.setPageContext(_jspx_page_context);
        _jspx_th_c_005fif_005f0.setParent(null);
        _jspx_th_c_005fif_005f0.setTest(((java.lang.Boolean) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${task eq 'view'}", java.lang.Boolean.class, (PageContext) _jspx_page_context, null, false)).booleanValue());
        int _jspx_eval_c_005fif_005f0 = _jspx_th_c_005fif_005f0.doStartTag();
        if (_jspx_eval_c_005fif_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            do {
                out.write('\r');
                out.write('\n');
                out.write('	');
                if (_jspx_meth_c_005fset_005f0(_jspx_th_c_005fif_005f0, _jspx_page_context)) return true;
                out.write('\r');
                out.write('\n');
                int evalDoAfterBody = _jspx_th_c_005fif_005f0.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
        }
        if (_jspx_th_c_005fif_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fc_005fif_0026_005ftest.reuse(_jspx_th_c_005fif_005f0);
            return true;
        }
        _005fjspx_005ftagPool_005fc_005fif_0026_005ftest.reuse(_jspx_th_c_005fif_005f0);
        return false;
    }
----------------------------------------
    private boolean _jspx_meth_c_005fif_005f8(javax.servlet.jsp.tagext.JspTag _jspx_th_c_005fwhen_005f3, PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.taglibs.standard.tag.rt.core.IfTag _jspx_th_c_005fif_005f8 = (org.apache.taglibs.standard.tag.rt.core.IfTag) _005fjspx_005ftagPool_005fc_005fif_0026_005ftest.get(org.apache.taglibs.standard.tag.rt.core.IfTag.class);
        _jspx_th_c_005fif_005f8.setPageContext(_jspx_page_context);
        _jspx_th_c_005fif_005f8.setParent((javax.servlet.jsp.tagext.Tag) _jspx_th_c_005fwhen_005f3);
        _jspx_th_c_005fif_005f8.setTest(((java.lang.Boolean) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${task eq 'create'}", java.lang.Boolean.class, (PageContext) _jspx_page_context, null, false)).booleanValue());
        int _jspx_eval_c_005fif_005f8 = _jspx_th_c_005fif_005f8.doStartTag();
        if (_jspx_eval_c_005fif_005f8 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            do {
                out.write("\r\n");
                out.write("\t<script type=\"text/javascript\">\r\n");
                out.write("\tnew LiveValidation('password').add(Validate.Presence);\r\n");
                out.write("\tnew LiveValidation('password2').add(Validate.Presence);\r\n");
                out.write("</script>\r\n");
                int evalDoAfterBody = _jspx_th_c_005fif_005f8.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
        }
        if (_jspx_th_c_005fif_005f8.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fc_005fif_0026_005ftest.reuse(_jspx_th_c_005fif_005f8);
            return true;
        }
        _005fjspx_005ftagPool_005fc_005fif_0026_005ftest.reuse(_jspx_th_c_005fif_005f8);
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2108660.java,959,985
selected,2554952.java,874,900
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,689476.java,246,271
selected,2348309.java,452,478
----------------------------------------
    public static final int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset) {
        if (source[srcOffset + 2] == EQUALS_SIGN) {
            int outbuf = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);
            destination[destOffset] = (byte) (outbuf >>> 16);
            return 1;
        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
            int outbuf = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);
            destination[destOffset] = (byte) (outbuf >>> 16);
            destination[destOffset + 1] = (byte) (outbuf >>> 8);
            return 2;
        } else {
            try {
                int outbuf = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF));
                destination[destOffset] = (byte) (outbuf >> 16);
                destination[destOffset + 1] = (byte) (outbuf >> 8);
                destination[destOffset + 2] = (byte) (outbuf);
                return 3;
            } catch (Exception e) {
                System.out.println("" + source[srcOffset] + ": " + (DECODABET[source[srcOffset]]));
                System.out.println("" + source[srcOffset + 1] + ": " + (DECODABET[source[srcOffset + 1]]));
                System.out.println("" + source[srcOffset + 2] + ": " + (DECODABET[source[srcOffset + 2]]));
                System.out.println("" + source[srcOffset + 3] + ": " + (DECODABET[source[srcOffset + 3]]));
                return -1;
            }
        }
    }
----------------------------------------
    private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset, int options) {
        byte[] DECODABET = getDecodabet(options);
        if (source[srcOffset + 2] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);
            destination[destOffset] = (byte) (outBuff >>> 16);
            return 1;
        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);
            destination[destOffset] = (byte) (outBuff >>> 16);
            destination[destOffset + 1] = (byte) (outBuff >>> 8);
            return 2;
        } else {
            try {
                int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF));
                destination[destOffset] = (byte) (outBuff >> 16);
                destination[destOffset + 1] = (byte) (outBuff >> 8);
                destination[destOffset + 2] = (byte) (outBuff);
                return 3;
            } catch (Exception e) {
                System.out.println("" + source[srcOffset] + ": " + (DECODABET[source[srcOffset]]));
                System.out.println("" + source[srcOffset + 1] + ": " + (DECODABET[source[srcOffset + 1]]));
                System.out.println("" + source[srcOffset + 2] + ": " + (DECODABET[source[srcOffset + 2]]));
                System.out.println("" + source[srcOffset + 3] + ": " + (DECODABET[source[srcOffset + 3]]));
                return -1;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,781670.java,838,863
selected,1802351.java,536,562
----------------------------------------
    private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset) {
        if (source[srcOffset + 2] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);
            destination[destOffset] = (byte) (outBuff >>> 16);
            return 1;
        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);
            destination[destOffset] = (byte) (outBuff >>> 16);
            destination[destOffset + 1] = (byte) (outBuff >>> 8);
            return 2;
        } else {
            try {
                int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF));
                destination[destOffset] = (byte) (outBuff >> 16);
                destination[destOffset + 1] = (byte) (outBuff >> 8);
                destination[destOffset + 2] = (byte) (outBuff);
                return 3;
            } catch (Exception e) {
                System.out.println("" + source[srcOffset] + ": " + (DECODABET[source[srcOffset]]));
                System.out.println("" + source[srcOffset + 1] + ": " + (DECODABET[source[srcOffset + 1]]));
                System.out.println("" + source[srcOffset + 2] + ": " + (DECODABET[source[srcOffset + 2]]));
                System.out.println("" + source[srcOffset + 3] + ": " + (DECODABET[source[srcOffset + 3]]));
                return -1;
            }
        }
    }
----------------------------------------
    private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset, int options) {
        byte[] DECODABET = getDecodabet(options);
        if (source[srcOffset + 2] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);
            destination[destOffset] = (byte) (outBuff >>> 16);
            return 1;
        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);
            destination[destOffset] = (byte) (outBuff >>> 16);
            destination[destOffset + 1] = (byte) (outBuff >>> 8);
            return 2;
        } else {
            try {
                int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF));
                destination[destOffset] = (byte) (outBuff >> 16);
                destination[destOffset + 1] = (byte) (outBuff >> 8);
                destination[destOffset + 2] = (byte) (outBuff);
                return 3;
            } catch (Exception e) {
                System.out.println("" + source[srcOffset] + ": " + (DECODABET[source[srcOffset]]));
                System.out.println("" + source[srcOffset + 1] + ": " + (DECODABET[source[srcOffset + 1]]));
                System.out.println("" + source[srcOffset + 2] + ": " + (DECODABET[source[srcOffset + 2]]));
                System.out.println("" + source[srcOffset + 3] + ": " + (DECODABET[source[srcOffset + 3]]));
                return -1;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1496807.java,781,807
selected,2626904.java,771,797
----------------------------------------
    public static byte[] decodeFromFile(String filename) {
        byte[] decodedData = null;
        Base64.InputStream bis = null;
        try {
            java.io.File file = new java.io.File(filename);
            byte[] buffer = null;
            int length = 0;
            int numBytes = 0;
            if (file.length() > Integer.MAX_VALUE) {
                System.err.println("File is too big for this convenience method (" + file.length() + " bytes).");
                return null;
            }
            buffer = new byte[(int) file.length()];
            bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);
            while ((numBytes = bis.read(buffer, length, 4096)) >= 0) length += numBytes;
            decodedData = new byte[length];
            System.arraycopy(buffer, 0, decodedData, 0, length);
        } catch (java.io.IOException e) {
            System.err.println("Error decoding from file " + filename);
        } finally {
            try {
                bis.close();
            } catch (Exception e) {
            }
        }
        return decodedData;
    }
----------------------------------------
    public static byte[] decodeFromFile(String filename) {
        byte[] decodedData = null;
        Base64.InputStream bis = null;
        try {
            java.io.File file = new java.io.File(filename);
            byte[] buffer = null;
            int length = 0;
            int numBytes = 0;
            if (file.length() > Integer.MAX_VALUE) {
                System.err.println("File is too big for this convenience method (" + file.length() + " bytes).");
                return null;
            }
            buffer = new byte[(int) file.length()];
            bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);
            while ((numBytes = bis.read(buffer, length, 4096)) >= 0) length += numBytes;
            decodedData = new byte[length];
            System.arraycopy(buffer, 0, decodedData, 0, length);
        } catch (java.io.IOException e) {
            System.err.println("Error decoding from file " + filename);
        } finally {
            try {
                bis.close();
            } catch (Exception e) {
            }
        }
        return decodedData;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1580182.java,143,167
selected,946507.java,105,130
----------------------------------------
    public void moveRowDown(int id, int row) throws FidoDatabaseException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                conn = fido.util.FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                int max = findMaxRank(stmt, id);
                if ((row < 1) || (row > (max - 1))) throw new IllegalArgumentException("Row number not between 1 and " + (max - 1));
                stmt.executeUpdate("update InstructionGroups set Rank = -1 where InstructionId = '" + id + "' and Rank = " + row);
                stmt.executeUpdate("update InstructionGroups set Rank = " + row + " where InstructionId = '" + id + "' and Rank = " + (row + 1));
                stmt.executeUpdate("update InstructionGroups set Rank = " + (row + 1) + " where InstructionId = '" + id + "' and Rank = -1");
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
----------------------------------------
    public void delete(String name, int row) throws FidoDatabaseException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                String sql = "delete from ProperNouns where Noun = '" + name + "' and SenseNumber = " + row;
                conn = fido.util.FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                int max = findMaxRank(stmt, name);
                stmt.executeUpdate(sql);
                for (int i = row; i < max; ++i) {
                    stmt.executeUpdate("update ProperNouns set SenseNumber = " + i + " where SenseNumber = " + (i + 1) + " and Noun = '" + name + "'");
                }
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,952493.java,1668,1694
selected,1323102.java,476,501
----------------------------------------
    private boolean _jspx_meth_c_005fotherwise_005f1(javax.servlet.jsp.tagext.JspTag _jspx_th_c_005fchoose_005f1, PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.taglibs.standard.tag.common.core.OtherwiseTag _jspx_th_c_005fotherwise_005f1 = (org.apache.taglibs.standard.tag.common.core.OtherwiseTag) _005fjspx_005ftagPool_005fc_005fotherwise.get(org.apache.taglibs.standard.tag.common.core.OtherwiseTag.class);
        _jspx_th_c_005fotherwise_005f1.setPageContext(_jspx_page_context);
        _jspx_th_c_005fotherwise_005f1.setParent((javax.servlet.jsp.tagext.Tag) _jspx_th_c_005fchoose_005f1);
        int _jspx_eval_c_005fotherwise_005f1 = _jspx_th_c_005fotherwise_005f1.doStartTag();
        if (_jspx_eval_c_005fotherwise_005f1 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            do {
                out.write("\n");
                out.write("                _$J(document).ready(\n");
                out.write("                    function() {\n");
                out.write("                            Liferay.Portlet.processLast();\n");
                out.write("                    }\n");
                out.write("                );\n");
                out.write("            ");
                int evalDoAfterBody = _jspx_th_c_005fotherwise_005f1.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
        }
        if (_jspx_th_c_005fotherwise_005f1.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fc_005fotherwise.reuse(_jspx_th_c_005fotherwise_005f1);
            return true;
        }
        _005fjspx_005ftagPool_005fc_005fotherwise.reuse(_jspx_th_c_005fotherwise_005f1);
        return false;
    }
----------------------------------------
    private boolean _jspx_meth_c_005fif_005f4(PageContext _jspx_page_context) throws Throwable {
        PageContext pageContext = _jspx_page_context;
        JspWriter out = _jspx_page_context.getOut();
        org.apache.taglibs.standard.tag.rt.core.IfTag _jspx_th_c_005fif_005f4 = (org.apache.taglibs.standard.tag.rt.core.IfTag) _005fjspx_005ftagPool_005fc_005fif_0026_005ftest.get(org.apache.taglibs.standard.tag.rt.core.IfTag.class);
        _jspx_th_c_005fif_005f4.setPageContext(_jspx_page_context);
        _jspx_th_c_005fif_005f4.setParent(null);
        _jspx_th_c_005fif_005f4.setTest(((java.lang.Boolean) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${user.userSwitch==1}", java.lang.Boolean.class, (PageContext) _jspx_page_context, null, false)).booleanValue());
        int _jspx_eval_c_005fif_005f4 = _jspx_th_c_005fif_005f4.doStartTag();
        if (_jspx_eval_c_005fif_005f4 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {
            do {
                out.write("\r\n");
                out.write("\t\t\t\t\t\t\t\t<input name=\"userSwitch\" type=\"radio\" value=\"1\" checked />是\r\n");
                out.write("\t\t\t\t\t\t\t\t<input name=\"userSwitch\" type=\"radio\" value=\"0\" />否\r\n");
                out.write("\t\t\t\t\t\t\t\r\n");
                out.write("\t\t\t\t\t\t\t");
                int evalDoAfterBody = _jspx_th_c_005fif_005f4.doAfterBody();
                if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break;
            } while (true);
        }
        if (_jspx_th_c_005fif_005f4.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {
            _005fjspx_005ftagPool_005fc_005fif_0026_005ftest.reuse(_jspx_th_c_005fif_005f4);
            return true;
        }
        _005fjspx_005ftagPool_005fc_005fif_0026_005ftest.reuse(_jspx_th_c_005fif_005f4);
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,979320.java,224,250
selected,1309332.java,196,215
----------------------------------------
    protected String readFileUsingHttp(String fileUrlName) {
        String response = "";
        try {
            URL url = new URL(fileUrlName);
            URLConnection connection = url.openConnection();
            HttpURLConnection httpConn = (HttpURLConnection) connection;
            httpConn.setRequestProperty("Content-Type", "text/html");
            httpConn.setRequestProperty("Content-Length", "0");
            httpConn.setRequestMethod("GET");
            httpConn.setDoOutput(true);
            httpConn.setDoInput(true);
            httpConn.setAllowUserInteraction(false);
            InputStreamReader isr = new InputStreamReader(httpConn.getInputStream());
            BufferedReader in = new BufferedReader(isr);
            String inputLine = "";
            while ((inputLine = in.readLine()) != null) {
                response += inputLine + "\n";
            }
            if (response.endsWith("\n")) {
                response = response.substring(0, response.length() - 1);
            }
            in.close();
        } catch (Exception x) {
            x.printStackTrace();
        }
        return response;
    }
----------------------------------------
    protected String readFileUsingFileUrl(String fileUrlName) {
        String response = "";
        try {
            URL url = new URL(fileUrlName);
            URLConnection connection = url.openConnection();
            InputStreamReader isr = new InputStreamReader(connection.getInputStream());
            BufferedReader in = new BufferedReader(isr);
            String inputLine = "";
            while ((inputLine = in.readLine()) != null) {
                response += inputLine + "\n";
            }
            if (response.endsWith("\n")) {
                response = response.substring(0, response.length() - 1);
            }
            in.close();
        } catch (Exception x) {
            x.printStackTrace();
        }
        return response;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2339370.java,603,629
default,126904.java,678,704
----------------------------------------
    public static Object decodeToObject(String encodedObject) {
        byte[] objBytes = decode(encodedObject);
        java.io.ByteArrayInputStream bais = null;
        java.io.ObjectInputStream ois = null;
        Object obj = null;
        try {
            bais = new java.io.ByteArrayInputStream(objBytes);
            ois = new java.io.ObjectInputStream(bais);
            obj = ois.readObject();
        } catch (java.io.IOException e) {
            e.printStackTrace();
            obj = null;
        } catch (java.lang.ClassNotFoundException e) {
            e.printStackTrace();
            obj = null;
        } finally {
            try {
                bais.close();
            } catch (Exception e) {
            }
            try {
                ois.close();
            } catch (Exception e) {
            }
        }
        return obj;
    }
----------------------------------------
    public static Object decodeToObject(String encodedObject) {
        byte[] objBytes = decode(encodedObject);
        java.io.ByteArrayInputStream bais = null;
        java.io.ObjectInputStream ois = null;
        Object obj = null;
        try {
            bais = new java.io.ByteArrayInputStream(objBytes);
            ois = new java.io.ObjectInputStream(bais);
            obj = ois.readObject();
        } catch (java.io.IOException e) {
            e.printStackTrace();
            obj = null;
        } catch (java.lang.ClassNotFoundException e) {
            e.printStackTrace();
            obj = null;
        } finally {
            try {
                bais.close();
            } catch (Exception e) {
            }
            try {
                ois.close();
            } catch (Exception e) {
            }
        }
        return obj;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,597475.java,838,864
selected,1560483.java,754,780
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2640664.java,789,815
selected,2365821.java,838,864
----------------------------------------
    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1561076.java,302,327
selected,2599719.java,268,293
----------------------------------------
    private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset, int options) {
        byte[] ALPHABET = getAlphabet(options);
        int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0) | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0) | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
        switch(numSigBytes) {
            case 3:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];
                return destination;
            case 2:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            case 1:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = EQUALS_SIGN;
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            default:
                return destination;
        }
    }
----------------------------------------
    private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset, int options) {
        byte[] ALPHABET = getAlphabet(options);
        int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0) | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0) | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
        switch(numSigBytes) {
            case 3:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];
                return destination;
            case 2:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            case 1:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = EQUALS_SIGN;
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            default:
                return destination;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,597475.java,268,293
selected,364540.java,268,293
----------------------------------------
    private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset, int options) {
        byte[] ALPHABET = getAlphabet(options);
        int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0) | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0) | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
        switch(numSigBytes) {
            case 3:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];
                return destination;
            case 2:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            case 1:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = EQUALS_SIGN;
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            default:
                return destination;
        }
    }
----------------------------------------
    private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset, int options) {
        byte[] ALPHABET = getAlphabet(options);
        int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0) | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0) | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
        switch(numSigBytes) {
            case 3:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];
                return destination;
            case 2:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            case 1:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = EQUALS_SIGN;
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            default:
                return destination;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,15508.java,683,708
default,6871.java,683,708
----------------------------------------
    private int evalExpr(StreamTokenizer st) throws IOException {
        int val = evalTerm(st);
        int token = st.nextToken();
        while (token == '+' || token == '-' || token == '|' || token == '^') {
            int t = evalTerm(st);
            switch(token) {
                case '+':
                    val += t;
                    break;
                case '-':
                    val -= t;
                    break;
                case '|':
                    val |= t;
                    break;
                case '^':
                    val ^= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
    private int evalExpr(StreamTokenizer st) throws IOException {
        int val = evalTerm(st);
        int token = st.nextToken();
        while (token == '+' || token == '-' || token == '|' || token == '^') {
            int t = evalTerm(st);
            switch(token) {
                case '+':
                    val += t;
                    break;
                case '-':
                    val -= t;
                    break;
                case '|':
                    val |= t;
                    break;
                case '^':
                    val ^= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,34614.java,815,840
default,52174.java,831,856
----------------------------------------
    public void doCurrentFrame(String command, String[] args) {
        try {
            int width, fp;
            switch(args.length) {
                case 0:
                    jdp_console.writeOutput(user.mem.printJVMstack(0, 4));
                    break;
                case 1:
                    if (args[0].length() == 8) {
                        fp = parseHex32(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstack(fp, 4));
                    } else {
                        width = Integer.parseInt(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstack(0, width));
                    }
                    break;
                case 2:
                    fp = parseHex32(args[0]);
                    width = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.printJVMstack(fp, width));
                    break;
            }
        } catch (NumberFormatException e) {
            printHelp(command);
        }
    }
----------------------------------------
    public void doCurrentFrame(String command, String[] args) {
        try {
            int width, fp;
            switch(args.length) {
                case 0:
                    jdp_console.writeOutput(user.mem.printJVMstack(0, 4));
                    break;
                case 1:
                    if (args[0].startsWith("0x") || args[0].startsWith("0X") || args[0].length() == 8) {
                        fp = parseHex32(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstack(fp, 4));
                    } else {
                        width = Integer.parseInt(args[0]);
                        jdp_console.writeOutput(user.mem.printJVMstack(0, width));
                    }
                    break;
                case 2:
                    fp = parseHex32(args[0]);
                    width = Integer.parseInt(args[1]);
                    jdp_console.writeOutput(user.mem.printJVMstack(fp, width));
                    break;
            }
        } catch (NumberFormatException e) {
            printHelp(command);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,122366.java,683,708
default,32260.java,656,681
----------------------------------------
    private int evalExpr(StreamTokenizer st) throws IOException {
        int val = evalTerm(st);
        int token = st.nextToken();
        while (token == '+' || token == '-' || token == '|' || token == '^') {
            int t = evalTerm(st);
            switch(token) {
                case '+':
                    val += t;
                    break;
                case '-':
                    val -= t;
                    break;
                case '|':
                    val |= t;
                    break;
                case '^':
                    val ^= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24353.java,683,708
default,10720.java,683,708
----------------------------------------
    private int evalExpr(StreamTokenizer st) throws IOException {
        int val = evalTerm(st);
        int token = st.nextToken();
        while (token == '+' || token == '-' || token == '|' || token == '^') {
            int t = evalTerm(st);
            switch(token) {
                case '+':
                    val += t;
                    break;
                case '-':
                    val -= t;
                    break;
                case '|':
                    val |= t;
                    break;
                case '^':
                    val ^= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
    private int evalExpr(StreamTokenizer st) throws IOException {
        int val = evalTerm(st);
        int token = st.nextToken();
        while (token == '+' || token == '-' || token == '|' || token == '^') {
            int t = evalTerm(st);
            switch(token) {
                case '+':
                    val += t;
                    break;
                case '-':
                    val -= t;
                    break;
                case '|':
                    val |= t;
                    break;
                case '^':
                    val ^= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2212150.java,76,101
selected,2212150.java,76,101
----------------------------------------
    public static OrbisStreamer play(URL url) throws IOException {
        InputStream in = url.openStream();
        OrbisStreamer streamer = new OrbisStreamer(in);
        try {
            synchronized (streamer) {
                streamer.start();
                streamer.wait(OPEN_TIMEOUT);
            }
        } catch (InterruptedException e) {
            throw new IOException("interrupted: " + e);
        }
        if (streamer.isRunning()) {
            return streamer;
        } else {
            if (streamer.failure instanceof IOException) {
                throw (IOException) streamer.failure;
            } else if (streamer.failure instanceof RuntimeException) {
                throw (RuntimeException) streamer.failure;
            } else if (streamer.failure instanceof Error) {
                throw (Error) streamer.failure;
            } else if (streamer.failure != null) {
                throw new IOException("unknown failure: " + streamer.failure);
            }
            return null;
        }
    }
----------------------------------------
    public static OrbisStreamer play(URL url) throws IOException {
        InputStream in = url.openStream();
        OrbisStreamer streamer = new OrbisStreamer(in);
        try {
            synchronized (streamer) {
                streamer.start();
                streamer.wait(OPEN_TIMEOUT);
            }
        } catch (InterruptedException e) {
            throw new IOException("interrupted: " + e);
        }
        if (streamer.isRunning()) {
            return streamer;
        } else {
            if (streamer.failure instanceof IOException) {
                throw (IOException) streamer.failure;
            } else if (streamer.failure instanceof RuntimeException) {
                throw (RuntimeException) streamer.failure;
            } else if (streamer.failure instanceof Error) {
                throw (Error) streamer.failure;
            } else if (streamer.failure != null) {
                throw new IOException("unknown failure: " + streamer.failure);
            }
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109831.java,656,681
default,82554.java,656,681
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,58510.java,637,662
default,2909.java,656,681
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
    private int evalTerm(StreamTokenizer st) throws IOException {
        int val = evalFactor(st);
        int token = st.nextToken();
        while (token == '*' || token == '/' || token == '%' || token == '&') {
            int t = evalFactor(st);
            switch(token) {
                case '*':
                    val *= t;
                    break;
                case '/':
                    val /= t;
                    break;
                case '%':
                    val %= t;
                    break;
                case '&':
                    val &= t;
                    break;
                default:
                    throw new IOException("Invalid token");
            }
            token = st.nextToken();
        }
        st.pushBack();
        return val;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,613232.java,36,61
selected,613000.java,32,51
----------------------------------------
    private static void insert(EntityManagerFactory entityManagerFactory) {
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        try {
            entityManager.getTransaction().begin();
            Person person = new Person();
            person.setFirstName("Jesse");
            person.setLastName("James");
            Address address1 = new Address();
            address1.setStreet("Main Road 12");
            address1.setCity("Oakwood");
            address1.setPerson(person);
            person.getAddresses().add(address1);
            Address address2 = new Address();
            address2.setStreet("Sunshine Boulevard 211");
            address2.setCity("Austin");
            address2.setPerson(person);
            person.getAddresses().add(address2);
            entityManager.persist(person);
            entityManager.getTransaction().commit();
        } finally {
            if (entityManager.getTransaction().isActive()) {
                entityManager.getTransaction().rollback();
            }
            entityManager.close();
        }
    }
----------------------------------------
    private static void insert(EntityManagerFactory entityManagerFactory) {
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        try {
            entityManager.getTransaction().begin();
            Person person = new Person();
            person.setFirstName("Jesse");
            person.setLastName("James");
            Address address = new Address();
            address.setStreet("Main Road 12");
            address.setCity("Oakwood");
            person.setAddress(address);
            entityManager.persist(person);
            entityManager.getTransaction().commit();
        } finally {
            if (entityManager.getTransaction().isActive()) {
                entityManager.getTransaction().rollback();
            }
            entityManager.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1095060.java,19,43
selected,2712277.java,19,43
----------------------------------------
    public org.omg.CORBA.portable.OutputStream _invoke(String opName, org.omg.CORBA.portable.InputStream in, org.omg.CORBA.portable.ResponseHandler handler) {
        final String[] _ob_names = { "connect_push_supplier", "disconnect_push_consumer", "get_typed_consumer", "push" };
        int _ob_left = 0;
        int _ob_right = _ob_names.length;
        int _ob_index = -1;
        while (_ob_left < _ob_right) {
            int _ob_m = (_ob_left + _ob_right) / 2;
            int _ob_res = _ob_names[_ob_m].compareTo(opName);
            if (_ob_res == 0) {
                _ob_index = _ob_m;
                break;
            } else if (_ob_res > 0) _ob_right = _ob_m; else _ob_left = _ob_m + 1;
        }
        switch(_ob_index) {
            case 0:
                return _OB_op_connect_push_supplier(in, handler);
            case 1:
                return _OB_op_disconnect_push_consumer(in, handler);
            case 2:
                return _OB_op_get_typed_consumer(in, handler);
            case 3:
                return _OB_op_push(in, handler);
        }
        throw new org.omg.CORBA.BAD_OPERATION();
    }
----------------------------------------
    public org.omg.CORBA.portable.OutputStream _invoke(String opName, org.omg.CORBA.portable.InputStream in, org.omg.CORBA.portable.ResponseHandler handler) {
        final String[] _ob_names = { "disconnect_push_consumer", "get_typed_consumer", "offer_change", "push" };
        int _ob_left = 0;
        int _ob_right = _ob_names.length;
        int _ob_index = -1;
        while (_ob_left < _ob_right) {
            int _ob_m = (_ob_left + _ob_right) / 2;
            int _ob_res = _ob_names[_ob_m].compareTo(opName);
            if (_ob_res == 0) {
                _ob_index = _ob_m;
                break;
            } else if (_ob_res > 0) _ob_right = _ob_m; else _ob_left = _ob_m + 1;
        }
        switch(_ob_index) {
            case 0:
                return _OB_op_disconnect_push_consumer(in, handler);
            case 1:
                return _OB_op_get_typed_consumer(in, handler);
            case 2:
                return _OB_op_offer_change(in, handler);
            case 3:
                return _OB_op_push(in, handler);
        }
        throw new org.omg.CORBA.BAD_OPERATION();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,127068.java,1711,1732
selected,849450.java,684,705
----------------------------------------
    public Matrix times(Matrix B) {
        if (B.m != n) {
            throw new IllegalArgumentException("Matrix inner dimensions must agree.");
        }
        Matrix X = new Matrix(m, B.n);
        double[][] C = X.getArray();
        double[] Bcolj = new double[n];
        for (int j = 0; j < B.n; j++) {
            for (int k = 0; k < n; k++) {
                Bcolj[k] = B.A[k][j];
            }
            for (int i = 0; i < m; i++) {
                double[] Arowi = A[i];
                double s = 0;
                for (int k = 0; k < n; k++) {
                    s += (Arowi[k] * Bcolj[k]);
                }
                C[i][j] = s;
            }
        }
        return X;
    }
----------------------------------------
    public Matrix times(Matrix B) {
        if (B.m != n) {
            throw new IllegalArgumentException("Matrix inner dimensions must agree.");
        }
        Matrix X = new Matrix(m, B.n);
        double[][] C = X.getArray();
        double[] Bcolj = new double[n];
        for (int j = 0; j < B.n; j++) {
            for (int k = 0; k < n; k++) {
                Bcolj[k] = B.A[k][j];
            }
            for (int i = 0; i < m; i++) {
                double[] Arowi = A[i];
                double s = 0;
                for (int k = 0; k < n; k++) {
                    s += Arowi[k] * Bcolj[k];
                }
                C[i][j] = s;
            }
        }
        return X;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,58926.java,142,166
default,66701.java,142,166
----------------------------------------
    public static CabinetFactory getRfsCabinetFactory(Agent agent) {
        Factory fileFactory = getFilingServiceFactory();
        try {
            java.util.Map props = new java.util.Hashtable();
            props.put(FSReadWrite, Boolean.TRUE);
            props.put(FSLocalAccess, Boolean.TRUE);
            props.put(FSRemoteAccess, Boolean.TRUE);
            if (USE_CACHING_FILESYSTEM) props.put(FSMetaCaching, Boolean.TRUE); else props.put(FSMetaCaching, Boolean.FALSE);
            CabinetFactory[] matches = fileFactory.getCabinetFactory(props);
            if (matches.length == 0 && USE_CACHING_FILESYSTEM) {
                if (verbose) outln("couldn't find factory that supports " + FSMetaCaching);
                props.remove(FSMetaCaching);
                matches = fileFactory.getCabinetFactory(props);
            }
            CabinetFactory rfsFactory = matches[0];
            Agent userAgent = getUserAgent();
            if (agent != null) userAgent.addProxy(agent);
            rfsFactory.setOwner(userAgent);
            if (verbose) outln("got RfsFactory [" + rfsFactory + "] that matched properties " + props);
            return rfsFactory;
        } catch (Exception e) {
            errout(e);
            return null;
        }
    }
----------------------------------------
    public static CabinetFactory getRfsCabinetFactory(Agent agent) {
        Factory fileFactory = getFilingServiceFactory();
        try {
            java.util.Map props = new java.util.Hashtable();
            props.put(FSReadWrite, Boolean.TRUE);
            props.put(FSLocalAccess, Boolean.TRUE);
            props.put(FSRemoteAccess, Boolean.TRUE);
            if (USE_CACHING_FILESYSTEM) props.put(FSMetaCaching, Boolean.TRUE); else props.put(FSMetaCaching, Boolean.FALSE);
            CabinetFactory[] matches = fileFactory.getCabinetFactory(props);
            if (matches.length == 0 && USE_CACHING_FILESYSTEM) {
                if (verbose) outln("couldn't find factory that supports " + FSMetaCaching);
                props.remove(FSMetaCaching);
                matches = fileFactory.getCabinetFactory(props);
            }
            CabinetFactory rfsFactory = matches[0];
            Agent userAgent = getUserAgent();
            if (agent != null) userAgent.addProxy(agent);
            rfsFactory.setOwner(userAgent);
            if (verbose) outln("got RfsFactory [" + rfsFactory + "] that matched properties " + props);
            return rfsFactory;
        } catch (Exception e) {
            errout(e);
            return null;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,26006.java,8,29
default,83302.java,14,37
----------------------------------------
    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
----------------------------------------
    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String version = null;
            String build = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".version")) version = line.substring(8).trim(); else if (line.startsWith(".build")) build = line.substring(6).trim();
            }
            bin.close();
            if (version != null && build != null) {
                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {
                    GUIUtilities.message(view, "version-check" + ".up-to-date", new String[0]);
                }
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55710.java,128,153
default,29342.java,128,153
----------------------------------------
    private boolean validateInput() {
        String filenameA = fileA.getText();
        String filenameB = fileB.getText();
        if (filenameB.length() == 0) {
            beep(fileB);
            return false;
        }
        compareA = null;
        if (filenameA.length() != 0) {
            compareA = new File(filenameA);
            if (!compareA.exists()) {
                beep(fileA);
                return false;
            }
        }
        compareB = new File(filenameB);
        if (!compareB.exists()) {
            beep(fileB);
            return false;
        }
        if (compareA != null && (compareA.isDirectory() != compareB.isDirectory())) {
            beep(fileA);
            return false;
        }
        return true;
    }
----------------------------------------
    private boolean validateInput() {
        String filenameA = fileA.getText();
        String filenameB = fileB.getText();
        if (filenameB.length() == 0) {
            beep(fileB);
            return false;
        }
        compareA = null;
        if (filenameA.length() != 0) {
            compareA = new File(filenameA);
            if (!compareA.exists()) {
                beep(fileA);
                return false;
            }
        }
        compareB = new File(filenameB);
        if (!compareB.exists()) {
            beep(fileB);
            return false;
        }
        if (compareA != null && (compareA.isDirectory() != compareB.isDirectory())) {
            beep(fileA);
            return false;
        }
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2510322.java,185,210
selected,10730.java,938,963
----------------------------------------
    private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset, int options) {
        byte[] ALPHABET = getAlphabet(options);
        int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0) | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0) | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
        switch(numSigBytes) {
            case 3:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];
                return destination;
            case 2:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            case 1:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = EQUALS_SIGN;
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;
            default:
                return destination;
        }
    }
----------------------------------------
    private static byte[] encode3to4(final byte[] source, final int srcOffset, final int numSigBytes, final byte[] destination, final int destOffset, final int options) {
        final byte[] ALPHABET = Base64.getAlphabet(options);
        final int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0) | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0) | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
        switch(numSigBytes) {
            case 3:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];
                return destination;
            case 2:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = Base64.EQUALS_SIGN;
                return destination;
            case 1:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = Base64.EQUALS_SIGN;
                destination[destOffset + 3] = Base64.EQUALS_SIGN;
                return destination;
            default:
                return destination;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73348.java,8,31
default,10360.java,8,29
----------------------------------------
    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String version = null;
            String build = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".version")) version = line.substring(8).trim(); else if (line.startsWith(".build")) build = line.substring(6).trim();
            }
            bin.close();
            if (version != null && build != null) {
                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {
                    GUIUtilities.message(view, "version-check" + ".up-to-date", new String[0]);
                }
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
----------------------------------------
    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6220.java,14,37
default,8235.java,8,29
----------------------------------------
    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String version = null;
            String build = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".version")) version = line.substring(8).trim(); else if (line.startsWith(".build")) build = line.substring(6).trim();
            }
            bin.close();
            if (version != null && build != null) {
                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {
                    GUIUtilities.message(view, "version-check" + ".up-to-date", new String[0]);
                }
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
----------------------------------------
    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12451.java,8,29
default,6220.java,14,37
----------------------------------------
    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
----------------------------------------
    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String version = null;
            String build = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".version")) version = line.substring(8).trim(); else if (line.startsWith(".build")) build = line.substring(6).trim();
            }
            bin.close();
            if (version != null && build != null) {
                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {
                    GUIUtilities.message(view, "version-check" + ".up-to-date", new String[0]);
                }
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,1253515.java,17,41
selected,1913054.java,18,43
----------------------------------------
    public static void main(String[] args) throws Exception {
        if (args.length != 1) {
            System.out.println("File path not given");
            System.exit(1);
        }
        HttpClient httpclient = new DefaultHttpClient();
        HttpPost httppost = new HttpPost("http://localhost:8080" + "/servlets-examples/servlet/RequestInfoExample");
        File file = new File(args[0]);
        InputStreamEntity reqEntity = new InputStreamEntity(new FileInputStream(file), -1);
        reqEntity.setContentType("binary/octet-stream");
        reqEntity.setChunked(true);
        httppost.setEntity(reqEntity);
        System.out.println("executing request " + httppost.getRequestLine());
        HttpResponse response = httpclient.execute(httppost);
        HttpEntity resEntity = response.getEntity();
        System.out.println("----------------------------------------");
        System.out.println(response.getStatusLine());
        if (resEntity != null) {
            System.out.println("Response content length: " + resEntity.getContentLength());
            System.out.println("Chunked?: " + resEntity.isChunked());
        }
        if (resEntity != null) {
            resEntity.consumeContent();
        }
    }
----------------------------------------
    public static void main(String[] args) throws Exception {
        if (args.length != 1) {
            System.out.println("File path not given");
            System.exit(1);
        }
        HttpClient httpclient = new DefaultHttpClient();
        HttpPost httppost = new HttpPost("http://localhost:8080" + "/servlets-examples/servlet/RequestInfoExample");
        FileBody bin = new FileBody(new File(args[0]));
        StringBody comment = new StringBody("A binary file of some kind");
        MultipartEntity reqEntity = new MultipartEntity();
        reqEntity.addPart("bin", bin);
        reqEntity.addPart("comment", comment);
        httppost.setEntity(reqEntity);
        System.out.println("executing request " + httppost.getRequestLine());
        HttpResponse response = httpclient.execute(httppost);
        HttpEntity resEntity = response.getEntity();
        System.out.println("----------------------------------------");
        System.out.println(response.getStatusLine());
        if (resEntity != null) {
            System.out.println("Response content length: " + resEntity.getContentLength());
            System.out.println("Chunked?: " + resEntity.isChunked());
        }
        if (resEntity != null) {
            resEntity.consumeContent();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,106083.java,224,248
selected,2187820.java,137,157
----------------------------------------
    private void copyDirectory(File sourceLocation, File targetLocation) {
        try {
            if (sourceLocation.isDirectory()) {
                if (!targetLocation.exists()) {
                    targetLocation.mkdir();
                }
                String[] children = sourceLocation.list();
                for (int i = 0; i < children.length; i++) {
                    copyDirectory(new File(sourceLocation, children[i]), new File(targetLocation, children[i]));
                }
            } else {
                InputStream in = new FileInputStream(sourceLocation);
                OutputStream out = new FileOutputStream(targetLocation);
                byte[] buf = new byte[1024];
                int len;
                while ((len = in.read(buf)) > 0) {
                    out.write(buf, 0, len);
                }
                in.close();
                out.close();
            }
        } catch (Exception me) {
            me.printStackTrace();
        }
    }
----------------------------------------
    public static void copyDirectory(File sourceLocation, File targetLocation) throws IOException {
        if (sourceLocation.isDirectory()) {
            if (!targetLocation.exists()) {
                targetLocation.mkdir();
            }
            String[] children = sourceLocation.list();
            for (int i = 0; i < children.length; i++) {
                copyDirectory(new File(sourceLocation, children[i]), new File(targetLocation, children[i]));
            }
        } else {
            InputStream in = new FileInputStream(sourceLocation);
            OutputStream out = new FileOutputStream(targetLocation);
            byte[] buf = new byte[1024];
            int len;
            while ((len = in.read(buf)) > 0) {
                out.write(buf, 0, len);
            }
            in.close();
            out.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
selected,2564195.java,84,106
selected,374127.java,59,83
----------------------------------------
    private void registerNodeChannels(final String type, final TypeQualifier nodeFilter) throws IOException {
        final NodeSignalProcessor processor = NodeSignalProcessor.getInstance(type);
        final List<SignalEntry> signals = new ArrayList<SignalEntry>();
        final TypeQualifier qualifier = QualifierFactory.qualifierForQualifiers(true, nodeFilter);
        final List<AcceleratorNode> nodes = SEQUENCE.getAllInclusiveNodesWithQualifier(qualifier);
        for (AcceleratorNode node : nodes) {
            final Collection handles = processor.getHandlesToProcess(node);
            for (Iterator handleIter = handles.iterator(); handleIter.hasNext(); ) {
                final String handle = (String) handleIter.next();
                final Channel channel = node.getChannel(handle);
                if (channel != null) {
                    final String signal = channel.channelName();
                    final SignalEntry entry = new SignalEntry(signal, handle);
                    if (!signals.contains(entry)) {
                        signals.add(entry);
                    }
                }
            }
        }
        for (SignalEntry entry : signals) {
            final MemoryProcessVariable pv = processor.makePV(SERVER, entry);
        }
    }
----------------------------------------
    protected void processNodes(final Writer writer, final String type, final TypeQualifier nodeFilter) throws IOException {
        final NodeSignalProcessor processor = NodeSignalProcessor.getInstance(type);
        final List<SignalEntry> signals = new ArrayList<SignalEntry>();
        final TypeQualifier qualifier = QualifierFactory.qualifierForQualifiers(true, nodeFilter);
        final List<AcceleratorNode> nodes = _sequence.getAllInclusiveNodesWithQualifier(qualifier);
        for (AcceleratorNode node : nodes) {
            final Collection<String> handles = processor.getHandlesToProcess(node);
            for (Iterator<String> handleIter = handles.iterator(); handleIter.hasNext(); ) {
                final String handle = handleIter.next();
                final Channel channel = node.getChannel(handle);
                if (channel != null) {
                    final String signal = channel.channelName();
                    final SignalEntry entry = new SignalEntry(signal, handle);
                    if (!signals.contains(entry)) {
                        signals.add(entry);
                    }
                }
            }
        }
        for (SignalEntry entry : signals) {
            final String line = processor.process(type, entry);
            writer.write(line);
            writer.write('\n');
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,522,544
default,23409.java,546,568
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42993.java,643,660
default,96339.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73352.java,524,546
default,90537.java,548,570
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,73352.java,548,570
default,51700.java,572,592
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5621.java,546,568
default,86322.java,522,544
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,517,539
default,55109.java,546,568
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,93897.java,648,665
default,55109.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62365.java,648,665
default,55109.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115118.java,546,568
default,70088.java,548,570
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,22931.java,648,665
default,70088.java,548,570
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109369.java,629,646
default,70088.java,524,546
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,118405.java,546,568
default,76392.java,522,544
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,669,687
default,103146.java,522,544
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35432.java,522,544
default,40375.java,380,402
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44208.java,546,568
default,35432.java,546,568
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51700.java,572,592
default,35432.java,546,568
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132787.java,546,568
default,72294.java,548,570
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90009.java,570,590
default,72294.java,524,546
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133515.java,522,544
default,53104.java,546,568
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133515.java,522,544
default,33872.java,648,665
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4439.java,546,568
default,15343.java,667,685
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,41265.java,629,646
default,4439.java,546,568
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,134647.java,522,544
default,58531.java,629,646
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109369.java,648,665
default,98981.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
