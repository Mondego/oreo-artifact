$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,78023.java,73,82
default,85301.java,64,71
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,17076.java,99,111
default,41408.java,99,111
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,101144.java,54,62
default,62476.java,73,82
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,41976.java,64,71
default,17076.java,64,71
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72306.java,194,203
default,17076.java,194,203
----------------------------------------
    public void testRetroCollections() {
        {
            List names = new Vector();
            Map dictionary = new Hashtable();
        }
        {
            List<String> names = new Vector<String>();
            Map<String, String> dictionary = new Hashtable<String, String>();
        }
    }
----------------------------------------
    public void testRetroCollections() {
        {
            List names = new Vector();
            Map dictionary = new Hashtable();
        }
        {
            List<String> names = new Vector<String>();
            Map<String, String> dictionary = new Hashtable<String, String>();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53413.java,113,124
default,39986.java,113,124
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,101144.java,99,111
default,95950.java,99,111
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,41408.java,99,111
default,48890.java,99,111
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,82554.java,549,554
default,15508.java,549,554
----------------------------------------
    private String parseArg(StreamTokenizer st) throws IOException {
        if (st.nextToken() != '(') throw new IOException("Missing '('");
        String ret = evalStrExpr(st);
        if (st.nextToken() != ')') throw new IOException("Missing ')'");
        return ret;
    }
----------------------------------------
    private String parseArg(StreamTokenizer st) throws IOException {
        if (st.nextToken() != '(') throw new IOException("Missing '('");
        String ret = evalStrExpr(st);
        if (st.nextToken() != ')') throw new IOException("Missing ')'");
        return ret;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,41408.java,19,34
default,69534.java,19,34
----------------------------------------
    public void testPalindrome() {
        assertFalse(isPalindrome("abcdef"));
        assertFalse(isPalindrome("abccda"));
        assertTrue(isPalindrome("abccba"));
        assertFalse(isPalindrome("abcxba"));
        assertTrue(isPalindrome("a"));
        assertTrue(isPalindrome("aa"));
        assertFalse(isPalindrome("ab"));
        assertTrue(isPalindrome(""));
        assertTrue(isPalindrome("aaa"));
        assertTrue(isPalindrome("aba"));
        assertTrue(isPalindrome("abbba"));
        assertTrue(isPalindrome("abba"));
        assertFalse(isPalindrome("abbaa"));
        assertFalse(isPalindrome("abcda"));
    }
----------------------------------------
    public void testPalindrome() {
        assertFalse(isPalindrome("abcdef"));
        assertFalse(isPalindrome("abccda"));
        assertTrue(isPalindrome("abccba"));
        assertFalse(isPalindrome("abcxba"));
        assertTrue(isPalindrome("a"));
        assertTrue(isPalindrome("aa"));
        assertFalse(isPalindrome("ab"));
        assertTrue(isPalindrome(""));
        assertTrue(isPalindrome("aaa"));
        assertTrue(isPalindrome("aba"));
        assertTrue(isPalindrome("abbba"));
        assertTrue(isPalindrome("abba"));
        assertFalse(isPalindrome("abbaa"));
        assertFalse(isPalindrome("abcda"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,111788.java,27,46
default,113632.java,27,46
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129984.java,43,71
default,15508.java,43,71
----------------------------------------
    public String nextToken() {
        skipDelimiters();
        if (curPos >= maxPos) throw new NoSuchElementException();
        int start = curPos;
        if (str.charAt(curPos) == '\"') {
            start++;
            curPos++;
            boolean quoted = false;
            while (quoted || str.charAt(curPos) != '\"') {
                quoted = !quoted && str.charAt(curPos) == '\\';
                curPos++;
                if (curPos >= maxPos) throw new UnterminatedStringException();
            }
            StringBuffer sb = new StringBuffer();
            String s = str.substring(start, curPos++);
            int st = 0;
            for (; ; ) {
                int bs = s.indexOf('\\', st);
                if (bs == -1) break;
                sb.append(s.substring(st, bs));
                sb.append(s.substring(bs + 1, bs + 2));
                st = bs + 2;
            }
            sb.append(s.substring(st));
            return sb.toString();
        }
        while (curPos < maxPos && delim.indexOf(str.charAt(curPos)) < 0) curPos++;
        return str.substring(start, curPos);
    }
----------------------------------------
    public String nextToken() {
        skipDelimiters();
        if (curPos >= maxPos) throw new NoSuchElementException();
        int start = curPos;
        if (str.charAt(curPos) == '\"') {
            start++;
            curPos++;
            boolean quoted = false;
            while (quoted || str.charAt(curPos) != '\"') {
                quoted = !quoted && str.charAt(curPos) == '\\';
                curPos++;
                if (curPos >= maxPos) throw new UnterminatedStringException();
            }
            StringBuffer sb = new StringBuffer();
            String s = str.substring(start, curPos++);
            int st = 0;
            for (; ; ) {
                int bs = s.indexOf('\\', st);
                if (bs == -1) break;
                sb.append(s.substring(st, bs));
                sb.append(s.substring(bs + 1, bs + 2));
                st = bs + 2;
            }
            sb.append(s.substring(st));
            return sb.toString();
        }
        while (curPos < maxPos && delim.indexOf(str.charAt(curPos)) < 0) curPos++;
        return str.substring(start, curPos);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76337.java,175,180
default,69534.java,175,180
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,82554.java,265,278
default,129984.java,265,278
----------------------------------------
    void buildLoopRegion(Vector region) throws IOException {
        for (; ; ) {
            String inLine = readLine();
            if (inLine == null) throw new IOException("Unexpected end of file");
            if (isTemplateLine(inLine)) {
                int command = getTemplateCommand(inLine);
                if (command == END) break;
                region.addElement(buildTemplateRegion(inLine));
            } else {
                if (DEBUG) System.out.println("adding line to region :" + inLine);
                region.addElement(inLine);
            }
        }
    }
----------------------------------------
    void buildLoopRegion(Vector region) throws IOException {
        for (; ; ) {
            String inLine = readLine();
            if (inLine == null) throw new IOException("Unexpected end of file");
            if (isTemplateLine(inLine)) {
                int command = getTemplateCommand(inLine);
                if (command == END) break;
                region.addElement(buildTemplateRegion(inLine));
            } else {
                if (DEBUG) System.out.println("adding line to region :" + inLine);
                region.addElement(inLine);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40097.java,126,138
default,41976.java,126,138
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70088.java,308,322
default,35053.java,308,322
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16429.java,463,472
default,107017.java,452,461
----------------------------------------
    public void addUDP(final InetAddress addr, final int port) {
        Thread t;
        t = new Thread(new Runnable() {

            public void run() {
                serveUDP(addr, port);
            }
        });
        t.start();
    }
----------------------------------------
    public void addTCP(final InetAddress addr, final int port) {
        Thread t;
        t = new Thread(new Runnable() {

            public void run() {
                serveTCP(addr, port);
            }
        });
        t.start();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,13378.java,506,524
default,28899.java,513,531
----------------------------------------
    private final void initAssocParam(Configuration cfg, DcmURL url, boolean echo) {
        acTimeout = Integer.parseInt(cfg.getProperty("ac-timeout", "5000"));
        dimseTimeout = Integer.parseInt(cfg.getProperty("dimse-timeout", "0"));
        soCloseDelay = Integer.parseInt(cfg.getProperty("so-close-delay", "500"));
        assocRQ.setCalledAET(url.getCalledAET());
        assocRQ.setCallingAET(maskNull(url.getCallingAET()));
        assocRQ.setMaxPDULength(Integer.parseInt(cfg.getProperty("max-pdu-len", "16352")));
        assocRQ.setAsyncOpsWindow(aFact.newAsyncOpsWindow(Integer.parseInt(cfg.getProperty("max-op-invoked", "0")), 1));
        if (echo) {
            assocRQ.addPresContext(aFact.newPresContext(PCID_ECHO, UIDs.Verification, DEF_TS));
            return;
        }
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("pc.")) {
                initPresContext(Integer.parseInt(key.substring(3)), cfg.tokenize(cfg.getProperty(key), new LinkedList()));
            }
        }
    }
----------------------------------------
    private final void initAssocParam(Configuration cfg, DcmURL url, boolean echo) {
        acTimeout = Integer.parseInt(cfg.getProperty("ac-timeout", "5000"));
        dimseTimeout = Integer.parseInt(cfg.getProperty("dimse-timeout", "0"));
        soCloseDelay = Integer.parseInt(cfg.getProperty("so-close-delay", "500"));
        assocRQ.setCalledAET(url.getCalledAET());
        assocRQ.setCallingAET(maskNull(url.getCallingAET()));
        assocRQ.setMaxPDULength(Integer.parseInt(cfg.getProperty("max-pdu-len", "16352")));
        assocRQ.setAsyncOpsWindow(aFact.newAsyncOpsWindow(Integer.parseInt(cfg.getProperty("max-op-invoked", "0")), 1));
        if (echo) {
            assocRQ.addPresContext(aFact.newPresContext(PCID_ECHO, UIDs.Verification, DEF_TS));
            return;
        }
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("pc.")) {
                initPresContext(Integer.parseInt(key.substring(3)), cfg.tokenize(cfg.getProperty(key), new LinkedList()));
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62476.java,54,62
default,69534.java,73,82
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88658.java,50,61
default,40221.java,50,61
----------------------------------------
    public List tokenize(String s, List result) {
        StringTokenizer stk = new StringTokenizer(s, ", ");
        while (stk.hasMoreTokens()) {
            String tk = stk.nextToken();
            if (tk.startsWith("$")) {
                tokenize(getProperty(tk.substring(1), ""), result);
            } else {
                result.add(tk);
            }
        }
        return result;
    }
----------------------------------------
    public List tokenize(String s, List result) {
        StringTokenizer stk = new StringTokenizer(s, ", ");
        while (stk.hasMoreTokens()) {
            String tk = stk.nextToken();
            if (tk.startsWith("$")) {
                tokenize(getProperty(tk.substring(1), ""), result);
            } else {
                result.add(tk);
            }
        }
        return result;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,77410.java,141,222
default,1628.java,130,197
----------------------------------------
    protected void writeContents() throws IOException {
        parseFormData();
        checkReferrer();
        String filename = getParameter(FILE_PARAM);
        if (filename == null) ;
        Element file = findFile(filename);
        if (file == null) {
            sendNoSuchFileMessage(filename);
            return;
        }
        File result = computePath(file, false);
        if (!metaPathVariables.isEmpty()) {
            pathVariables = metaPathVariables;
            pathVariableNames = metaPathVariableNames;
            displayNeedInfoForm(filename, null, false, MISSING_META, file);
            return;
        }
        if (result == null && !needPathInfo()) {
            sendNoSuchFileMessage(filename);
            return;
        }
        if (result == null) {
            displayNeedInfoForm(filename, result, false, MISSING_INFO, file);
            return;
        }
        if (!nameIsSafe(result)) {
            displayNeedInfoForm(filename, result, false, MISSING_INFO, file);
            return;
        }
        if (!result.exists()) {
            if (getParameter(CONFIRM_PARAM) == null) {
                displayNeedInfoForm(filename, result, false, CREATE_CONFIRM, file);
                return;
            }
            if (isDirectory) {
                if (!result.mkdirs()) {
                    String message = resources.format("Create_Directory_Error_FMT", HTMLUtils.escapeEntities(result.getPath()));
                    sendCopyTemplateError(message);
                    return;
                }
            }
        }
        if (result.exists()) {
            redirectTo(filename, result);
            return;
        }
        savePathInfo();
        File template = computePath(file, true);
        if (!metaPathVariables.isEmpty()) {
            pathVariables = metaPathVariables;
            pathVariableNames = metaPathVariableNames;
            displayNeedInfoForm(filename, null, true, MISSING_META, file);
            return;
        }
        if (!foundTemplate) {
            restorePathInfo();
            displayNeedInfoForm(filename, result, false, CANNOT_LOCATE, file);
            return;
        }
        String templateURL = null;
        if (isTemplateURL(template)) try {
            templateURL = template.toURL().toString();
            templateURL = templateURL.substring(templateURL.indexOf(TEMPLATE_ROOT_UNIX) + TEMPLATE_ROOT_UNIX.length() - 1);
        } catch (MalformedURLException mue) {
        }
        if (template == null || (templateURL == null && !template.exists())) {
            displayNeedInfoForm(filename, template, true, MISSING_INFO, file);
            return;
        }
        File resultDir = result.getParentFile();
        if (!resultDir.exists()) if (!resultDir.mkdirs()) {
            String message = resources.format("Create_Directory_Error_FMT", HTMLUtils.escapeEntities(resultDir.getPath()));
            sendCopyTemplateError(message);
            return;
        }
        if (copyFile(template, templateURL, result) == false) {
            String message = resources.format("Copy_File_Error_FMT", HTMLUtils.escapeEntities(template.getPath()), HTMLUtils.escapeEntities(result.getPath()));
            sendCopyTemplateError(message);
            return;
        }
        redirectTo(filename, result);
    }
----------------------------------------
    protected void writeContents() throws IOException {
        parseFormData();
        String filename = getParameter(FILE_PARAM);
        if (filename == null) ;
        Element file = findFile(filename);
        if (file == null) {
            sendNoSuchFileMessage(filename);
            return;
        }
        File result = computePath(file, false);
        if (!metaPathVariables.isEmpty()) {
            pathVariables = metaPathVariables;
            pathVariableNames = metaPathVariableNames;
            displayNeedInfoForm(filename, null, false, file);
            return;
        }
        if (result == null && !needPathInfo()) {
            sendNoSuchFileMessage(filename);
            return;
        }
        if (result == null) {
            displayNeedInfoForm(filename, result, false, file);
            return;
        }
        if (!result.exists() && isDirectory) {
            if (!result.mkdirs()) {
                sendCopyTemplateError("Could not create the directory '" + result.getPath() + "'.");
                return;
            }
        }
        if (result.exists()) {
            redirectTo(filename, result);
            return;
        }
        savePathInfo();
        File template = computePath(file, true);
        if (!metaPathVariables.isEmpty()) {
            pathVariables = metaPathVariables;
            pathVariableNames = metaPathVariableNames;
            displayNeedInfoForm(filename, null, true, file);
            return;
        }
        if (!foundTemplate) {
            restorePathInfo();
            displayNeedInfoForm(filename, result, false, file);
            return;
        }
        String templateURL = null;
        if (isTemplateURL(template)) try {
            templateURL = template.toURL().toString();
            templateURL = templateURL.substring(templateURL.indexOf(TEMPLATE_ROOT_UNIX) + TEMPLATE_ROOT_UNIX.length() - 1);
        } catch (MalformedURLException mue) {
        }
        if (template == null || (templateURL == null && !template.exists())) {
            displayNeedInfoForm(filename, template, true, file);
            return;
        }
        File resultDir = result.getParentFile();
        if (!resultDir.exists()) if (!resultDir.mkdirs()) {
            sendCopyTemplateError("Could not create the directory '" + resultDir.getPath() + "'.");
            return;
        }
        if (copyFile(template, templateURL, result) == false) {
            sendCopyTemplateError("Could not copy '" + template.getPath() + "' to '" + result.getPath() + "'.");
            return;
        }
        redirectTo(filename, result);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,84782.java,105,116
default,2207.java,105,116
----------------------------------------
    private static void addUIDs(Dataset ds) {
        UIDGenerator uidgen = UIDGenerator.getInstance();
        if (!ds.contains(Tags.StudyInstanceUID)) {
            ds.putUI(Tags.StudyInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SeriesInstanceUID)) {
            ds.putUI(Tags.SeriesInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SOPInstanceUID)) {
            ds.putUI(Tags.SOPInstanceUID, uidgen.createUID());
        }
    }
----------------------------------------
    private static void addUIDs(Dataset ds) {
        UIDGenerator uidgen = UIDGenerator.getInstance();
        if (!ds.contains(Tags.StudyInstanceUID)) {
            ds.putUI(Tags.StudyInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SeriesInstanceUID)) {
            ds.putUI(Tags.SeriesInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SOPInstanceUID)) {
            ds.putUI(Tags.SOPInstanceUID, uidgen.createUID());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103762.java,667,685
default,35053.java,629,646
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65413.java,572,592
default,116906.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98981.java,667,685
default,35053.java,667,685
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95950.java,175,180
default,39986.java,175,180
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25053.java,335,349
default,24621.java,335,349
----------------------------------------
    public void create(String[] args, int off) throws IOException {
        if (uid == null || uid.length() == 0) {
            uid = UIDGenerator.getInstance().createUID();
        }
        File rootDir = dirFile.getParentFile();
        if (rootDir != null && !rootDir.exists()) {
            rootDir.mkdirs();
        }
        DirWriter writer = fact.newDirWriter(dirFile, uid, id, readMeFile, readMeCharset, encodeParam());
        try {
            build(writer, args, off);
        } finally {
            writer.close();
        }
    }
----------------------------------------
    public void create(String[] args, int off) throws IOException {
        if (uid == null || uid.length() == 0) {
            uid = UIDGenerator.getInstance().createUID();
        }
        File rootDir = dirFile.getParentFile();
        if (rootDir != null && !rootDir.exists()) {
            rootDir.mkdirs();
        }
        DirWriter writer = fact.newDirWriter(dirFile, uid, id, readMeFile, readMeCharset, encodeParam());
        try {
            build(writer, args, off);
        } finally {
            writer.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,2058.java,126,133
default,8952.java,199,206
----------------------------------------
    private static void set(Configuration cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("set." + s, "");
        } else {
            cfg.put("set." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,117763.java,73,82
default,53413.java,54,62
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45925.java,72,79
default,50355.java,72,79
----------------------------------------
    SkinProperty(String name, String defaultValue, String id, int type, boolean isNew) {
        this.name = name;
        this.value = defaultValue;
        this.id = id;
        this.isNew = isNew;
        this.type = type;
        this.totalPieces = 1;
    }
----------------------------------------
    SkinProperty(String name, String defaultValue, String id, int type, boolean isNew) {
        this.name = name;
        this.value = defaultValue;
        this.id = id;
        this.isNew = isNew;
        this.type = type;
        this.totalPieces = 1;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53567.java,43,52
default,70893.java,43,52
----------------------------------------
    public void testCommas() {
        String sequence = "1,2,3,4,5";
        assertEquals(sequence, sequenceUsingDo(1, 5));
        assertEquals(sequence, sequenceUsingFor(1, 5));
        assertEquals(sequence, sequenceUsingWhile(1, 5));
        sequence = "8";
        assertEquals(sequence, sequenceUsingDo(8, 8));
        assertEquals(sequence, sequenceUsingFor(8, 8));
        assertEquals(sequence, sequenceUsingWhile(8, 8));
    }
----------------------------------------
    public void testCommas() {
        String sequence = "1,2,3,4,5";
        assertEquals(sequence, sequenceUsingDo(1, 5));
        assertEquals(sequence, sequenceUsingFor(1, 5));
        assertEquals(sequence, sequenceUsingWhile(1, 5));
        sequence = "8";
        assertEquals(sequence, sequenceUsingDo(8, 8));
        assertEquals(sequence, sequenceUsingFor(8, 8));
        assertEquals(sequence, sequenceUsingWhile(8, 8));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56146.java,73,82
default,48890.java,73,82
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,8506.java,459,468
default,4297.java,452,461
----------------------------------------
    public void addUDP(final InetAddress addr, final int port) {
        Thread t;
        t = new Thread(new Runnable() {

            public void run() {
                serveUDP(addr, port);
            }
        });
        t.start();
    }
----------------------------------------
    public void addTCP(final InetAddress addr, final int port) {
        Thread t;
        t = new Thread(new Runnable() {

            public void run() {
                serveTCP(addr, port);
            }
        });
        t.start();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28899.java,142,195
default,51702.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("DcmGen", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmGen.class.getResource("dcmgen.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'r':
                    cfg.put("set-random", "true");
                    break;
                case 'c':
                    cfg.put("set-complete", "true");
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmGen DcmGen = new DcmGen(cfg, new DcmURL(args[optind]), argc);
            DcmGen.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44208.java,648,665
default,56216.java,667,685
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,75612.java,113,124
default,28707.java,113,124
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51702.java,526,534
default,13560.java,526,534
----------------------------------------
    private final void initPresContext(int pcid, List val) {
        Iterator it = val.iterator();
        String as = UIDs.forName((String) it.next());
        String[] tsUIDs = new String[val.size() - 1];
        for (int i = 0; i < tsUIDs.length; ++i) {
            tsUIDs[i] = UIDs.forName((String) it.next());
        }
        assocRQ.addPresContext(aFact.newPresContext(pcid, as, tsUIDs));
    }
----------------------------------------
    private final void initPresContext(int pcid, List val) {
        Iterator it = val.iterator();
        String as = UIDs.forName((String) it.next());
        String[] tsUIDs = new String[val.size() - 1];
        for (int i = 0; i < tsUIDs.length; ++i) {
            tsUIDs[i] = UIDs.forName((String) it.next());
        }
        assocRQ.addPresContext(aFact.newPresContext(pcid, as, tsUIDs));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,669,687
default,70088.java,631,648
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,669,687
default,24621.java,667,685
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,10254.java,84,91
default,115646.java,84,91
----------------------------------------
    public void testEndTrim() {
        assertEquals("", endTrim(""));
        assertEquals("  x", endTrim("  x  "));
        assertEquals("y", endTrim("y"));
        assertEquals("xaxa", endTrim("xaxa"));
        assertEquals("", endTrim(" "));
        assertEquals("xxx", endTrim("xxx      "));
    }
----------------------------------------
    public void testEndTrim() {
        assertEquals("", endTrim(""));
        assertEquals("  x", endTrim("  x  "));
        assertEquals("y", endTrim("y"));
        assertEquals("xaxa", endTrim("xaxa"));
        assertEquals("", endTrim(" "));
        assertEquals("xxx", endTrim("xxx      "));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,10254.java,84,91
default,39986.java,84,91
----------------------------------------
    public void testEndTrim() {
        assertEquals("", endTrim(""));
        assertEquals("  x", endTrim("  x  "));
        assertEquals("y", endTrim("y"));
        assertEquals("xaxa", endTrim("xaxa"));
        assertEquals("", endTrim(" "));
        assertEquals("xxx", endTrim("xxx      "));
    }
----------------------------------------
    public void testEndTrim() {
        assertEquals("", endTrim(""));
        assertEquals("  x", endTrim("  x  "));
        assertEquals("y", endTrim("y"));
        assertEquals("xaxa", endTrim("xaxa"));
        assertEquals("", endTrim(" "));
        assertEquals("xxx", endTrim("xxx      "));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,97898.java,75,91
default,77601.java,75,91
----------------------------------------
    private void open(File f) {
        try {
            ImageInputStream iis = ImageIO.createImageInputStream(f);
            Iterator iter = ImageIO.getImageReadersByFormatName("DICOM");
            ImageReader reader = (ImageReader) iter.next();
            reader.setInput(iis, false);
            JPanel p = new ImageBox(reader);
            JFrame jf = new JFrame("ImageDisplay - Display Panel");
            jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            jf.getContentPane().add(p);
            jf.pack();
            jf.setSize(Math.min(jf.getWidth(), 800), Math.min(jf.getHeight(), 600));
            jf.setVisible(true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
----------------------------------------
    private void open(File f) {
        try {
            ImageInputStream iis = ImageIO.createImageInputStream(f);
            Iterator iter = ImageIO.getImageReadersByFormatName("DICOM");
            ImageReader reader = (ImageReader) iter.next();
            reader.setInput(iis, false);
            JPanel p = new ImageBox(reader);
            JFrame jf = new JFrame("ImageDisplay - Display Panel");
            jf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            jf.getContentPane().add(p);
            jf.pack();
            jf.setSize(Math.min(jf.getWidth(), 800), Math.min(jf.getHeight(), 600));
            jf.setVisible(true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,87653.java,453,467
default,87653.java,1270,1284
----------------------------------------
    private byte[] importAutoAddData(HTTPurl urlData) throws Exception {
        String sessionID = urlData.getParameter("sessionID");
        if (!store.checkSessionID(sessionID)) {
            return "Security Warning: The Security Session ID you entered is not correct.".getBytes();
        }
        boolean append = "append".equalsIgnoreCase(urlData.getParameter("data_action"));
        String data = urlData.getParameter("data");
        if (data != null && data.length() > 0) {
            store.importEpgAutoList(data.trim(), append);
        }
        StringBuffer buff = new StringBuffer();
        buff.append("HTTP/1.0 302 Moved Temporarily\n");
        buff.append("Location: /servlet/EpgAutoAddDataRes?action=01\n\n");
        return buff.toString().getBytes();
    }
----------------------------------------
    private byte[] addMatchList(HTTPurl urlData) throws Exception {
        String name = urlData.getParameter("name");
        if (name != null && name.trim().length() > 0) {
            HashMap<String, EpgMatchList> matchLists = store.getMatchLists();
            if (!matchLists.containsKey(name)) {
                EpgMatchList matchList = new EpgMatchList();
                matchLists.put(name.trim(), matchList);
                store.saveMatchList(null);
            }
        }
        StringBuffer out = new StringBuffer(256);
        out.append("HTTP/1.0 302 Moved Temporarily\n");
        out.append("Location: /servlet/" + urlData.getServletClass() + "?action=05\n\n");
        return out.toString().getBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,17673.java,11,104
default,78872.java,11,104
----------------------------------------
    public static void main(String[] args) {
        if (args.length < 3) {
            System.err.println("CreateSyntheticGenome was not called properly. It should be called as:");
            System.err.println("\tjava CreateSyntheticGenome fasta_input_file slo_output_file mutations_file [read_length]");
        }
        String inputFile = args[0];
        String outputFile = args[1];
        String mutationFile = args[2];
        int readLength = 36;
        if (args.length > 3) {
            readLength = Integer.parseInt(args[3]);
        }
        int numberOfMutations = fileLineLength(mutationFile);
        HashMap[] mutationArray = new HashMap[numberOfMutations];
        populateMutationHash(mutationFile, mutationArray);
        for (int i = 1; i < mutationArray.length; i++) {
            String mLen1 = mutationArray[i - 1].get("mutation").toString();
            int mPos1 = Integer.parseInt(mutationArray[i - 1].get("position").toString());
            int mPos2 = Integer.parseInt(mutationArray[i].get("position").toString());
            if (mPos1 + readLength + mLen1.length() >= mPos2 - readLength) {
                System.err.println("ERROR: Mutation position + length of mutation must be more than readLength (" + readLength + ") bases apart from the next mutation position minus readLength.");
                System.err.println(mPos2 + " is too close to " + mPos1);
                System.exit(-1);
            }
        }
        Sequence fastaSequence = prepareFastaRead(inputFile);
        BufferedWriter out = null;
        try {
            out = new BufferedWriter(new FileWriter(outputFile));
        } catch (IOException e) {
            System.exit(-1);
        }
        try {
            out.write("#QuerySequenceID\tQuerySeq\tTargetLocation\tTargetStrand\tTargetSequence\tQueryQualityScore\tQueryPrefixTags\tQuerySuffixTags\tMultiReads\tReadNum\tQueryUnconvertedCsFirstRead\tQueryUnconvertedCsSecondRead\n");
        } catch (IOException e) {
            System.exit(-1);
        }
        for (int i = 0; i < mutationArray.length; i++) {
            int mPosition = Integer.parseInt(mutationArray[i].get("position").toString());
            String mType = mutationArray[i].get("type").toString();
            String mOriginal = mutationArray[i].get("original").toString();
            String mMutation = mutationArray[i].get("mutation").toString();
            int readOffset = mPosition - readLength;
            int totalReadLength = 2 * readLength - 1;
            if (readOffset < 0) {
                totalReadLength += readOffset;
                readOffset = 0;
            }
            String seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
            seqRead = seqRead.toUpperCase();
            String referenceSeq = seqRead;
            String mutatedSeq = seqRead;
            int changePos = totalReadLength - readLength;
            if (mType.equals("i")) {
            } else if ((mType.equals("v") || mType.equals("d")) && mOriginal.equals(seqRead.substring(changePos, changePos + mOriginal.length()))) {
                if (mType.equals("v")) {
                    mutatedSeq = seqRead.substring(0, changePos) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                } else if (mType.equals("d")) {
                    totalReadLength += mMutation.length() - 1;
                    seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
                    seqRead = seqRead.toUpperCase();
                    referenceSeq = seqRead;
                    mutatedSeq = seqRead.substring(0, changePos) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                } else if (mType.equals("i")) {
                    totalReadLength += mMutation.length() - 1;
                    seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
                    seqRead = seqRead.toUpperCase();
                    mutatedSeq = seqRead.substring(1, changePos + 1) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                    referenceSeq = seqRead.substring(1, changePos + 1) + mOriginal + seqRead.substring(changePos + 1, totalReadLength);
                    readOffset++;
                } else {
                    System.err.println("Something is wrong, mType came up as " + mType + ".");
                    System.exit(1);
                }
            } else {
                System.err.println("Something is wrong. The mutation was supposed to change a \'" + mOriginal + "\' but instead, that position is a \'" + seqRead.substring(changePos, changePos + 1) + "\'.");
                System.exit(1);
            }
            for (int j = 0; j <= totalReadLength - readLength; j++) {
                try {
                    out.write("1:1:1:" + ((i + 1) * 1000 + j) + "\t" + mutatedSeq.substring(j, j + readLength) + "\tchr22:" + (readOffset + j) + "\tF\t" + referenceSeq.substring(j, j + readLength) + "\t0" + "\n");
                    out.write("1:1:1:" + ((i + 1) * 1000 + j) + "\t" + mutatedSeq.substring(j, j + readLength) + "\tchr22:" + (readOffset + j) + "\tR\t" + reverseString(referenceSeq.substring(j, j + readLength)) + "\t0" + "\n");
                } catch (IOException e) {
                    System.exit(-1);
                }
            }
        }
        try {
            out.close();
        } catch (IOException e) {
            System.exit(-1);
        }
        System.exit(0);
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length < 3) {
            System.err.println("CreateSyntheticGenome was not called properly. It should be called as:");
            System.err.println("\tjava CreateSyntheticGenome fasta_input_file slo_output_file mutations_file [read_length]");
        }
        String inputFile = args[0];
        String outputFile = args[1];
        String mutationFile = args[2];
        int readLength = 36;
        if (args.length > 3) {
            readLength = Integer.parseInt(args[3]);
        }
        int numberOfMutations = fileLineLength(mutationFile);
        HashMap[] mutationArray = new HashMap[numberOfMutations];
        populateMutationHash(mutationFile, mutationArray);
        for (int i = 1; i < mutationArray.length; i++) {
            String mLen1 = mutationArray[i - 1].get("mutation").toString();
            int mPos1 = Integer.parseInt(mutationArray[i - 1].get("position").toString());
            int mPos2 = Integer.parseInt(mutationArray[i].get("position").toString());
            if (mPos1 + readLength + mLen1.length() >= mPos2 - readLength) {
                System.err.println("ERROR: Mutation position + length of mutation must be more than readLength (" + readLength + ") bases apart from the next mutation position minus readLength.");
                System.err.println(mPos2 + " is too close to " + mPos1);
                System.exit(-1);
            }
        }
        Sequence fastaSequence = prepareFastaRead(inputFile);
        BufferedWriter out = null;
        try {
            out = new BufferedWriter(new FileWriter(outputFile));
        } catch (IOException e) {
            System.exit(-1);
        }
        try {
            out.write("#QuerySequenceID\tQuerySeq\tTargetLocation\tTargetStrand\tTargetSequence\tQueryQualityScore\tQueryPrefixTags\tQuerySuffixTags\tMultiReads\tReadNum\tQueryUnconvertedCsFirstRead\tQueryUnconvertedCsSecondRead\n");
        } catch (IOException e) {
            System.exit(-1);
        }
        for (int i = 0; i < mutationArray.length; i++) {
            int mPosition = Integer.parseInt(mutationArray[i].get("position").toString());
            String mType = mutationArray[i].get("type").toString();
            String mOriginal = mutationArray[i].get("original").toString();
            String mMutation = mutationArray[i].get("mutation").toString();
            int readOffset = mPosition - readLength;
            int totalReadLength = 2 * readLength - 1;
            if (readOffset < 0) {
                totalReadLength += readOffset;
                readOffset = 0;
            }
            String seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
            seqRead = seqRead.toUpperCase();
            String referenceSeq = seqRead;
            String mutatedSeq = seqRead;
            int changePos = totalReadLength - readLength;
            if (mType.equals("i")) {
            } else if ((mType.equals("v") || mType.equals("d")) && mOriginal.equals(seqRead.substring(changePos, changePos + mOriginal.length()))) {
                if (mType.equals("v")) {
                    mutatedSeq = seqRead.substring(0, changePos) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                } else if (mType.equals("d")) {
                    totalReadLength += mMutation.length() - 1;
                    seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
                    seqRead = seqRead.toUpperCase();
                    referenceSeq = seqRead;
                    mutatedSeq = seqRead.substring(0, changePos) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                } else if (mType.equals("i")) {
                    totalReadLength += mMutation.length() - 1;
                    seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
                    seqRead = seqRead.toUpperCase();
                    mutatedSeq = seqRead.substring(1, changePos + 1) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                    referenceSeq = seqRead.substring(1, changePos + 1) + mOriginal + seqRead.substring(changePos + 1, totalReadLength);
                    readOffset++;
                } else {
                    System.err.println("Something is wrong, mType came up as " + mType + ".");
                    System.exit(1);
                }
            } else {
                System.err.println("Something is wrong. The mutation was supposed to change a \'" + mOriginal + "\' but instead, that position is a \'" + seqRead.substring(changePos, changePos + 1) + "\'.");
                System.exit(1);
            }
            for (int j = 0; j <= totalReadLength - readLength; j++) {
                try {
                    out.write("1:1:1:" + ((i + 1) * 1000 + j) + "\t" + mutatedSeq.substring(j, j + readLength) + "\tchr22:" + (readOffset + j) + "\tF\t" + referenceSeq.substring(j, j + readLength) + "\t0" + "\n");
                    out.write("1:1:1:" + ((i + 1) * 1000 + j) + "\t" + mutatedSeq.substring(j, j + readLength) + "\tchr22:" + (readOffset + j) + "\tR\t" + reverseString(referenceSeq.substring(j, j + readLength)) + "\t0" + "\n");
                } catch (IOException e) {
                    System.exit(-1);
                }
            }
        }
        try {
            out.close();
        } catch (IOException e) {
            System.exit(-1);
        }
        System.exit(0);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65413.java,572,592
default,70088.java,669,687
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4537.java,228,241
default,50381.java,238,251
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,74245.java,184,198
default,108541.java,197,213
----------------------------------------
    DcmSnd(Configuration cfg, DcmURL url, int argc) {
        this.url = url;
        this.priority = Integer.parseInt(cfg.getProperty("prior", "0"));
        this.packPDVs = "true".equalsIgnoreCase(cfg.getProperty("pack-pdvs", "false"));
        this.truncPostPixelData = "true".equalsIgnoreCase(cfg.getProperty("trunc-post-pixeldata", "false"));
        this.excludePrivate = "true".equalsIgnoreCase(cfg.getProperty("exclude-private", "false"));
        this.bufferSize = Integer.parseInt(cfg.getProperty("buf-len", "2048")) & 0xfffffffe;
        this.repeatWhole = Integer.parseInt(cfg.getProperty("repeat-assoc", "1"));
        this.repeatSingle = Integer.parseInt(cfg.getProperty("repeat-dimse", "1"));
        this.uidSuffix = cfg.getProperty("uid-suffix");
        this.mode = argc > 1 ? SEND : initPollDirSrv(cfg) ? POLL : ECHO;
        initAssocParam(cfg, url, mode == ECHO);
        initTLS(cfg);
        initOverwrite(cfg);
    }
----------------------------------------
    DcmGen(Configuration cfg, DcmURL url, int argc) {
        this.url = url;
        this.priority = Integer.parseInt(cfg.getProperty("prior", "0"));
        this.packPDVs = "true".equalsIgnoreCase(cfg.getProperty("pack-pdvs", "false"));
        this.truncPostPixelData = "true".equalsIgnoreCase(cfg.getProperty("trunc-post-pixeldata", "false"));
        this.excludePrivate = "true".equalsIgnoreCase(cfg.getProperty("exclude-private", "false"));
        this.bufferSize = Integer.parseInt(cfg.getProperty("buf-len", "2048")) & 0xfffffffe;
        this.repeatWhole = Integer.parseInt(cfg.getProperty("repeat-assoc", "1"));
        this.repeatSingle = Integer.parseInt(cfg.getProperty("repeat-dimse", "1"));
        this.uidSuffix = cfg.getProperty("uid-suffix");
        this.mode = argc > 1 ? SEND : ECHO;
        this.random = "true".equalsIgnoreCase(cfg.getProperty("set-random", "false"));
        this.complete = "true".equalsIgnoreCase(cfg.getProperty("set-complete", "false"));
        initAssocParam(cfg, url, mode == ECHO);
        initTLS(cfg);
        initOverwrite(cfg);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,85514.java,488,494
default,11974.java,488,494
----------------------------------------
    private Socket newSocket(String host, int port) throws IOException, GeneralSecurityException {
        if (cipherSuites != null) {
            return tls.getSocketFactory(cipherSuites).createSocket(host, port);
        } else {
            return new Socket(host, port);
        }
    }
----------------------------------------
    private Socket newSocket(String host, int port) throws IOException, GeneralSecurityException {
        if (cipherSuites != null) {
            return tls.getSocketFactory(cipherSuites).createSocket(host, port);
        } else {
            return new Socket(host, port);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40832.java,389,412
default,132453.java,382,405
----------------------------------------
    public int loadXMLdata(byte[] xmlFile) throws Exception {
        int found = 0;
        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
        ByteArrayInputStream reader = new ByteArrayInputStream(xmlFile);
        Document doc = docBuilder.parse(reader);
        NodeList root = null;
        root = doc.getElementsByTagName("tv");
        if (root != null) {
            Node firstNode = root.item(0);
            if (firstNode == null) {
                System.out.println("ERROR precessing XML data, first node of <tv> not found.");
                return found;
            }
            root = firstNode.getChildNodes();
            if (root == null) {
                System.out.println("ERROR precessing XML data, no children of first node.");
                return found;
            }
            HashMap channels = loadChannels(root);
            found = recurseXMLData(root, channels);
        }
        return found;
    }
----------------------------------------
    public int loadXMLdata(byte[] xmlFile) throws Exception {
        int found = 0;
        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
        ByteArrayInputStream reader = new ByteArrayInputStream(xmlFile);
        Document doc = docBuilder.parse(reader);
        NodeList root = null;
        root = doc.getElementsByTagName("tv");
        if (root != null) {
            Node firstNode = root.item(0);
            if (firstNode == null) {
                System.out.println("ERROR precessing XML data, first node of <tv> not found.");
                return found;
            }
            root = firstNode.getChildNodes();
            if (root == null) {
                System.out.println("ERROR precessing XML data, no children of first node.");
                return found;
            }
            HashMap channels = loadChannels(root);
            found = recurseXMLData(root, channels);
        }
        return found;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,133404.java,171,192
default,133404.java,223,244
----------------------------------------
    public StudentInfo[] getStudents(boolean first_last) {
        StudentInfo users[];
        try {
            Statement sm = cn.createStatement();
            ResultSet rs = sm.executeQuery("SELECT uid, first, last, email FROM Person ORDER BY " + (first_last ? "first, last" : "last, first"));
            rs.last();
            users = new StudentInfo[rs.getRow()];
            rs.first();
            do {
                StudentInfo temp = new StudentInfo();
                temp.email = rs.getString("email");
                temp.first = rs.getString("first");
                temp.last = rs.getString("last");
                temp.uid = Integer.parseInt(rs.getString("uid"));
                users[rs.getRow() - 1] = temp;
            } while (rs.next());
        } catch (SQLException e) {
            users = new StudentInfo[0];
            e.printStackTrace();
        }
        return users;
    }
----------------------------------------
    public Club[] getClubs() {
        Club clubs[];
        try {
            Statement sm = cn.createStatement();
            ResultSet rs = sm.executeQuery("SELECT club_id, name, type, rank FROM Club ORDER BY name");
            rs.last();
            clubs = new Club[rs.getRow()];
            rs.first();
            do {
                Club temp = new Club();
                temp.name = rs.getString("name");
                temp.id = Integer.parseInt(rs.getString("club_id"));
                temp.rank = rs.getString("rank");
                temp.type = rs.getString("type");
                clubs[rs.getRow() - 1] = temp;
            } while (rs.next());
        } catch (SQLException e) {
            clubs = new Club[0];
            e.printStackTrace();
        }
        return clubs;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44208.java,648,665
default,6320.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90330.java,487,504
default,90330.java,506,523
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90330.java,325,338
default,8952.java,440,452
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,9693.java,349,379
default,108541.java,349,379
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,476,485
default,90330.java,340,349
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12148.java,149,157
default,28707.java,149,157
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126614.java,346,377
default,51702.java,346,377
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,102948.java,379,383
default,89968.java,379,383
----------------------------------------
    private void applyUIDSuffix(Dataset ds) {
        ds.putUI(Tags.StudyInstanceUID, ds.getString(Tags.StudyInstanceUID, "") + uidSuffix);
        ds.putUI(Tags.SeriesInstanceUID, ds.getString(Tags.SeriesInstanceUID, "") + uidSuffix);
        ds.putUI(Tags.SOPInstanceUID, ds.getString(Tags.SOPInstanceUID, "") + uidSuffix);
    }
----------------------------------------
    private void applyUIDSuffix(Dataset ds) {
        ds.putUI(Tags.StudyInstanceUID, ds.getString(Tags.StudyInstanceUID, "") + uidSuffix);
        ds.putUI(Tags.SeriesInstanceUID, ds.getString(Tags.SeriesInstanceUID, "") + uidSuffix);
        ds.putUI(Tags.SOPInstanceUID, ds.getString(Tags.SOPInstanceUID, "") + uidSuffix);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,84530.java,183,197
default,32245.java,183,197
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40123.java,126,138
default,102156.java,126,138
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49795.java,63,67
default,41888.java,63,67
----------------------------------------
    public String[] tokenize(String s) {
        if (s == null) return null;
        List l = tokenize(s, new LinkedList());
        return (String[]) l.toArray(new String[l.size()]);
    }
----------------------------------------
    public String[] tokenize(String s) {
        if (s == null) return null;
        List l = tokenize(s, new LinkedList());
        return (String[]) l.toArray(new String[l.size()]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,111151.java,27,46
default,29717.java,27,46
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19968.java,254,285
default,75592.java,254,285
----------------------------------------
    private void examineFiles(File a, File b) {
        filesAreIdentical = true;
        filesAreBinary = false;
        if (a == null || b == null) filesAreIdentical = false; else if (a.length() != b.length()) filesAreIdentical = false;
        Reader inA = null, inB = null;
        try {
            if (a != null) inA = new BufferedReader(new FileReader(a));
            if (b != null) inB = new BufferedReader(new FileReader(b));
            int charA = -2, charB = -2;
            int count = 0;
            while (true) {
                if (inA != null && charA != -1) charA = inA.read();
                if (inB != null && charB != -1) charB = inB.read();
                if (charA != charB) filesAreIdentical = false;
                if (charA == 0 || charB == 0) {
                    filesAreBinary = true;
                    break;
                }
                if ((charA == -1 && charB == -1) || (count++ > 4096 && !filesAreIdentical)) break;
            }
        } catch (IOException ioe) {
        } finally {
            try {
                if (inA != null) inA.close();
            } catch (IOException i) {
            }
            try {
                if (inB != null) inB.close();
            } catch (IOException i) {
            }
        }
    }
----------------------------------------
    private void examineFiles(File a, File b) {
        filesAreIdentical = true;
        filesAreBinary = false;
        if (a == null || b == null) filesAreIdentical = false; else if (a.length() != b.length()) filesAreIdentical = false;
        Reader inA = null, inB = null;
        try {
            if (a != null) inA = new BufferedReader(new FileReader(a));
            if (b != null) inB = new BufferedReader(new FileReader(b));
            int charA = -2, charB = -2;
            int count = 0;
            while (true) {
                if (inA != null && charA != -1) charA = inA.read();
                if (inB != null && charB != -1) charB = inB.read();
                if (charA != charB) filesAreIdentical = false;
                if (charA == 0 || charB == 0) {
                    filesAreBinary = true;
                    break;
                }
                if ((charA == -1 && charB == -1) || (count++ > 4096 && !filesAreIdentical)) break;
            }
        } catch (IOException ioe) {
        } finally {
            try {
                if (inA != null) inA.close();
            } catch (IOException i) {
            }
            try {
                if (inB != null) inB.close();
            } catch (IOException i) {
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,100919.java,73,82
default,56146.java,64,71
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,100919.java,73,82
default,17076.java,73,82
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,74245.java,536,547
default,96072.java,536,547
----------------------------------------
    private void initOverwrite(Configuration cfg) {
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("set.")) {
                try {
                    overwrite.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal entry in dcmsnd.cfg - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
    }
----------------------------------------
    private void initOverwrite(Configuration cfg) {
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("set.")) {
                try {
                    overwrite.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal entry in dcmsnd.cfg - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4537.java,503,507
default,53763.java,512,516
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70088.java,631,648
default,8952.java,570,590
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28899.java,543,569
default,26124.java,543,569
----------------------------------------
    private void initOverwrite(Configuration config) {
        SortedMap cfg = new TreeMap(config);
        LinkedHashMap list = new LinkedHashMap();
        for (Iterator it = cfg.keySet().iterator(); it.hasNext(); ) {
            String key = (String) it.next();
            if (key.startsWith("set.")) {
                String[] split = key.split("[.]");
                int subKey = Integer.parseInt(split[1]);
                int tag = Tags.forName(split[2]);
                if (subKey == 0) {
                    overwrite.putXX(tag, (String) cfg.get(key));
                    continue;
                }
                Dataset ds = (Dataset) list.get("" + (subKey - 1));
                if (ds == null) {
                    ds = DcmObjectFactory.getInstance().newDataset();
                    list.put("" + (subKey - 1), ds);
                }
                try {
                    ds.putXX(tag, (String) cfg.get(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal entry in DcmGen.cfg - " + key + "=" + cfg.get(key));
                }
            }
        }
        datasets = (Dataset[]) list.values().toArray(new Dataset[0]);
    }
----------------------------------------
    private void initOverwrite(Configuration config) {
        SortedMap cfg = new TreeMap(config);
        LinkedHashMap list = new LinkedHashMap();
        for (Iterator it = cfg.keySet().iterator(); it.hasNext(); ) {
            String key = (String) it.next();
            if (key.startsWith("set.")) {
                String[] split = key.split("[.]");
                int subKey = Integer.parseInt(split[1]);
                int tag = Tags.forName(split[2]);
                if (subKey == 0) {
                    overwrite.putXX(tag, (String) cfg.get(key));
                    continue;
                }
                Dataset ds = (Dataset) list.get("" + (subKey - 1));
                if (ds == null) {
                    ds = DcmObjectFactory.getInstance().newDataset();
                    list.put("" + (subKey - 1), ds);
                }
                try {
                    ds.putXX(tag, (String) cfg.get(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal entry in DcmGen.cfg - " + key + "=" + cfg.get(key));
                }
            }
        }
        datasets = (Dataset[]) list.values().toArray(new Dataset[0]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76337.java,149,157
default,100171.java,149,157
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,60222.java,470,488
default,28859.java,513,531
----------------------------------------
    private final void initAssocParam(Configuration cfg, DcmURL url, boolean echo) {
        acTimeout = Integer.parseInt(cfg.getProperty("ac-timeout", "5000"));
        dimseTimeout = Integer.parseInt(cfg.getProperty("dimse-timeout", "0"));
        soCloseDelay = Integer.parseInt(cfg.getProperty("so-close-delay", "500"));
        assocRQ.setCalledAET(url.getCalledAET());
        assocRQ.setCallingAET(url.getCallingAET());
        assocRQ.setMaxPDULength(Integer.parseInt(cfg.getProperty("max-pdu-len", "16352")));
        assocRQ.setAsyncOpsWindow(aFact.newAsyncOpsWindow(Integer.parseInt(cfg.getProperty("max-op-invoked", "0")), 1));
        if (echo) {
            assocRQ.addPresContext(aFact.newPresContext(PCID_ECHO, UIDs.Verification, DEF_TS));
            return;
        }
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("pc.")) {
                initPresContext(Integer.parseInt(key.substring(3)), cfg.tokenize(cfg.getProperty(key), new LinkedList()));
            }
        }
    }
----------------------------------------
    private final void initAssocParam(Configuration cfg, DcmURL url, boolean echo) {
        acTimeout = Integer.parseInt(cfg.getProperty("ac-timeout", "5000"));
        dimseTimeout = Integer.parseInt(cfg.getProperty("dimse-timeout", "0"));
        soCloseDelay = Integer.parseInt(cfg.getProperty("so-close-delay", "500"));
        assocRQ.setCalledAET(url.getCalledAET());
        assocRQ.setCallingAET(maskNull(url.getCallingAET()));
        assocRQ.setMaxPDULength(Integer.parseInt(cfg.getProperty("max-pdu-len", "16352")));
        assocRQ.setAsyncOpsWindow(aFact.newAsyncOpsWindow(Integer.parseInt(cfg.getProperty("max-op-invoked", "0")), 1));
        if (echo) {
            assocRQ.addPresContext(aFact.newPresContext(PCID_ECHO, UIDs.Verification, DEF_TS));
            return;
        }
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("pc.")) {
                initPresContext(Integer.parseInt(key.substring(3)), cfg.tokenize(cfg.getProperty(key), new LinkedList()));
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35053.java,440,452
default,5621.java,440,452
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115646.java,149,157
default,63132.java,149,157
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,12038.java,20,75
default,55062.java,20,75
----------------------------------------
    public jnamed(String conffile) throws IOException, ZoneTransferException {
        FileInputStream fs;
        List ports = new ArrayList();
        List addresses = new ArrayList();
        try {
            fs = new FileInputStream(conffile);
        } catch (Exception e) {
            System.out.println("Cannot open " + conffile);
            return;
        }
        try {
            caches = new HashMap();
            znames = new HashMap();
            TSIGs = new HashMap();
            InputStreamReader isr = new InputStreamReader(fs);
            BufferedReader br = new BufferedReader(isr);
            String line = null;
            while ((line = br.readLine()) != null) {
                StringTokenizer st = new StringTokenizer(line);
                if (!st.hasMoreTokens()) continue;
                String keyword = st.nextToken();
                if (!st.hasMoreTokens()) {
                    System.out.println("Invalid line: " + line);
                    continue;
                }
                if (keyword.charAt(0) == '#') continue;
                if (keyword.equals("primary")) addPrimaryZone(st.nextToken(), st.nextToken()); else if (keyword.equals("secondary")) addSecondaryZone(st.nextToken(), st.nextToken()); else if (keyword.equals("cache")) {
                    Cache cache = new Cache(st.nextToken());
                    caches.put(new Integer(DClass.IN), cache);
                } else if (keyword.equals("key")) addTSIG(st.nextToken(), st.nextToken()); else if (keyword.equals("port")) ports.add(Integer.valueOf(st.nextToken())); else if (keyword.equals("address")) {
                    String addr = st.nextToken();
                    addresses.add(InetAddress.getByName(addr));
                } else {
                    System.out.println("unknown keyword: " + keyword);
                }
            }
            if (ports.size() == 0) ports.add(new Integer(53));
            if (addresses.size() == 0) addresses.add(null);
            Iterator iaddr = addresses.iterator();
            while (iaddr.hasNext()) {
                InetAddress addr = (InetAddress) iaddr.next();
                Iterator iport = ports.iterator();
                while (iport.hasNext()) {
                    int port = ((Integer) iport.next()).intValue();
                    String addrString;
                    addUDP(addr, port);
                    addTCP(addr, port);
                    if (addr == null) addrString = "0.0.0.0"; else addrString = addr.getHostAddress();
                    System.out.println("jnamed: listening on " + addrString + "#" + port);
                }
            }
            System.out.println("jnamed: running");
        } finally {
            fs.close();
        }
    }
----------------------------------------
    public jnamed(String conffile) throws IOException, ZoneTransferException {
        FileInputStream fs;
        List ports = new ArrayList();
        List addresses = new ArrayList();
        try {
            fs = new FileInputStream(conffile);
        } catch (Exception e) {
            System.out.println("Cannot open " + conffile);
            return;
        }
        try {
            caches = new HashMap();
            znames = new HashMap();
            TSIGs = new HashMap();
            InputStreamReader isr = new InputStreamReader(fs);
            BufferedReader br = new BufferedReader(isr);
            String line = null;
            while ((line = br.readLine()) != null) {
                StringTokenizer st = new StringTokenizer(line);
                if (!st.hasMoreTokens()) continue;
                String keyword = st.nextToken();
                if (!st.hasMoreTokens()) {
                    System.out.println("Invalid line: " + line);
                    continue;
                }
                if (keyword.charAt(0) == '#') continue;
                if (keyword.equals("primary")) addPrimaryZone(st.nextToken(), st.nextToken()); else if (keyword.equals("secondary")) addSecondaryZone(st.nextToken(), st.nextToken()); else if (keyword.equals("cache")) {
                    Cache cache = new Cache(st.nextToken());
                    caches.put(new Integer(DClass.IN), cache);
                } else if (keyword.equals("key")) addTSIG(st.nextToken(), st.nextToken()); else if (keyword.equals("port")) ports.add(Integer.valueOf(st.nextToken())); else if (keyword.equals("address")) {
                    String addr = st.nextToken();
                    addresses.add(InetAddress.getByName(addr));
                } else {
                    System.out.println("unknown keyword: " + keyword);
                }
            }
            if (ports.size() == 0) ports.add(new Integer(53));
            if (addresses.size() == 0) addresses.add(null);
            Iterator iaddr = addresses.iterator();
            while (iaddr.hasNext()) {
                InetAddress addr = (InetAddress) iaddr.next();
                Iterator iport = ports.iterator();
                while (iport.hasNext()) {
                    int port = ((Integer) iport.next()).intValue();
                    String addrString;
                    addUDP(addr, port);
                    addTCP(addr, port);
                    if (addr == null) addrString = "0.0.0.0"; else addrString = addr.getHostAddress();
                    System.out.println("jnamed: listening on " + addrString + "#" + port);
                }
            }
            System.out.println("jnamed: running");
        } finally {
            fs.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24795.java,50,61
default,95109.java,50,61
----------------------------------------
    public List tokenize(String s, List result) {
        StringTokenizer stk = new StringTokenizer(s, ", ");
        while (stk.hasMoreTokens()) {
            String tk = stk.nextToken();
            if (tk.startsWith("$")) {
                tokenize(getProperty(tk.substring(1), ""), result);
            } else {
                result.add(tk);
            }
        }
        return result;
    }
----------------------------------------
    public List tokenize(String s, List result) {
        StringTokenizer stk = new StringTokenizer(s, ", ");
        while (stk.hasMoreTokens()) {
            String tk = stk.nextToken();
            if (tk.startsWith("$")) {
                tokenize(getProperty(tk.substring(1), ""), result);
            } else {
                result.add(tk);
            }
        }
        return result;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126614.java,549,571
default,535.java,549,571
----------------------------------------
    private boolean initPollDirSrv(Configuration cfg) {
        String pollDirName = cfg.getProperty("poll-dir", "", "<none>", "");
        if (pollDirName.length() == 0) {
            return false;
        }
        pollDir = new File(pollDirName);
        if (!pollDir.isDirectory()) {
            throw new IllegalArgumentException("Not a directory - " + pollDirName);
        }
        pollPeriod = 1000L * Integer.parseInt(cfg.getProperty("poll-period", "5"));
        pollDirSrv = PollDirSrvFactory.getInstance().newPollDirSrv(this);
        pollDirSrv.setOpenRetryPeriod(1000L * Integer.parseInt(cfg.getProperty("poll-retry-open", "60")) * 1000L);
        pollDirSrv.setDeltaLastModified(1000L * Integer.parseInt(cfg.getProperty("poll-delta-last-modified", "3")));
        String doneDirName = cfg.getProperty("poll-done-dir", "", "<none>", "");
        if (doneDirName.length() != 0) {
            File doneDir = new File(doneDirName);
            if (!doneDir.isDirectory()) {
                throw new IllegalArgumentException("Not a directory - " + doneDirName);
            }
            pollDirSrv.setDoneDir(doneDir);
        }
        return true;
    }
----------------------------------------
    private boolean initPollDirSrv(Configuration cfg) {
        String pollDirName = cfg.getProperty("poll-dir", "", "<none>", "");
        if (pollDirName.length() == 0) {
            return false;
        }
        pollDir = new File(pollDirName);
        if (!pollDir.isDirectory()) {
            throw new IllegalArgumentException("Not a directory - " + pollDirName);
        }
        pollPeriod = 1000L * Integer.parseInt(cfg.getProperty("poll-period", "5"));
        pollDirSrv = PollDirSrvFactory.getInstance().newPollDirSrv(this);
        pollDirSrv.setOpenRetryPeriod(1000L * Integer.parseInt(cfg.getProperty("poll-retry-open", "60")) * 1000L);
        pollDirSrv.setDeltaLastModified(1000L * Integer.parseInt(cfg.getProperty("poll-delta-last-modified", "3")));
        String doneDirName = cfg.getProperty("poll-done-dir", "", "<none>", "");
        if (doneDirName.length() != 0) {
            File doneDir = new File(doneDirName);
            if (!doneDir.isDirectory()) {
                throw new IllegalArgumentException("Not a directory - " + doneDirName);
            }
            pollDirSrv.setDoneDir(doneDir);
        }
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40097.java,149,157
default,59549.java,149,157
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103146.java,648,665
default,24621.java,570,590
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57055.java,73,82
default,46902.java,64,71
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35737.java,236,250
default,71085.java,230,244
----------------------------------------
    private BootMap loadMap(String mainClass, String classesNeededFilename, String classpath, Debugger debugger) {
        try {
            return new BootMapExternal(this, mainClass, classesNeededFilename, classpath, debugger);
        } catch (BootMapCorruptException bme) {
            System.out.println(bme);
            bme.printStackTrace();
            System.out.println("ERROR: corrupted method map");
            return new BootMapExternal(this, debugger);
        } catch (Exception e) {
            System.out.println(e);
            e.printStackTrace();
            System.out.println("ERROR: something wrong with method map :) ");
            return new BootMapExternal(this, debugger);
        }
    }
----------------------------------------
    private BootMap loadMap(String mainClass, String classesNeededFilename, String classpath) {
        try {
            return new BootMapExternal(this, mainClass, classesNeededFilename, classpath);
        } catch (BootMapCorruptException bme) {
            System.out.println(bme);
            bme.printStackTrace();
            System.out.println("ERROR: corrupted method map");
            return new BootMapExternal(this);
        } catch (Exception e) {
            System.out.println(e);
            e.printStackTrace();
            System.out.println("ERROR: something wrong with method map :) ");
            return new BootMapExternal(this);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53567.java,113,124
default,46902.java,113,124
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,517,539
default,5621.java,570,590
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,113166.java,113,124
default,7413.java,113,124
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43887.java,504,510
default,109585.java,508,514
----------------------------------------
    private Socket newSocket(String host, int port) throws IOException, GeneralSecurityException {
        if (cipherSuites != null) {
            return tls.getSocketFactory(cipherSuites).createSocket(host, port);
        } else {
            return new Socket(host, port);
        }
    }
----------------------------------------
    private Socket newSocket(String host, int port) throws IOException, GeneralSecurityException {
        if (cipherSuites != null) {
            return tls.getSocketFactory(cipherSuites).createSocket(host, port);
        } else {
            return new Socket(host, port);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,68839.java,379,383
default,46776.java,381,385
----------------------------------------
    private void applyUIDSuffix(Dataset ds) {
        ds.putUI(Tags.StudyInstanceUID, ds.getString(Tags.StudyInstanceUID, "") + uidSuffix);
        ds.putUI(Tags.SeriesInstanceUID, ds.getString(Tags.SeriesInstanceUID, "") + uidSuffix);
        ds.putUI(Tags.SOPInstanceUID, ds.getString(Tags.SOPInstanceUID, "") + uidSuffix);
    }
----------------------------------------
    private void applyUIDSuffix(Dataset ds) {
        ds.putUI(Tags.StudyInstanceUID, ds.getString(Tags.StudyInstanceUID, "") + uidSuffix);
        ds.putUI(Tags.SeriesInstanceUID, ds.getString(Tags.SeriesInstanceUID, "") + uidSuffix);
        ds.putUI(Tags.SOPInstanceUID, ds.getString(Tags.SOPInstanceUID, "") + uidSuffix);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65413.java,260,270
default,63015.java,260,270
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103146.java,459,472
default,124843.java,440,452
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,135495.java,110,197
default,6320.java,110,197
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,31976.java,120,147
default,19731.java,105,132
----------------------------------------
    private void inlineObjectValue(String rType, String rTypeObject) {
        _insert("\n    ");
        _insert(rTypeObject);
        _insert(" object_");
        _insert(rType);
        _insert(" = (");
        _insert(rTypeObject);
        _insert(") object;\n");
        if (!rType.equals(rTypeObject)) {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(".");
            _insert(rType);
            _insert("Value();\n");
        } else {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(";\n");
        }
    }
----------------------------------------
    private void inlineObjectValue(String rType, String rTypeObject) {
        _insert("\n    ");
        _insert(rTypeObject);
        _insert(" object_");
        _insert(rType);
        _insert(" = (");
        _insert(rTypeObject);
        _insert(") object;\n");
        if (!rType.equals(rTypeObject)) {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(".");
            _insert(rType);
            _insert("Value();\n");
        } else {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(";\n");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25053.java,493,507
default,124843.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,135495.java,280,289
default,5621.java,280,289
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88856.java,330,347
default,38355.java,330,347
----------------------------------------
        private void initFile(String fileName) {
            this.tf = new File(this.cbInterface.traceFilesDir + "/" + fileName + ".trace");
            try {
                if (this.tf.exists()) {
                    this.tf.renameTo(new File(tf.getName() + ".bak"));
                } else {
                    if (!this.tf.createNewFile()) {
                        System.out.println("\tTestClient.initFile(" + fileName + ") : tf.createNewFile(): FAILED!");
                        System.exit(0);
                        return;
                    }
                }
            } catch (Exception ex) {
                System.out.println("Error initfile: = " + this.tf.getAbsolutePath());
                ex.printStackTrace();
                System.exit(0);
            }
        }
----------------------------------------
        private void initFile(String fileName) {
            this.tf = new File(this.cbInterface.traceFilesDir + "/" + fileName + ".trace");
            try {
                if (this.tf.exists()) {
                    this.tf.renameTo(new File(tf.getName() + ".bak"));
                } else {
                    if (!this.tf.createNewFile()) {
                        System.out.println("\tTestClient.initFile(" + fileName + ") : tf.createNewFile(): FAILED!");
                        System.exit(0);
                        return;
                    }
                }
            } catch (Exception ex) {
                System.out.println("Error initfile: = " + this.tf.getAbsolutePath());
                ex.printStackTrace();
                System.exit(0);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,131818.java,31,46
default,29785.java,31,46
----------------------------------------
    public static void doVersionCheck(View view, String stableBuild, String develBuild) {
        String myBuild = jEdit.getBuild();
        String pre = myBuild.substring(6, 7);
        String variant;
        String build;
        if (pre.equals("99")) {
            variant = "stable";
            build = stableBuild;
        } else {
            variant = "devel";
            build = develBuild;
        }
        if (develBuild.compareTo(stableBuild) < 0) variant += "-nodevel";
        int retVal = GUIUtilities.confirm(view, "version-check." + variant, new String[] { MiscUtilities.buildToVersion(myBuild), MiscUtilities.buildToVersion(stableBuild), MiscUtilities.buildToVersion(develBuild) }, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (retVal == JOptionPane.YES_OPTION) jEdit.openFile(view, jEdit.getProperty("version-check.url"));
    }
----------------------------------------
    public static void doVersionCheck(View view, String stableBuild, String develBuild) {
        String myBuild = jEdit.getBuild();
        String pre = myBuild.substring(6, 7);
        String variant;
        String build;
        if (pre.equals("99")) {
            variant = "stable";
            build = stableBuild;
        } else {
            variant = "devel";
            build = develBuild;
        }
        if (develBuild.compareTo(stableBuild) < 0) variant += "-nodevel";
        int retVal = GUIUtilities.confirm(view, "version-check." + variant, new String[] { MiscUtilities.buildToVersion(myBuild), MiscUtilities.buildToVersion(stableBuild), MiscUtilities.buildToVersion(develBuild) }, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (retVal == JOptionPane.YES_OPTION) jEdit.openFile(view, jEdit.getProperty("version-check.url"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,123780.java,64,71
default,104630.java,73,82
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72323.java,604,617
default,70088.java,606,619
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,75612.java,64,71
default,63132.java,73,82
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63132.java,99,111
default,100171.java,99,111
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,101935.java,612,638
default,71085.java,624,650
----------------------------------------
    private void zeroJ2NThreadCounts(int threadPointer) throws Exception {
        if (threadPointer == 0) return;
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NYieldCount");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NLockFailureCount");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NTotalYieldDuration");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NTotalLockDuration");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
    }
----------------------------------------
    private void zeroJ2NThreadCounts(int threadPointer) throws Exception {
        if (threadPointer == 0) return;
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NYieldCount");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NLockFailureCount");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NTotalYieldDuration");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
        try {
            VM_Field field = bmap.findVMField("VM_Thread", "J2NTotalLockDuration");
            mem.write(threadPointer + field.getOffset(), 0);
        } catch (BmapNotFoundException e) {
            throw new Exception("cannot find VM_Thread.threadSlot, has VM_Thread.java been changed?");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32033.java,1062,1073
default,92257.java,705,721
----------------------------------------
    public boolean validateVersion_0_3() throws Exception {
        String testRoot = TEST_Version_0_3;
        boolean test = true;
        sReferencePS.clear();
        sReferencePS.set("version_0_3", "version_0_3");
        sTestPS.load(new File(getTestFolder(), PREFIX_RESULT + testRoot + DOT + TXT));
        test = sTestPS.contains(sReferencePS) && test;
        if (!test) {
            displayPropertySets(sTestPS, sReferencePS);
        }
        return test;
    }
----------------------------------------
    public boolean validateMethodGetArgs() throws Exception {
        String testRoot = TEST_MethodGetArgs;
        boolean test = true;
        sReferencePS.clear();
        sReferencePS.set("arg0", "jsa:o=" + getWriterFolder());
        sReferencePS.set("arg1", "jsa:p=");
        sReferencePS.set("arg2", "jsa:B");
        sReferencePS.set("arg3", "ua1");
        sReferencePS.set("arg4", "u a 2");
        sReferencePS.set("arg5", "ua3");
        sTestPS.load(new File(getTestFolder(), PREFIX_RESULT + testRoot + DOT + TXT));
        test = sTestPS.equals(sReferencePS) && test;
        if (!test) {
            displayPropertySets(sTestPS, sReferencePS);
        }
        return test;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24621.java,648,665
default,45549.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,31976.java,791,819
default,106521.java,406,434
----------------------------------------
    public void writer__backup(String rFilePath, String rFileName, String rBackupFolder) throws Exception {
        File backupFolder = new File(rBackupFolder);
        if (!backupFolder.exists()) {
            if (!backupFolder.mkdir()) {
                throw new Exception(writer__UITEXT_BackupFolderColon + backupFolder + writer__UITEXT_BackupFolderExistFailure);
            }
        }
        if (!backupFolder.isDirectory()) {
            throw new Exception(writer__UITEXT_BackupFolderColon + backupFolder + writer__UITEXT_BackupFolderNotAFolder);
        }
        if (!backupFolder.canWrite()) {
            throw new Exception(writer__UITEXT_BackupFolderColon + backupFolder + writer__UITEXT_BackupFolderNotWritable);
        }
        Calendar calendar = Calendar.getInstance();
        String year_yyyy = _align(String.valueOf(calendar.get(Calendar.YEAR)), "0", 4, 'r');
        String month_mm = _align(String.valueOf((1 + calendar.get(Calendar.MONTH))), "0", 2, 'r');
        String day_dd = _align(String.valueOf(calendar.get(Calendar.DAY_OF_MONTH)), "0", 2, 'r');
        String hour_hh = _align(String.valueOf(calendar.get(Calendar.HOUR_OF_DAY)), "0", 2, 'r');
        String minute_mm = _align(String.valueOf(calendar.get(Calendar.MINUTE)), "0", 2, 'r');
        String second_ss = _align(String.valueOf(calendar.get(Calendar.SECOND)), "0", 2, 'r');
        String dateTime = year_yyyy + month_mm + day_dd + hour_hh + minute_mm + second_ss;
        String backupFileName = dateTime + writer__iBackupPrefix + rFileName + writer__iBackupSuffix;
        File backupFilePath = new File(rBackupFolder, backupFileName);
        File fileToBackup = new File(rFilePath);
        if (fileToBackup.exists()) {
            String fileContents = writer__read(rFilePath);
            writer__save(backupFilePath.getPath(), fileContents);
        }
    }
----------------------------------------
    public void writer__backup(String rFilePath, String rFileName, String rBackupFolder) throws Exception {
        File backupFolder = new File(rBackupFolder);
        if (!backupFolder.exists()) {
            if (!backupFolder.mkdir()) {
                throw new Exception(writer__UITEXT_BackupFolderColon + backupFolder + writer__UITEXT_BackupFolderExistFailure);
            }
        }
        if (!backupFolder.isDirectory()) {
            throw new Exception(writer__UITEXT_BackupFolderColon + backupFolder + writer__UITEXT_BackupFolderNotAFolder);
        }
        if (!backupFolder.canWrite()) {
            throw new Exception(writer__UITEXT_BackupFolderColon + backupFolder + writer__UITEXT_BackupFolderNotWritable);
        }
        Calendar calendar = Calendar.getInstance();
        String year_yyyy = _align(String.valueOf(calendar.get(Calendar.YEAR)), "0", 4, 'r');
        String month_mm = _align(String.valueOf((1 + calendar.get(Calendar.MONTH))), "0", 2, 'r');
        String day_dd = _align(String.valueOf(calendar.get(Calendar.DAY_OF_MONTH)), "0", 2, 'r');
        String hour_hh = _align(String.valueOf(calendar.get(Calendar.HOUR_OF_DAY)), "0", 2, 'r');
        String minute_mm = _align(String.valueOf(calendar.get(Calendar.MINUTE)), "0", 2, 'r');
        String second_ss = _align(String.valueOf(calendar.get(Calendar.SECOND)), "0", 2, 'r');
        String dateTime = year_yyyy + month_mm + day_dd + hour_hh + minute_mm + second_ss;
        String backupFileName = dateTime + writer__iBackupPrefix + rFileName + writer__iBackupSuffix;
        File backupFilePath = new File(rBackupFolder, backupFileName);
        File fileToBackup = new File(rFilePath);
        if (fileToBackup.exists()) {
            String fileContents = writer__read(rFilePath);
            writer__save(backupFilePath.getPath(), fileContents);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,84782.java,118,124
default,99553.java,118,124
----------------------------------------
    private static void addContentDateTime(Dataset ds) {
        if (!ds.contains(Tags.ContentDate)) {
            Date now = new Date();
            ds.putDA(Tags.ContentDate, now);
            ds.putTM(Tags.ContentTime, now);
        } else if (!ds.contains(Tags.ContentTime)) ds.putTM(Tags.ContentTime);
    }
----------------------------------------
    private static void addContentDateTime(Dataset ds) {
        if (!ds.contains(Tags.ContentDate)) {
            Date now = new Date();
            ds.putDA(Tags.ContentDate, now);
            ds.putTM(Tags.ContentTime, now);
        } else if (!ds.contains(Tags.ContentTime)) ds.putTM(Tags.ContentTime);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6320.java,260,270
default,86322.java,260,270
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,84501.java,676,685
default,25052.java,567,576
----------------------------------------
    public String _getProperty(String rName) {
        String result = "";
        if (!writer__iPropertiesInitialised) {
            writer__initProperties();
        }
        if (writer__iProperties.containsKey(rName)) {
            result = (String) writer__iProperties.get(rName);
        }
        return result;
    }
----------------------------------------
    public String _getProperty(String rName) {
        String result = "";
        if (!writer__iPropertiesInitialised) {
            writer__initProperties();
        }
        if (writer__iProperties.containsKey(rName)) {
            result = (String) writer__iProperties.get(rName);
        }
        return result;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32033.java,772,785
default,92257.java,1047,1060
----------------------------------------
    public boolean validateMethodGetThirdUserArg() throws Exception {
        String testRoot = TEST_MethodGetThirdUserArg;
        boolean test = true;
        sReferencePS.clear();
        sReferencePS.set("ua1", "ua1");
        sReferencePS.set("ua2", "ua2");
        sReferencePS.set("ua3", "ua3");
        sTestPS.load(new File(getTestFolder(), PREFIX_RESULT + testRoot + DOT + TXT));
        test = sTestPS.equals(sReferencePS) && test;
        if (!test) {
            displayPropertySets(sTestPS, sReferencePS);
        }
        return test;
    }
----------------------------------------
    public boolean validateVersion_0_2() throws Exception {
        String testRoot = TEST_Version_0_2;
        boolean test = true;
        sReferencePS.clear();
        sReferencePS.set("body", "bodyCheck");
        sReferencePS.set("init", "initCheck");
        sReferencePS.set("declare", "declareCheck");
        sTestPS.load(new File(getTestFolder(), PREFIX_RESULT + testRoot + DOT + TXT));
        test = sTestPS.contains(sReferencePS) && test;
        if (!test) {
            displayPropertySets(sTestPS, sReferencePS);
        }
        return test;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,10101.java,913,947
default,25052.java,739,773
----------------------------------------
    public String _align(String rText, String rBackText, int rColWidth, char rAlignment) {
        String result = rText;
        if (null == rText) {
            result = "";
        } else if (null != rBackText) {
            try {
                int textLen = rText.length();
                if (rColWidth > textLen) {
                    int backTextLen = rBackText.length();
                    int remainWidth = rColWidth - textLen;
                    int backTextRepeats = remainWidth / backTextLen;
                    int backTextRemain = remainWidth % backTextLen;
                    String back = "";
                    for (int backTextI = 0; backTextI < backTextRepeats; backTextI++) {
                        back = back + rBackText;
                    }
                    back = back + rBackText.substring(0, backTextRemain);
                    switch(rAlignment) {
                        case 'l':
                            result = result + back;
                            break;
                        case 'c':
                            result = back.substring(0, (back.length() / 2)) + result + back.substring((back.length() / 2));
                            break;
                        case 'r':
                            result = back + result;
                            break;
                    }
                }
            } catch (Exception e) {
                result = rText;
            }
        }
        return result;
    }
----------------------------------------
    public String _align(String rText, String rBackText, int rColWidth, char rAlignment) {
        String result = rText;
        if (null == rText) {
            result = "";
        } else if (null != rBackText) {
            try {
                int textLen = rText.length();
                if (rColWidth > textLen) {
                    int backTextLen = rBackText.length();
                    int remainWidth = rColWidth - textLen;
                    int backTextRepeats = remainWidth / backTextLen;
                    int backTextRemain = remainWidth % backTextLen;
                    String back = "";
                    for (int backTextI = 0; backTextI < backTextRepeats; backTextI++) {
                        back = back + rBackText;
                    }
                    back = back + rBackText.substring(0, backTextRemain);
                    switch(rAlignment) {
                        case 'l':
                            result = result + back;
                            break;
                        case 'c':
                            result = back.substring(0, (back.length() / 2)) + result + back.substring((back.length() / 2));
                            break;
                        case 'r':
                            result = back + result;
                            break;
                    }
                }
            } catch (Exception e) {
                result = rText;
            }
        }
        return result;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32033.java,851,866
default,32033.java,1003,1014
----------------------------------------
    public boolean validateMethodLeft() throws Exception {
        String testRoot = TEST_MethodLeft;
        boolean test = true;
        sReferencePS.clear();
        sReferencePS.set("a", "[a]");
        sReferencePS.set("b", "[a  ]");
        sReferencePS.set("c", "[aa ]");
        sReferencePS.set("d", "[aaa]");
        sReferencePS.set("e", "[aaaa]");
        sTestPS.load(new File(getTestFolder(), PREFIX_RESULT + testRoot + DOT + TXT));
        test = sTestPS.equals(sReferencePS) && test;
        if (!test) {
            displayPropertySets(sTestPS, sReferencePS);
        }
        return test;
    }
----------------------------------------
    public boolean validateBackup() throws Exception {
        String testRoot = TEST_Backup;
        boolean test = true;
        sReferencePS.clear();
        sReferencePS.set("backup", "done");
        sTestPS.load(new File(getTestFolder(), PREFIX_RESULT + testRoot + DOT + TXT));
        test = sTestPS.contains(sReferencePS) && test;
        if (!test) {
            displayPropertySets(sTestPS, sReferencePS);
        }
        return test;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72323.java,546,568
default,8952.java,546,568
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63015.java,442,454
default,820.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53104.java,367,379
default,86322.java,367,379
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,548,570
default,820.java,522,544
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6320.java,629,646
default,86322.java,522,544
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,134632.java,183,197
default,19995.java,183,197
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,135495.java,619,627
default,70088.java,621,629
----------------------------------------
    private int doPurge(DirWriter w) throws IOException {
        int[] counter = { 0 };
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeStudy(w, rec, counter)) {
                counter[0] += w.remove(rec);
            }
        }
        return counter[0];
    }
----------------------------------------
    private int doPurge(DirWriter w) throws IOException {
        int[] counter = { 0 };
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeStudy(w, rec, counter)) {
                counter[0] += w.remove(rec);
            }
        }
        return counter[0];
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,135495.java,629,646
default,103762.java,522,544
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56216.java,629,646
default,820.java,629,646
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,524,546
default,57585.java,541,563
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98684.java,335,349
default,56216.java,335,349
----------------------------------------
    public void create(String[] args, int off) throws IOException {
        if (uid == null || uid.length() == 0) {
            uid = UIDGenerator.getInstance().createUID();
        }
        File rootDir = dirFile.getParentFile();
        if (rootDir != null && !rootDir.exists()) {
            rootDir.mkdirs();
        }
        DirWriter writer = fact.newDirWriter(dirFile, uid, id, readMeFile, readMeCharset, encodeParam());
        try {
            build(writer, args, off);
        } finally {
            writer.close();
        }
    }
----------------------------------------
    public void create(String[] args, int off) throws IOException {
        if (uid == null || uid.length() == 0) {
            uid = UIDGenerator.getInstance().createUID();
        }
        File rootDir = dirFile.getParentFile();
        if (rootDir != null && !rootDir.exists()) {
            rootDir.mkdirs();
        }
        DirWriter writer = fact.newDirWriter(dirFile, uid, id, readMeFile, readMeCharset, encodeParam());
        try {
            build(writer, args, off);
        } finally {
            writer.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55062.java,452,461
default,18032.java,463,472
----------------------------------------
    public void addTCP(final InetAddress addr, final int port) {
        Thread t;
        t = new Thread(new Runnable() {

            public void run() {
                serveTCP(addr, port);
            }
        });
        t.start();
    }
----------------------------------------
    public void addUDP(final InetAddress addr, final int port) {
        Thread t;
        t = new Thread(new Runnable() {

            public void run() {
                serveUDP(addr, port);
            }
        });
        t.start();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24621.java,367,379
default,98684.java,367,379
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126019.java,529,542
default,50898.java,476,489
----------------------------------------
    public void _setFileNameRoots(String[] rFileNameRoots) {
        if (null == rFileNameRoots) {
            return;
        }
        String[] roots = (String[]) rFileNameRoots.clone();
        int numRoots = roots.length;
        for (int rootI = 0; rootI < numRoots; rootI++) {
            if (null == roots[rootI]) {
                roots[rootI] = "";
            }
        }
        writer__iFileNameRoots = roots;
        writer__iNumFiles = numRoots;
    }
----------------------------------------
    public void _setFileNameRoots(String[] rFileNameRoots) {
        if (null == rFileNameRoots) {
            return;
        }
        String[] roots = (String[]) rFileNameRoots.clone();
        int numRoots = roots.length;
        for (int rootI = 0; rootI < numRoots; rootI++) {
            if (null == roots[rootI]) {
                roots[rootI] = "";
            }
        }
        writer__iFileNameRoots = roots;
        writer__iNumFiles = numRoots;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63015.java,669,687
default,56216.java,667,685
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90330.java,311,323
default,98684.java,440,452
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25053.java,705,713
default,820.java,705,713
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) {
            System.err.println(prompt);
        }
        if (error) {
            System.err.println(messages.getString("try"));
        }
        System.exit(1);
    }
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) {
            System.err.println(prompt);
        }
        if (error) {
            System.err.println(messages.getString("try"));
        }
        System.exit(1);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49591.java,117,131
default,14407.java,117,131
----------------------------------------
    File createJar(String name, String... entries) throws IOException {
        File jar = new File(name);
        OutputStream out = new FileOutputStream(jar);
        try {
            JarOutputStream jos = new JarOutputStream(out);
            for (String e : entries) {
                jos.putNextEntry(new ZipEntry(e));
                jos.write(e.getBytes());
            }
            jos.close();
        } finally {
            out.close();
        }
        return jar;
    }
----------------------------------------
    File createJar(String name, String... entries) throws IOException {
        File jar = new File(name);
        OutputStream out = new FileOutputStream(jar);
        try {
            JarOutputStream jos = new JarOutputStream(out);
            for (String e : entries) {
                jos.putNextEntry(new ZipEntry(e));
                jos.write(e.getBytes());
            }
            jos.close();
        } finally {
            out.close();
        }
        return jar;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16697.java,105,116
default,63929.java,105,116
----------------------------------------
    private static void addUIDs(Dataset ds) {
        UIDGenerator uidgen = UIDGenerator.getInstance();
        if (!ds.contains(Tags.StudyInstanceUID)) {
            ds.putUI(Tags.StudyInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SeriesInstanceUID)) {
            ds.putUI(Tags.SeriesInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SOPInstanceUID)) {
            ds.putUI(Tags.SOPInstanceUID, uidgen.createUID());
        }
    }
----------------------------------------
    private static void addUIDs(Dataset ds) {
        UIDGenerator uidgen = UIDGenerator.getInstance();
        if (!ds.contains(Tags.StudyInstanceUID)) {
            ds.putUI(Tags.StudyInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SeriesInstanceUID)) {
            ds.putUI(Tags.SeriesInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SOPInstanceUID)) {
            ds.putUI(Tags.SOPInstanceUID, uidgen.createUID());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,69172.java,11,28
default,110306.java,11,28
----------------------------------------
    public static void main(String argv[]) throws Exception {
        if (argv.length == 0) {
            printUsage();
            return;
        }
        for (int iArg = 0; iArg < argv.length; iArg++) {
            String arg = argv[iArg];
            if (arg.startsWith("-h")) {
                printUsage();
                return;
            }
            System.out.println("**** START OF EXECUTION of " + arg + "." + methodToRun + " " + signatureToPrintOut + " ****.");
            Class klass = Class.forName(arg);
            Method method = klass.getDeclaredMethod(methodToRun, noparams);
            Object result = method.invoke(null, noparams);
            System.out.println("**** RESULT: " + result);
        }
    }
----------------------------------------
    public static void main(String argv[]) throws Exception {
        if (argv.length == 0) {
            printUsage();
            return;
        }
        for (int iArg = 0; iArg < argv.length; iArg++) {
            String arg = argv[iArg];
            if (arg.startsWith("-h")) {
                printUsage();
                return;
            }
            System.out.println("**** START OF EXECUTION of " + arg + "." + methodToRun + " " + signatureToPrintOut + " ****.");
            Class klass = Class.forName(arg);
            Method method = klass.getDeclaredMethod(methodToRun, noparams);
            Object result = method.invoke(null, (Object[]) noparams);
            System.out.println("**** RESULT: " + result);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90320.java,56,63
default,57585.java,196,203
----------------------------------------
    private static void add(Configuration cfg, String s) {
        int pos = s.indexOf('=');
        if (pos == -1) {
            cfg.put(s, "");
        } else {
            cfg.put(s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63015.java,260,270
default,42612.java,297,306
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16429.java,96,103
default,14153.java,91,98
----------------------------------------
    public Cache getCache(int dclass) {
        Cache c = (Cache) caches.get(new Integer(dclass));
        if (c == null) {
            c = new Cache(dclass);
            caches.put(new Integer(dclass), c);
        }
        return c;
    }
----------------------------------------
    public Cache getCache(int dclass) {
        Cache c = (Cache) caches.get(new Integer(dclass));
        if (c == null) {
            c = new Cache(dclass);
            caches.put(new Integer(dclass), c);
        }
        return c;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,89284.java,113,124
default,14153.java,100,111
----------------------------------------
    public Zone findBestZone(Name name) {
        Zone foundzone = null;
        foundzone = (Zone) znames.get(name);
        if (foundzone != null) return foundzone;
        int labels = name.labels();
        for (int i = 1; i < labels; i++) {
            Name tname = new Name(name, i);
            foundzone = (Zone) znames.get(tname);
            if (foundzone != null) return foundzone;
        }
        return null;
    }
----------------------------------------
    public Zone findBestZone(Name name) {
        Zone foundzone = null;
        foundzone = (Zone) znames.get(name);
        if (foundzone != null) return foundzone;
        int labels = name.labels();
        for (int i = 1; i < labels; i++) {
            Name tname = new Name(name, i);
            foundzone = (Zone) znames.get(tname);
            if (foundzone != null) return foundzone;
        }
        return null;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,335,349
default,42612.java,335,349
----------------------------------------
    public void create(String[] args, int off) throws IOException {
        if (uid == null || uid.length() == 0) {
            uid = UIDGenerator.getInstance().createUID();
        }
        File rootDir = dirFile.getParentFile();
        if (rootDir != null && !rootDir.exists()) {
            rootDir.mkdirs();
        }
        DirWriter writer = fact.newDirWriter(dirFile, uid, id, readMeFile, readMeCharset, encodeParam());
        try {
            build(writer, args, off);
        } finally {
            writer.close();
        }
    }
----------------------------------------
    public void create(String[] args, int off) throws IOException {
        if (uid == null || uid.length() == 0) {
            uid = UIDGenerator.getInstance().createUID();
        }
        File rootDir = dirFile.getParentFile();
        if (rootDir != null && !rootDir.exists()) {
            rootDir.mkdirs();
        }
        DirWriter writer = fact.newDirWriter(dirFile, uid, id, readMeFile, readMeCharset, encodeParam());
        try {
            build(writer, args, off);
        } finally {
            writer.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,123634.java,19,34
default,78674.java,19,34
----------------------------------------
    public void testPalindrome() {
        assertFalse(isPalindrome("abcdef"));
        assertFalse(isPalindrome("abccda"));
        assertTrue(isPalindrome("abccba"));
        assertFalse(isPalindrome("abcxba"));
        assertTrue(isPalindrome("a"));
        assertTrue(isPalindrome("aa"));
        assertFalse(isPalindrome("ab"));
        assertTrue(isPalindrome(""));
        assertTrue(isPalindrome("aaa"));
        assertTrue(isPalindrome("aba"));
        assertTrue(isPalindrome("abbba"));
        assertTrue(isPalindrome("abba"));
        assertFalse(isPalindrome("abbaa"));
        assertFalse(isPalindrome("abcda"));
    }
----------------------------------------
    public void testPalindrome() {
        assertFalse(isPalindrome("abcdef"));
        assertFalse(isPalindrome("abccda"));
        assertTrue(isPalindrome("abccba"));
        assertFalse(isPalindrome("abcxba"));
        assertTrue(isPalindrome("a"));
        assertTrue(isPalindrome("aa"));
        assertFalse(isPalindrome("ab"));
        assertTrue(isPalindrome(""));
        assertTrue(isPalindrome("aaa"));
        assertTrue(isPalindrome("aba"));
        assertTrue(isPalindrome("abbba"));
        assertTrue(isPalindrome("abba"));
        assertFalse(isPalindrome("abbaa"));
        assertFalse(isPalindrome("abcda"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,116906.java,199,206
default,45025.java,126,133
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void set(Configuration cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("set." + s, "");
        } else {
            cfg.put("set." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79079.java,135,182
default,45025.java,135,182
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmsnd", args, "", LONG_OPTS);
        Configuration cfg = new Configuration(DcmSnd.class.getResource("dcmsnd.cfg"));
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 'P':
                    cfg.put("prior", "1");
                    break;
                case 'p':
                    cfg.put("prior", "2");
                    break;
                case 'k':
                    cfg.put("pack-pdvs", "true");
                    break;
                case 't':
                    cfg.put("trunc-post-pixeldata", "true");
                    break;
                case 'x':
                    cfg.put("exclude-private", "true");
                    break;
                case 's':
                    set(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmSnd dcmsnd = new DcmSnd(cfg, new DcmURL(args[optind]), argc);
            dcmsnd.execute(args, optind + 1);
        } catch (IllegalArgumentException e) {
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,127822.java,11,104
default,24905.java,11,104
----------------------------------------
    public static void main(String[] args) {
        if (args.length < 3) {
            System.err.println("CreateSyntheticGenome was not called properly. It should be called as:");
            System.err.println("\tjava CreateSyntheticGenome fasta_input_file slo_output_file mutations_file [read_length]");
        }
        String inputFile = args[0];
        String outputFile = args[1];
        String mutationFile = args[2];
        int readLength = 36;
        if (args.length > 3) {
            readLength = Integer.parseInt(args[3]);
        }
        int numberOfMutations = fileLineLength(mutationFile);
        HashMap[] mutationArray = new HashMap[numberOfMutations];
        populateMutationHash(mutationFile, mutationArray);
        for (int i = 1; i < mutationArray.length; i++) {
            String mLen1 = mutationArray[i - 1].get("mutation").toString();
            int mPos1 = Integer.parseInt(mutationArray[i - 1].get("position").toString());
            int mPos2 = Integer.parseInt(mutationArray[i].get("position").toString());
            if (mPos1 + readLength + mLen1.length() >= mPos2 - readLength) {
                System.err.println("ERROR: Mutation position + length of mutation must be more than readLength (" + readLength + ") bases apart from the next mutation position minus readLength.");
                System.err.println(mPos2 + " is too close to " + mPos1);
                System.exit(-1);
            }
        }
        Sequence fastaSequence = prepareFastaRead(inputFile);
        BufferedWriter out = null;
        try {
            out = new BufferedWriter(new FileWriter(outputFile));
        } catch (IOException e) {
            System.exit(-1);
        }
        try {
            out.write("#QuerySequenceID\tQuerySeq\tTargetLocation\tTargetStrand\tTargetSequence\tQueryQualityScore\tQueryPrefixTags\tQuerySuffixTags\tMultiReads\tReadNum\tQueryUnconvertedCsFirstRead\tQueryUnconvertedCsSecondRead\n");
        } catch (IOException e) {
            System.exit(-1);
        }
        for (int i = 0; i < mutationArray.length; i++) {
            int mPosition = Integer.parseInt(mutationArray[i].get("position").toString());
            String mType = mutationArray[i].get("type").toString();
            String mOriginal = mutationArray[i].get("original").toString();
            String mMutation = mutationArray[i].get("mutation").toString();
            int readOffset = mPosition - readLength;
            int totalReadLength = 2 * readLength - 1;
            if (readOffset < 0) {
                totalReadLength += readOffset;
                readOffset = 0;
            }
            String seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
            seqRead = seqRead.toUpperCase();
            String referenceSeq = seqRead;
            String mutatedSeq = seqRead;
            int changePos = totalReadLength - readLength;
            if (mType.equals("i")) {
            } else if ((mType.equals("v") || mType.equals("d")) && mOriginal.equals(seqRead.substring(changePos, changePos + mOriginal.length()))) {
                if (mType.equals("v")) {
                    mutatedSeq = seqRead.substring(0, changePos) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                } else if (mType.equals("d")) {
                    totalReadLength += mMutation.length() - 1;
                    seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
                    seqRead = seqRead.toUpperCase();
                    referenceSeq = seqRead;
                    mutatedSeq = seqRead.substring(0, changePos) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                } else if (mType.equals("i")) {
                    totalReadLength += mMutation.length() - 1;
                    seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
                    seqRead = seqRead.toUpperCase();
                    mutatedSeq = seqRead.substring(1, changePos + 1) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                    referenceSeq = seqRead.substring(1, changePos + 1) + mOriginal + seqRead.substring(changePos + 1, totalReadLength);
                    readOffset++;
                } else {
                    System.err.println("Something is wrong, mType came up as " + mType + ".");
                    System.exit(1);
                }
            } else {
                System.err.println("Something is wrong. The mutation was supposed to change a \'" + mOriginal + "\' but instead, that position is a \'" + seqRead.substring(changePos, changePos + 1) + "\'.");
                System.exit(1);
            }
            for (int j = 0; j <= totalReadLength - readLength; j++) {
                try {
                    out.write("1:1:1:" + ((i + 1) * 1000 + j) + "\t" + mutatedSeq.substring(j, j + readLength) + "\tchr22:" + (readOffset + j) + "\tF\t" + referenceSeq.substring(j, j + readLength) + "\t0" + "\n");
                    out.write("1:1:1:" + ((i + 1) * 1000 + j) + "\t" + mutatedSeq.substring(j, j + readLength) + "\tchr22:" + (readOffset + j) + "\tR\t" + reverseString(referenceSeq.substring(j, j + readLength)) + "\t0" + "\n");
                } catch (IOException e) {
                    System.exit(-1);
                }
            }
        }
        try {
            out.close();
        } catch (IOException e) {
            System.exit(-1);
        }
        System.exit(0);
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length < 3) {
            System.err.println("CreateSyntheticGenome was not called properly. It should be called as:");
            System.err.println("\tjava CreateSyntheticGenome fasta_input_file slo_output_file mutations_file [read_length]");
        }
        String inputFile = args[0];
        String outputFile = args[1];
        String mutationFile = args[2];
        int readLength = 36;
        if (args.length > 3) {
            readLength = Integer.parseInt(args[3]);
        }
        int numberOfMutations = fileLineLength(mutationFile);
        HashMap[] mutationArray = new HashMap[numberOfMutations];
        populateMutationHash(mutationFile, mutationArray);
        for (int i = 1; i < mutationArray.length; i++) {
            String mLen1 = mutationArray[i - 1].get("mutation").toString();
            int mPos1 = Integer.parseInt(mutationArray[i - 1].get("position").toString());
            int mPos2 = Integer.parseInt(mutationArray[i].get("position").toString());
            if (mPos1 + readLength + mLen1.length() >= mPos2 - readLength) {
                System.err.println("ERROR: Mutation position + length of mutation must be more than readLength (" + readLength + ") bases apart from the next mutation position minus readLength.");
                System.err.println(mPos2 + " is too close to " + mPos1);
                System.exit(-1);
            }
        }
        Sequence fastaSequence = prepareFastaRead(inputFile);
        BufferedWriter out = null;
        try {
            out = new BufferedWriter(new FileWriter(outputFile));
        } catch (IOException e) {
            System.exit(-1);
        }
        try {
            out.write("#QuerySequenceID\tQuerySeq\tTargetLocation\tTargetStrand\tTargetSequence\tQueryQualityScore\tQueryPrefixTags\tQuerySuffixTags\tMultiReads\tReadNum\tQueryUnconvertedCsFirstRead\tQueryUnconvertedCsSecondRead\n");
        } catch (IOException e) {
            System.exit(-1);
        }
        for (int i = 0; i < mutationArray.length; i++) {
            int mPosition = Integer.parseInt(mutationArray[i].get("position").toString());
            String mType = mutationArray[i].get("type").toString();
            String mOriginal = mutationArray[i].get("original").toString();
            String mMutation = mutationArray[i].get("mutation").toString();
            int readOffset = mPosition - readLength;
            int totalReadLength = 2 * readLength - 1;
            if (readOffset < 0) {
                totalReadLength += readOffset;
                readOffset = 0;
            }
            String seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
            seqRead = seqRead.toUpperCase();
            String referenceSeq = seqRead;
            String mutatedSeq = seqRead;
            int changePos = totalReadLength - readLength;
            if (mType.equals("i")) {
            } else if ((mType.equals("v") || mType.equals("d")) && mOriginal.equals(seqRead.substring(changePos, changePos + mOriginal.length()))) {
                if (mType.equals("v")) {
                    mutatedSeq = seqRead.substring(0, changePos) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                } else if (mType.equals("d")) {
                    totalReadLength += mMutation.length() - 1;
                    seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
                    seqRead = seqRead.toUpperCase();
                    referenceSeq = seqRead;
                    mutatedSeq = seqRead.substring(0, changePos) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                } else if (mType.equals("i")) {
                    totalReadLength += mMutation.length() - 1;
                    seqRead = fastaSequence.subStr(readOffset + 1, readOffset + totalReadLength);
                    seqRead = seqRead.toUpperCase();
                    mutatedSeq = seqRead.substring(1, changePos + 1) + mMutation + seqRead.substring(changePos + 1, totalReadLength);
                    referenceSeq = seqRead.substring(1, changePos + 1) + mOriginal + seqRead.substring(changePos + 1, totalReadLength);
                    readOffset++;
                } else {
                    System.err.println("Something is wrong, mType came up as " + mType + ".");
                    System.exit(1);
                }
            } else {
                System.err.println("Something is wrong. The mutation was supposed to change a \'" + mOriginal + "\' but instead, that position is a \'" + seqRead.substring(changePos, changePos + 1) + "\'.");
                System.exit(1);
            }
            for (int j = 0; j <= totalReadLength - readLength; j++) {
                try {
                    out.write("1:1:1:" + ((i + 1) * 1000 + j) + "\t" + mutatedSeq.substring(j, j + readLength) + "\tchr22:" + (readOffset + j) + "\tF\t" + referenceSeq.substring(j, j + readLength) + "\t0" + "\n");
                    out.write("1:1:1:" + ((i + 1) * 1000 + j) + "\t" + mutatedSeq.substring(j, j + readLength) + "\tchr22:" + (readOffset + j) + "\tR\t" + reverseString(referenceSeq.substring(j, j + readLength)) + "\t0" + "\n");
                } catch (IOException e) {
                    System.exit(-1);
                }
            }
        }
        try {
            out.close();
        } catch (IOException e) {
            System.exit(-1);
        }
        System.exit(0);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,522,544
default,35053.java,522,544
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132272.java,488,494
default,109585.java,508,514
----------------------------------------
    private Socket newSocket(String host, int port) throws IOException, GeneralSecurityException {
        if (cipherSuites != null) {
            return tls.getSocketFactory(cipherSuites).createSocket(host, port);
        } else {
            return new Socket(host, port);
        }
    }
----------------------------------------
    private Socket newSocket(String host, int port) throws IOException, GeneralSecurityException {
        if (cipherSuites != null) {
            return tls.getSocketFactory(cipherSuites).createSocket(host, port);
        } else {
            return new Socket(host, port);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,29754.java,715,722
default,45072.java,1292,1299
----------------------------------------
    private synchronized void VerticalDivBar(PrintWriter out) {
        out.println("<td valign=\"top\" bgcolor=\"000099\" width=2 height=\"100%\">");
        out.println("<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\"width=\"100%\" height=\"100%\">");
        out.println("<td valign=\"top\" bgcolor=\"000099\" width=0 height=\"100%\">");
        out.println("</td>");
        out.println("</table>");
        out.println("</td>");
    }
----------------------------------------
    private synchronized void VerticalDivBar(PrintWriter out) {
        out.println("<td valign=\"top\" bgcolor=\"000099\" width=2 height=\"100%\">");
        out.println("<table border=\"1\" cellpadding=\"0\" cellspacing=\"0\"width=\"100%\" height=\"100%\">");
        out.println("<td valign=\"top\" bgcolor=\"000099\" width=0 height=\"100%\">");
        out.println("</td>");
        out.println("</table>");
        out.println("</td>");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,15343.java,414,433
default,86322.java,414,433
----------------------------------------
    public void append(DirBuilder builder, File file, int[] counter) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                append(builder, files[i], counter);
            }
        } else {
            try {
                counter[1] += builder.addFileRef(file);
                ++counter[0];
                System.out.print('.');
            } catch (DcmParseException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            } catch (IllegalArgumentException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            }
        }
    }
----------------------------------------
    public void append(DirBuilder builder, File file, int[] counter) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                append(builder, files[i], counter);
            }
        } else {
            try {
                counter[1] += builder.addFileRef(file);
                ++counter[0];
                System.out.print('.');
            } catch (DcmParseException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            } catch (IllegalArgumentException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,15343.java,667,685
default,820.java,648,665
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45549.java,459,472
default,15343.java,440,452
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109585.java,130,137
default,59194.java,56,63
----------------------------------------
    private static void set(Configuration cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("set." + s, "");
        } else {
            cfg.put("set." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void add(Configuration cfg, String s) {
        int pos = s.indexOf('=');
        if (pos == -1) {
            cfg.put(s, "");
        } else {
            cfg.put(s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,66600.java,149,157
default,123634.java,149,157
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,624,641
default,53104.java,629,646
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,599,612
default,33872.java,604,617
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90330.java,428,448
default,98684.java,629,646
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,15343.java,280,289
default,86322.java,280,289
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4439.java,414,433
default,90330.java,290,309
----------------------------------------
    public void append(DirBuilder builder, File file, int[] counter) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                append(builder, files[i], counter);
            }
        } else {
            try {
                counter[1] += builder.addFileRef(file);
                ++counter[0];
                System.out.print('.');
            } catch (DcmParseException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            } catch (IllegalArgumentException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            }
        }
    }
----------------------------------------
    public void append(DirBuilder builder, File file, int[] counter) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                append(builder, files[i], counter);
            }
        } else {
            try {
                counter[1] += builder.addFileRef(file);
                ++counter[0];
                System.out.print('.');
            } catch (DcmParseException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            } catch (IllegalArgumentException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33872.java,629,646
default,56216.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45273.java,3,37
default,78752.java,3,37
----------------------------------------
    public static void quickSort(Object s[], int lo, int hi, Comparator cmp) {
        if (lo >= hi) return;
        int mid = (lo + hi) / 2;
        if (cmp.compare(s[lo], s[mid]) > 0) {
            Object tmp = s[lo];
            s[lo] = s[mid];
            s[mid] = tmp;
        }
        if (cmp.compare(s[mid], s[hi]) > 0) {
            Object tmp = s[mid];
            s[mid] = s[hi];
            s[hi] = tmp;
            if (cmp.compare(s[lo], s[mid]) > 0) {
                Object tmp2 = s[lo];
                s[lo] = s[mid];
                s[mid] = tmp2;
            }
        }
        int left = lo + 1;
        int right = hi - 1;
        if (left >= right) return;
        Object partition = s[mid];
        for (; ; ) {
            while (cmp.compare(s[right], partition) > 0) --right;
            while (left < right && cmp.compare(s[left], partition) <= 0) ++left;
            if (left < right) {
                Object tmp = s[left];
                s[left] = s[right];
                s[right] = tmp;
                --right;
            } else break;
        }
        quickSort(s, lo, left, cmp);
        quickSort(s, left + 1, hi, cmp);
    }
----------------------------------------
    public static void quickSort(Object s[], int lo, int hi, Comparator cmp) {
        if (lo >= hi) return;
        int mid = (lo + hi) / 2;
        if (cmp.compare(s[lo], s[mid]) > 0) {
            Object tmp = s[lo];
            s[lo] = s[mid];
            s[mid] = tmp;
        }
        if (cmp.compare(s[mid], s[hi]) > 0) {
            Object tmp = s[mid];
            s[mid] = s[hi];
            s[hi] = tmp;
            if (cmp.compare(s[lo], s[mid]) > 0) {
                Object tmp2 = s[lo];
                s[lo] = s[mid];
                s[mid] = tmp2;
            }
        }
        int left = lo + 1;
        int right = hi - 1;
        if (left >= right) return;
        Object partition = s[mid];
        for (; ; ) {
            while (cmp.compare(s[right], partition) > 0) --right;
            while (left < right && cmp.compare(s[left], partition) <= 0) ++left;
            if (left < right) {
                Object tmp = s[left];
                s[left] = s[right];
                s[right] = tmp;
                --right;
            } else break;
        }
        quickSort(s, lo, left, cmp);
        quickSort(s, left + 1, hi, cmp);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59194.java,118,124
default,63929.java,118,124
----------------------------------------
    private static void addContentDateTime(Dataset ds) {
        if (!ds.contains(Tags.ContentDate)) {
            Date now = new Date();
            ds.putDA(Tags.ContentDate, now);
            ds.putTM(Tags.ContentTime, now);
        } else if (!ds.contains(Tags.ContentTime)) ds.putTM(Tags.ContentTime);
    }
----------------------------------------
    private static void addContentDateTime(Dataset ds) {
        if (!ds.contains(Tags.ContentDate)) {
            Date now = new Date();
            ds.putDA(Tags.ContentDate, now);
            ds.putTM(Tags.ContentTime, now);
        } else if (!ds.contains(Tags.ContentTime)) ds.putTM(Tags.ContentTime);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,123634.java,73,82
default,59549.java,54,62
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55062.java,77,83
default,80007.java,77,83
----------------------------------------
    public void addPrimaryZone(String zname, String zonefile) throws IOException {
        Name origin = null;
        Cache cache = getCache(DClass.IN);
        if (zname != null) origin = Name.fromString(zname, Name.root);
        Zone newzone = new Zone(zonefile, cache, origin);
        znames.put(newzone.getOrigin(), newzone);
    }
----------------------------------------
    public void addPrimaryZone(String zname, String zonefile) throws IOException {
        Name origin = null;
        Cache cache = getCache(DClass.IN);
        if (zname != null) origin = Name.fromString(zname, Name.root);
        Zone newzone = new Zone(zonefile, cache, origin);
        znames.put(newzone.getOrigin(), newzone);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53104.java,648,665
default,70088.java,524,546
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33872.java,243,252
default,19573.java,243,252
----------------------------------------
    private TransformerHandler getTransformerHandler(SAXTransformerFactory tf, Templates tpl, String dsprompt) throws TransformerConfigurationException, IOException {
        TransformerHandler th = tf.newTransformerHandler(tpl);
        th.setResult(new StreamResult(System.out));
        Transformer t = th.getTransformer();
        t.setParameter("maxlen", maxlen);
        t.setParameter("vallen", vallen);
        t.setParameter("vallen", vallen);
        t.setParameter("dsprompt", dsprompt);
        return th;
    }
----------------------------------------
    private TransformerHandler getTransformerHandler(SAXTransformerFactory tf, Templates tpl, String dsprompt) throws TransformerConfigurationException, IOException {
        TransformerHandler th = tf.newTransformerHandler(tpl);
        th.setResult(new StreamResult(System.out));
        Transformer t = th.getTransformer();
        t.setParameter("maxlen", maxlen);
        t.setParameter("vallen", vallen);
        t.setParameter("vallen", vallen);
        t.setParameter("dsprompt", dsprompt);
        return th;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,199,206
default,57607.java,126,133
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void set(Configuration cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("set." + s, "");
        } else {
            cfg.put("set." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,81694.java,127,146
default,62004.java,127,146
----------------------------------------
    public void collect(BufferedReader in, Message msg) throws MessagingException, IOException {
        String line;
        String subject = msg.getSubject();
        StringBuffer sb = new StringBuffer();
        sb.append("<HTML>\n");
        sb.append("<HEAD>\n");
        sb.append("<TITLE>\n");
        sb.append(subject + "\n");
        sb.append("</TITLE>\n");
        sb.append("</HEAD>\n");
        sb.append("<BODY>\n");
        sb.append("<H1>" + subject + "</H1>" + "\n");
        while ((line = in.readLine()) != null) {
            sb.append(line);
            sb.append("\n");
        }
        sb.append("</BODY>\n");
        sb.append("</HTML>\n");
        msg.setDataHandler(new DataHandler(new ByteArrayDataSource(sb.toString(), "text/html")));
    }
----------------------------------------
    public void collect(BufferedReader in, Message msg) throws MessagingException, IOException {
        String line;
        String subject = msg.getSubject();
        StringBuffer sb = new StringBuffer();
        sb.append("<HTML>\n");
        sb.append("<HEAD>\n");
        sb.append("<TITLE>\n");
        sb.append(subject + "\n");
        sb.append("</TITLE>\n");
        sb.append("</HEAD>\n");
        sb.append("<BODY>\n");
        sb.append("<H1>" + subject + "</H1>" + "\n");
        while ((line = in.readLine()) != null) {
            sb.append(line);
            sb.append("\n");
        }
        sb.append("</BODY>\n");
        sb.append("</HTML>\n");
        msg.setDataHandler(new DataHandler(new ByteArrayDataSource(sb.toString(), "text/html")));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63057.java,533,541
default,2085.java,542,550
----------------------------------------
    private final void initPresContext(int pcid, List val) {
        Iterator it = val.iterator();
        String as = UIDs.forName((String) it.next());
        String[] tsUIDs = new String[val.size() - 1];
        for (int i = 0; i < tsUIDs.length; ++i) {
            tsUIDs[i] = UIDs.forName((String) it.next());
        }
        assocRQ.addPresContext(aFact.newPresContext(pcid, as, tsUIDs));
    }
----------------------------------------
    private final void initPresContext(int pcid, List val) {
        Iterator it = val.iterator();
        String as = UIDs.forName((String) it.next());
        String[] tsUIDs = new String[val.size() - 1];
        for (int i = 0; i < tsUIDs.length; ++i) {
            tsUIDs[i] = UIDs.forName((String) it.next());
        }
        assocRQ.addPresContext(aFact.newPresContext(pcid, as, tsUIDs));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103968.java,202,265
default,54008.java,202,265
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        LongOpt[] longopts = new LongOpt[8];
        longopts[0] = new LongOpt("study-uid", LongOpt.REQUIRED_ARGUMENT, null, 'S');
        longopts[1] = new LongOpt("series-uid", LongOpt.REQUIRED_ARGUMENT, null, 's');
        longopts[2] = new LongOpt("inst-uid", LongOpt.REQUIRED_ARGUMENT, null, 'i');
        longopts[3] = new LongOpt("class-uid", LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[4] = new LongOpt("grouplen", LongOpt.NO_ARGUMENT, null, 'g');
        longopts[5] = new LongOpt("seqlen", LongOpt.NO_ARGUMENT, null, 'q');
        longopts[6] = new LongOpt("itemlen", LongOpt.NO_ARGUMENT, null, 'm');
        longopts[7] = new LongOpt("no-fmi", LongOpt.NO_ARGUMENT, null, 'n');
        Getopt g = new Getopt("acr2dcm.jar", args, "S:s:i:c:g", longopts, true);
        Acr2Dcm acr2dcm = new Acr2Dcm();
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 'S':
                    acr2dcm.setStudyUID(g.getOptarg());
                    break;
                case 's':
                    acr2dcm.setSeriesUID(g.getOptarg());
                    break;
                case 'i':
                    acr2dcm.setInstUID(g.getOptarg());
                    break;
                case 'c':
                    acr2dcm.setClassUID(g.getOptarg());
                    break;
                case 'g':
                    acr2dcm.setSkipGroupLen(false);
                    break;
                case 'q':
                    acr2dcm.setUndefSeqLen(false);
                    break;
                case 'm':
                    acr2dcm.setUndefItemLen(false);
                    break;
                case 'n':
                    acr2dcm.setFileMetaInfo(false);
                    break;
                case '?':
                    exit("");
                    break;
            }
        }
        int optind = g.getOptind();
        int argc = args.length - optind;
        if (argc < 2) {
            exit("acr2dcm.jar: missing argument\n");
        }
        File dest = new File(args[args.length - 1]);
        long t1 = System.currentTimeMillis();
        int count = 1;
        if (dest.isDirectory()) {
            count = acr2dcm.mconvert(args, optind, dest);
        } else {
            File src = new File(args[optind]);
            if (argc > 2 || src.isDirectory()) {
                exit("acr2dcm.jar: when converting several files, " + "last argument must be a directory\n");
            }
            acr2dcm.convert(src, dest);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\nconverted " + count + " files in " + (t2 - t1) / 1000f + " s.");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32260.java,383,482
default,10720.java,383,482
----------------------------------------
    void processForeachRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing variable in FOREACH");
        String var_name = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing filename in FOREACH");
        String file_name = pst.nextToken();
        String select = null;
        String start = null;
        String end = null;
        boolean inRange = false;
        if (pst.hasMoreTokens()) {
            select = pst.nextToken();
            if (!pst.hasMoreTokens()) throw new IOException("Missing field value in FOREACH");
            String fval = pst.nextToken();
            int dotdot = fval.indexOf("..");
            if (dotdot != -1 && dotdot == fval.lastIndexOf("..")) {
                start = fval.substring(0, dotdot);
                end = fval.substring(dotdot + 2);
            } else {
                start = fval;
            }
        }
        if (DEBUG) System.out.println("doing foreach with varname " + var_name + " on data file :" + file_name);
        if (DEBUG && select != null) {
            System.out.print("   selecting records with " + select);
            if (end == null) System.out.println(" equal to \"" + start + "\""); else System.out.println(" between \"" + start + "\" and \"" + end + "\"");
        }
        BufferedReader data;
        try {
            data = new BufferedReader(new FileReader(file_name));
        } catch (java.io.FileNotFoundException e) {
            data = new BufferedReader(new FileReader(inDir + file_name));
        }
        Vector fields_v = new Vector();
        Vector fpl_v = new Vector();
        for (String inLine = getNextLine(data); (inLine != null && inLine.length() != 0); inLine = getNextLine(data)) {
            StringTokenizer st = new StringTokenizer(inLine);
            fpl_v.addElement(new Integer(st.countTokens()));
            while (st.hasMoreTokens()) {
                String tok = st.nextToken();
                if (DEBUG) System.out.println("read field " + fields_v.size() + " :" + tok);
                fields_v.addElement(tok);
            }
        }
        fields_v.addElement(indexField);
        int[] fieldsPerLine = new int[fpl_v.size()];
        for (int i = 0; i < fieldsPerLine.length; i++) fieldsPerLine[i] = ((Integer) fpl_v.elementAt(i)).intValue();
        String[] fields = new String[fields_v.size()];
        for (int i = 0; i < fields.length; i++) fields[i] = (String) fields_v.elementAt(i);
        dataFileLoop: for (int curField = 0; ; curField++) {
            int i = 0;
            String[] fieldData = new String[fields.length];
            for (int j = 0; j < fieldsPerLine.length; j++) {
                String line = getNextLine(data);
                if (line == null) break dataFileLoop;
                if (fieldsPerLine[j] == 1) {
                    if (DEBUG) System.out.println("read field " + fields[i] + " :" + line);
                    fieldData[i++] = line;
                } else {
                    if (DEBUG) System.out.println("reading " + fieldsPerLine[j] + " fields");
                    StringTokenizer st = new StringTokenizer(line);
                    try {
                        for (int k = 0; k < fieldsPerLine[j]; k++) {
                            String tok = st.nextToken();
                            if (DEBUG) System.out.println("read field " + fields[i] + ": " + tok);
                            fieldData[i++] = tok;
                        }
                    } catch (NoSuchElementException x) {
                        throw new IOException("Missing field " + fields[i]);
                    }
                }
            }
            if (fieldsPerLine.length != 1) getNextLine(data);
            fieldData[i++] = Integer.toString(curField);
            if (select != null) {
                for (int j = 0; j < fields.length; j++) {
                    if (DEBUG) System.out.println("checking if select is field " + fields[j]);
                    if (select.equals(fields[j])) {
                        String value = fieldData[j];
                        if (value.equals(start)) inRange = true; else if (end == null) inRange = false; else if (value.equals(end)) end = null;
                        if (DEBUG) System.out.println("record in range; including");
                        break;
                    }
                }
                if (!inRange) break dataFileLoop;
            }
            for (int j = 1; j < region.size(); j++) {
                try {
                    String currentLine = (String) region.elementAt(j);
                    String result = substitute(currentLine, var_name, fields, fieldData);
                    out.print(result + "\n");
                } catch (ClassCastException e) {
                    Vector oldRegion = (Vector) region.elementAt(j);
                    Vector newRegion = substituteInRegion(oldRegion, var_name, fields, fieldData);
                    processTemplateRegion(newRegion);
                }
            }
        }
        data.close();
    }
----------------------------------------
    void processForeachRegion(Vector region) throws IOException {
        QuotedStringTokenizer pst = new QuotedStringTokenizer(params);
        if (!pst.hasMoreTokens()) throw new IOException("Missing variable in FOREACH");
        String var_name = pst.nextToken();
        if (!pst.hasMoreTokens()) throw new IOException("Missing filename in FOREACH");
        String file_name = pst.nextToken();
        String select = null;
        String start = null;
        String end = null;
        boolean inRange = false;
        if (pst.hasMoreTokens()) {
            select = pst.nextToken();
            if (!pst.hasMoreTokens()) throw new IOException("Missing field value in FOREACH");
            String fval = pst.nextToken();
            int dotdot = fval.indexOf("..");
            if (dotdot != -1 && dotdot == fval.lastIndexOf("..")) {
                start = fval.substring(0, dotdot);
                end = fval.substring(dotdot + 2);
            } else {
                start = fval;
            }
        }
        if (DEBUG) System.out.println("doing foreach with varname " + var_name + " on data file :" + file_name);
        if (DEBUG && select != null) {
            System.out.print("   selecting records with " + select);
            if (end == null) System.out.println(" equal to \"" + start + "\""); else System.out.println(" between \"" + start + "\" and \"" + end + "\"");
        }
        BufferedReader data;
        try {
            data = new BufferedReader(new FileReader(file_name));
        } catch (java.io.FileNotFoundException e) {
            data = new BufferedReader(new FileReader(inDir + file_name));
        }
        Vector fields_v = new Vector();
        Vector fpl_v = new Vector();
        for (String inLine = getNextLine(data); (inLine != null && inLine.length() != 0); inLine = getNextLine(data)) {
            StringTokenizer st = new StringTokenizer(inLine);
            fpl_v.addElement(new Integer(st.countTokens()));
            while (st.hasMoreTokens()) {
                String tok = st.nextToken();
                if (DEBUG) System.out.println("read field " + fields_v.size() + " :" + tok);
                fields_v.addElement(tok);
            }
        }
        fields_v.addElement(indexField);
        int[] fieldsPerLine = new int[fpl_v.size()];
        for (int i = 0; i < fieldsPerLine.length; i++) fieldsPerLine[i] = ((Integer) fpl_v.elementAt(i)).intValue();
        String[] fields = new String[fields_v.size()];
        for (int i = 0; i < fields.length; i++) fields[i] = (String) fields_v.elementAt(i);
        dataFileLoop: for (int curField = 0; ; curField++) {
            int i = 0;
            String[] fieldData = new String[fields.length];
            for (int j = 0; j < fieldsPerLine.length; j++) {
                String line = getNextLine(data);
                if (line == null) break dataFileLoop;
                if (fieldsPerLine[j] == 1) {
                    if (DEBUG) System.out.println("read field " + fields[i] + " :" + line);
                    fieldData[i++] = line;
                } else {
                    if (DEBUG) System.out.println("reading " + fieldsPerLine[j] + " fields");
                    StringTokenizer st = new StringTokenizer(line);
                    try {
                        for (int k = 0; k < fieldsPerLine[j]; k++) {
                            String tok = st.nextToken();
                            if (DEBUG) System.out.println("read field " + fields[i] + ": " + tok);
                            fieldData[i++] = tok;
                        }
                    } catch (NoSuchElementException x) {
                        throw new IOException("Missing field " + fields[i]);
                    }
                }
            }
            if (fieldsPerLine.length != 1) getNextLine(data);
            fieldData[i++] = Integer.toString(curField);
            if (select != null) {
                for (int j = 0; j < fields.length; j++) {
                    if (DEBUG) System.out.println("checking if select is field " + fields[j]);
                    if (select.equals(fields[j])) {
                        String value = fieldData[j];
                        if (value.equals(start)) inRange = true; else if (end == null) inRange = false; else if (value.equals(end)) end = null;
                        if (DEBUG) System.out.println("record in range; including");
                        break;
                    }
                }
                if (!inRange) break dataFileLoop;
            }
            for (int j = 1; j < region.size(); j++) {
                try {
                    String currentLine = (String) region.elementAt(j);
                    String result = substitute(currentLine, var_name, fields, fieldData);
                    out.print(result + "\n");
                } catch (ClassCastException e) {
                    Vector oldRegion = (Vector) region.elementAt(j);
                    Vector newRegion = substituteInRegion(oldRegion, var_name, fields, fieldData);
                    processTemplateRegion(newRegion);
                }
            }
        }
        data.close();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32738.java,621,658
default,80764.java,726,762
----------------------------------------
    protected void readImage() {
        System.out.println("GifDecoder.readImage(" + ")");
        ix = readShort();
        iy = readShort();
        iw = readShort();
        ih = readShort();
        int packed = read();
        lctFlag = (packed & 0x80) != 0;
        interlace = (packed & 0x40) != 0;
        lctSize = 2 << (packed & 7);
        if (lctFlag) {
            lct = readColorTable(lctSize);
            act = lct;
        } else {
            act = gct;
            if (bgIndex == transIndex) bgColor = 0;
        }
        int save = 0;
        if (transparency) {
            save = act[transIndex];
            act[transIndex] = 0;
        }
        if (act == null) {
            status = STATUS_FORMAT_ERROR;
        }
        if (err()) return;
        decodeImageData();
        skip();
        if (err()) return;
        frameCount++;
        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB_PRE);
        setPixels();
        frames.add(new GifFrame(image, delay));
        if (transparency) {
            act[transIndex] = save;
        }
        resetFrame();
    }
----------------------------------------
    protected void readImage() {
        ix = readShort();
        iy = readShort();
        iw = readShort();
        ih = readShort();
        int packed = read();
        lctFlag = (packed & 0x80) != 0;
        interlace = (packed & 0x40) != 0;
        lctSize = 2 << (packed & 7);
        if (lctFlag) {
            lct = readColorTable(lctSize);
            act = lct;
        } else {
            act = gct;
            if (bgIndex == transIndex) bgColor = 0;
        }
        int save = 0;
        if (transparency) {
            save = act[transIndex];
            act[transIndex] = 0;
        }
        if (act == null) {
            status = STATUS_FORMAT_ERROR;
        }
        if (err()) return;
        decodeImageData();
        skip();
        if (err()) return;
        frameCount++;
        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB_PRE);
        setPixels();
        frames.add(new GifFrame(image, delay));
        if (transparency) {
            act[transIndex] = save;
        }
        resetFrame();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33872.java,522,544
default,53104.java,667,685
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,97360.java,495,509
default,103762.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57607.java,459,501
default,50381.java,463,505
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,495,509
default,97360.java,495,509
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25073.java,345,365
default,91489.java,191,211
----------------------------------------
    public int truncateSection(Message in, int maxLength, int length, int section) {
        int removed = 0;
        Record[] records = in.getSectionArray(section);
        for (int i = records.length - 1; i >= 0; i--) {
            Record r = records[i];
            removed += r.getWireLength();
            length -= r.getWireLength();
            in.removeRecord(r, section);
            if (length > maxLength) continue; else {
                for (int j = i - 1; j >= 0; j--) {
                    Record r2 = records[j];
                    if (!r.getName().equals(r2.getName()) || r.getType() != r2.getType() || r.getDClass() != r2.getDClass()) break;
                    removed += r2.getWireLength();
                    length -= r2.getWireLength();
                    in.removeRecord(r2, section);
                }
                return removed;
            }
        }
        return removed;
    }
----------------------------------------
    public int truncateSection(Message in, int maxLength, int length, int section) {
        int removed = 0;
        Record[] records = in.getSectionArray(section);
        for (int i = records.length - 1; i >= 0; i--) {
            Record r = records[i];
            removed += r.getWireLength();
            length -= r.getWireLength();
            in.removeRecord(section, r);
            if (length > maxLength) continue; else {
                for (int j = i - 1; j >= 0; j--) {
                    Record r2 = records[j];
                    if (!r.getName().equals(r2.getName()) || r.getType() != r2.getType() || r.getDClass() != r2.getDClass()) break;
                    removed += r2.getWireLength();
                    length -= r2.getWireLength();
                    in.removeRecord(section, r2);
                }
                return removed;
            }
        }
        return removed;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,135495.java,629,646
default,42612.java,667,685
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53104.java,474,483
default,36322.java,474,483
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,80596.java,456,465
default,59943.java,457,466
----------------------------------------
    public void addUDP(final InetAddress addr, final int port) {
        Thread t;
        t = new Thread(new Runnable() {

            public void run() {
                serveUDP(addr, port);
            }
        });
        t.start();
    }
----------------------------------------
    public void addUDP(final InetAddress addr, final int port) {
        Thread t;
        t = new Thread(new Runnable() {

            public void run() {
                serveUDP(addr, port);
            }
        });
        t.start();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109369.java,522,544
default,42612.java,522,544
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,123890.java,27,46
default,103511.java,27,46
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4439.java,667,685
default,109369.java,667,685
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25053.java,570,590
default,19573.java,570,590
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,662,680
default,19573.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32654.java,522,544
default,820.java,546,568
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32654.java,522,544
default,35053.java,648,665
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45549.java,546,568
default,86322.java,546,568
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,41662.java,175,180
default,24133.java,175,180
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,113166.java,99,111
default,27366.java,99,111
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,243,252
default,36322.java,243,252
----------------------------------------
    private TransformerHandler getTransformerHandler(SAXTransformerFactory tf, Templates tpl, String dsprompt) throws TransformerConfigurationException, IOException {
        TransformerHandler th = tf.newTransformerHandler(tpl);
        th.setResult(new StreamResult(System.out));
        Transformer t = th.getTransformer();
        t.setParameter("maxlen", maxlen);
        t.setParameter("vallen", vallen);
        t.setParameter("vallen", vallen);
        t.setParameter("dsprompt", dsprompt);
        return th;
    }
----------------------------------------
    private TransformerHandler getTransformerHandler(SAXTransformerFactory tf, Templates tpl, String dsprompt) throws TransformerConfigurationException, IOException {
        TransformerHandler th = tf.newTransformerHandler(tpl);
        th.setResult(new StreamResult(System.out));
        Transformer t = th.getTransformer();
        t.setParameter("maxlen", maxlen);
        t.setParameter("vallen", vallen);
        t.setParameter("vallen", vallen);
        t.setParameter("dsprompt", dsprompt);
        return th;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19573.java,604,617
default,56216.java,604,617
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,97360.java,524,546
default,124843.java,546,568
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,682,698
default,97360.java,689,705
----------------------------------------
    private static Properties loadConfig() {
        InputStream in = DcmDir.class.getResourceAsStream("dcmdir.cfg");
        try {
            Properties retval = new Properties();
            retval.load(in);
            return retval;
        } catch (Exception e) {
            throw new RuntimeException("Could not read dcmdir.cfg", e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
----------------------------------------
    private static Properties loadConfig() {
        InputStream in = DcmDir.class.getResourceAsStream("dcmdir.cfg");
        try {
            Properties retval = new Properties();
            retval.load(in);
            return retval;
        } catch (Exception e) {
            throw new RuntimeException("Could not read dcmdir.cfg", e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45549.java,667,685
default,15343.java,522,544
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88095.java,385,390
default,2085.java,401,406
----------------------------------------
    private void doOverwrite(Dataset ds) {
        for (Iterator it = overwrite.iterator(); it.hasNext(); ) {
            DcmElement el = (DcmElement) it.next();
            ds.putXX(el.tag(), el.vr(), el.getByteBuffer());
        }
    }
----------------------------------------
    private void doOverwrite(Dataset ds) {
        for (Iterator it = overwrite.iterator(); it.hasNext(); ) {
            DcmElement el = (DcmElement) it.next();
            ds.putXX(el.tag(), el.vr(), el.getByteBuffer());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,517,539
default,53104.java,570,590
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,67537.java,197,213
default,552.java,197,213
----------------------------------------
    DcmGen(Configuration cfg, DcmURL url, int argc) {
        this.url = url;
        this.priority = Integer.parseInt(cfg.getProperty("prior", "0"));
        this.packPDVs = "true".equalsIgnoreCase(cfg.getProperty("pack-pdvs", "false"));
        this.truncPostPixelData = "true".equalsIgnoreCase(cfg.getProperty("trunc-post-pixeldata", "false"));
        this.excludePrivate = "true".equalsIgnoreCase(cfg.getProperty("exclude-private", "false"));
        this.bufferSize = Integer.parseInt(cfg.getProperty("buf-len", "2048")) & 0xfffffffe;
        this.repeatWhole = Integer.parseInt(cfg.getProperty("repeat-assoc", "1"));
        this.repeatSingle = Integer.parseInt(cfg.getProperty("repeat-dimse", "1"));
        this.uidSuffix = cfg.getProperty("uid-suffix");
        this.mode = argc > 1 ? SEND : ECHO;
        this.random = "true".equalsIgnoreCase(cfg.getProperty("set-random", "false"));
        this.complete = "true".equalsIgnoreCase(cfg.getProperty("set-complete", "false"));
        initAssocParam(cfg, url, mode == ECHO);
        initTLS(cfg);
        initOverwrite(cfg);
    }
----------------------------------------
    DcmGen(Configuration cfg, DcmURL url, int argc) {
        this.url = url;
        this.priority = Integer.parseInt(cfg.getProperty("prior", "0"));
        this.packPDVs = "true".equalsIgnoreCase(cfg.getProperty("pack-pdvs", "false"));
        this.truncPostPixelData = "true".equalsIgnoreCase(cfg.getProperty("trunc-post-pixeldata", "false"));
        this.excludePrivate = "true".equalsIgnoreCase(cfg.getProperty("exclude-private", "false"));
        this.bufferSize = Integer.parseInt(cfg.getProperty("buf-len", "2048")) & 0xfffffffe;
        this.repeatWhole = Integer.parseInt(cfg.getProperty("repeat-assoc", "1"));
        this.repeatSingle = Integer.parseInt(cfg.getProperty("repeat-dimse", "1"));
        this.uidSuffix = cfg.getProperty("uid-suffix");
        this.mode = argc > 1 ? SEND : ECHO;
        this.random = "true".equalsIgnoreCase(cfg.getProperty("set-random", "false"));
        this.complete = "true".equalsIgnoreCase(cfg.getProperty("set-complete", "false"));
        initAssocParam(cfg, url, mode == ECHO);
        initTLS(cfg);
        initOverwrite(cfg);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,114414.java,42,59
default,108224.java,42,59
----------------------------------------
    SqueezeCube(BufferedReader br, BufferedWriter bw) {
        this.br = br;
        this.bw = bw;
        try {
            readTitleLines();
            readAtomCountAndOriginLine();
            readVolumetricVectorLines();
            readAtomLines();
            readOptionalMolecularOrbitalLine();
            readVolumetricData();
            squeezeVolumetricData(0.001f);
            writeHeader();
            writeVolumetricData();
            bw.flush();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
----------------------------------------
    SqueezeCube(BufferedReader br, BufferedWriter bw) {
        this.br = br;
        this.bw = bw;
        try {
            readTitleLines();
            readAtomCountAndOriginLine();
            readVolumetricVectorLines();
            readAtomLines();
            readOptionalMolecularOrbitalLine();
            readVolumetricData();
            squeezeVolumetricData(0.001f);
            writeHeader();
            writeVolumetricData();
            bw.flush();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132272.java,216,229
default,19811.java,216,229
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,78674.java,113,124
default,70893.java,113,124
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
    private boolean found(List<List<String>> table, String target) {
        boolean found = false;
        search: for (List<String> row : table) {
            for (String value : row) {
                if (value.equals(target)) {
                    found = true;
                    break search;
                }
            }
        }
        return found;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,72323.java,629,646
default,64200.java,546,568
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,108541.java,295,307
default,48666.java,295,307
----------------------------------------
    private void send(ActiveAssociation active, File file, Dataset ds) throws InterruptedException, IOException {
        if (!file.isDirectory()) {
            for (int i = 0; i < repeatSingle; ++i) {
                if (ds != null && random) ds.putUI(Tags.SOPInstanceUID, uidGen.createUID());
                sendFile(active, file, ds);
            }
            return;
        }
        File[] list = file.listFiles();
        for (int i = 0; i < list.length; ++i) {
            send(active, list[i], ds);
        }
    }
----------------------------------------
    private void send(ActiveAssociation active, File file, Dataset ds) throws InterruptedException, IOException {
        if (!file.isDirectory()) {
            for (int i = 0; i < repeatSingle; ++i) {
                if (ds != null && random) ds.putUI(Tags.SOPInstanceUID, uidGen.createUID());
                sendFile(active, file, ds);
            }
            return;
        }
        File[] list = file.listFiles();
        for (int i = 0; i < list.length; ++i) {
            send(active, list[i], ds);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,199,206
default,88095.java,126,133
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void set(Configuration cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("set." + s, "");
        } else {
            cfg.put("set." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98981.java,522,544
default,86322.java,648,665
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25053.java,604,617
default,4439.java,604,617
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,650,667
default,116906.java,648,665
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19573.java,110,197
default,97360.java,110,197
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
    public static void main(String args[]) throws Exception {
        Getopt g = new Getopt("dcmdir", args, "c:t:q:a:x:X:z:P:", LONG_OPTS);
        Properties cfg = loadConfig();
        int cmd = 0;
        File dirfile = null;
        int c;
        while ((c = g.getopt()) != -1) {
            switch(c) {
                case 2:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), g.getOptarg());
                    break;
                case 3:
                    cfg.put(LONG_OPTS[g.getLongind()].getName(), "<yes>");
                    break;
                case 'c':
                case 't':
                case 'q':
                case 'a':
                case 'x':
                case 'X':
                case 'P':
                case 'z':
                    cmd = c;
                    dirfile = new File(g.getOptarg());
                    break;
                case 'p':
                    patientIDs.add(g.getOptarg());
                    break;
                case 's':
                    studyUIDs.add(g.getOptarg());
                    break;
                case 'e':
                    seriesUIDs.add(g.getOptarg());
                    break;
                case 'o':
                    sopInstUIDs.add(g.getOptarg());
                    break;
                case 'y':
                    putKey(cfg, g.getOptarg());
                    break;
                case 'v':
                    exit(messages.getString("version"), false);
                case 'h':
                    exit(messages.getString("usage"), false);
                case '?':
                    exit(null, true);
                    break;
            }
        }
        if (cmd == 0) {
            exit(messages.getString("missing"), true);
        }
        try {
            DcmDir dcmdir = new DcmDir(dirfile, cfg);
            switch(cmd) {
                case 0:
                    exit(messages.getString("missing"), true);
                    break;
                case 'c':
                    dcmdir.create(args, g.getOptind());
                    break;
                case 't':
                    dcmdir.list();
                    break;
                case 'q':
                    dcmdir.query();
                    break;
                case 'a':
                    dcmdir.append(args, g.getOptind());
                    break;
                case 'x':
                case 'X':
                    dcmdir.remove(args, g.getOptind(), cmd == 'X');
                    break;
                case 'z':
                    dcmdir.compact();
                    break;
                case 'P':
                    dcmdir.purge();
                    break;
                default:
                    throw new RuntimeException();
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            exit(e.getMessage(), true);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,104653.java,448,465
default,94364.java,435,452
----------------------------------------
    public boolean pstepLineOverMethod(int thread) {
        boolean stillrunning = true;
        boolean skip_prolog;
        int addr, orig_frame, curr_frame;
        String orig_line;
        String curr_line;
        orig_frame = mem.findFrameCount();
        stillrunning = pstepLine(thread, PRINTNONE);
        if (!stillrunning) return stillrunning;
        curr_frame = mem.findFrameCount();
        if (orig_frame < curr_frame) {
            stillrunning = pcontinueToReturn(thread, PRINTNONE);
        } else {
            stillrunning = true;
        }
        if (stillrunning) printCurrentStatus(PRINTSOURCE);
        return stillrunning;
    }
----------------------------------------
    public boolean pstepLineOverMethod(int thread) {
        boolean stillrunning = true;
        boolean skip_prolog;
        int addr, orig_frame, curr_frame;
        String orig_line;
        String curr_line;
        orig_frame = mem.findFrameCount();
        stillrunning = pstepLine(thread, PRINTNONE);
        if (!stillrunning) return stillrunning;
        curr_frame = mem.findFrameCount();
        if (orig_frame < curr_frame) {
            stillrunning = pcontinueToReturn(thread, PRINTNONE);
        } else {
            stillrunning = true;
        }
        if (stillrunning) printCurrentStatus(PRINTSOURCE);
        return stillrunning;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,199,206
default,97360.java,199,206
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,208,241
default,97360.java,208,241
----------------------------------------
    DcmDir(File dirfile, Properties cfg) throws IOException {
        this.dirFile = dirfile.getCanonicalFile();
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
    DcmDir(File dirfile, Properties cfg) throws IOException {
        this.dirFile = dirfile.getCanonicalFile();
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59549.java,99,111
default,96830.java,99,111
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19383.java,413,448
default,58507.java,406,441
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,16697.java,87,103
default,105947.java,87,103
----------------------------------------
    private static void write(File pdfFile, File dcmFile, Dataset ds) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(pdfFile), BUFFER_SIZE);
        try {
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dcmFile));
            try {
                ds.writeFile(out, null);
                final int doclen = (int) pdfFile.length();
                ds.writeHeader(out, DcmEncodeParam.EVR_LE, Tags.EncapsulatedDocument, VRs.OB, (doclen + 1) & ~1);
                copy(in, out);
                if ((doclen & 1) != 0) out.write(0);
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }
----------------------------------------
    private static void write(File pdfFile, File dcmFile, Dataset ds) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(pdfFile), BUFFER_SIZE);
        try {
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dcmFile));
            try {
                ds.writeFile(out, null);
                final int doclen = (int) pdfFile.length();
                ds.writeHeader(out, DcmEncodeParam.EVR_LE, Tags.EncapsulatedDocument, VRs.OB, (doclen + 1) & ~1);
                copy(in, out);
                if ((doclen & 1) != 0) out.write(0);
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,111522.java,105,116
default,105947.java,105,116
----------------------------------------
    private static void addUIDs(Dataset ds) {
        UIDGenerator uidgen = UIDGenerator.getInstance();
        if (!ds.contains(Tags.StudyInstanceUID)) {
            ds.putUI(Tags.StudyInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SeriesInstanceUID)) {
            ds.putUI(Tags.SeriesInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SOPInstanceUID)) {
            ds.putUI(Tags.SOPInstanceUID, uidgen.createUID());
        }
    }
----------------------------------------
    private static void addUIDs(Dataset ds) {
        UIDGenerator uidgen = UIDGenerator.getInstance();
        if (!ds.contains(Tags.StudyInstanceUID)) {
            ds.putUI(Tags.StudyInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SeriesInstanceUID)) {
            ds.putUI(Tags.SeriesInstanceUID, uidgen.createUID());
        }
        if (!ds.contains(Tags.SOPInstanceUID)) {
            ds.putUI(Tags.SOPInstanceUID, uidgen.createUID());
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55775.java,30,44
default,58332.java,30,44
----------------------------------------
    public Configuration(URL url) {
        InputStream in = null;
        try {
            load(in = url.openStream());
        } catch (Exception e) {
            throw new RuntimeException("Could not load configuration from " + url, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
----------------------------------------
    public Configuration(URL url) {
        InputStream in = null;
        try {
            load(in = url.openStream());
        } catch (Exception e) {
            throw new RuntimeException("Could not load configuration from " + url, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,135495.java,667,685
default,70088.java,631,648
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51768.java,39,43
default,4434.java,38,42
----------------------------------------
    public static void newVersionAvailable(View view, String version, URL url) {
        String[] args = { version };
        int result = GUIUtilities.confirm(view, "version-check.new-version", args, JOptionPane.YES_NO_OPTION, JOptionPane.INFORMATION_MESSAGE);
        if (result == JOptionPane.YES_OPTION) jEdit.openFile(view, url.toString());
    }
----------------------------------------
    public static void newVersionAvailable(View view, String version, URL url) {
        String[] args = { version };
        int result = GUIUtilities.confirm(view, "version-check.new-version", args, JOptionPane.YES_NO_OPTION, JOptionPane.INFORMATION_MESSAGE);
        if (result == JOptionPane.YES_OPTION) jEdit.openFile(view, url.toString());
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126614.java,526,534
default,109803.java,466,474
----------------------------------------
    private final void initPresContext(int pcid, List val) {
        Iterator it = val.iterator();
        String as = UIDs.forName((String) it.next());
        String[] tsUIDs = new String[val.size() - 1];
        for (int i = 0; i < tsUIDs.length; ++i) {
            tsUIDs[i] = UIDs.forName((String) it.next());
        }
        assocRQ.addPresContext(aFact.newPresContext(pcid, as, tsUIDs));
    }
----------------------------------------
    private final void initPresContext(int pcid, List val) {
        Iterator it = val.iterator();
        String as = UIDs.forName((String) it.next());
        String[] tsUIDs = new String[val.size() - 1];
        for (int i = 0; i < tsUIDs.length; ++i) {
            tsUIDs[i] = UIDs.forName((String) it.next());
        }
        assocRQ.addPresContext(aFact.newPresContext(pcid, as, tsUIDs));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,7413.java,73,82
default,81085.java,64,71
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98834.java,728,744
default,98834.java,749,769
----------------------------------------
    public void testWriteTryLockWhenReadLockedFair() {
        final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);
        lock.readLock().lock();
        Thread t = new Thread(new Runnable() {

            public void run() {
                threadAssertFalse(lock.writeLock().tryLock());
            }
        });
        try {
            t.start();
            t.join();
            lock.readLock().unlock();
        } catch (Exception e) {
            unexpectedException();
        }
    }
----------------------------------------
    public void testWriteTryLock_Timeout() {
        final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
        lock.writeLock().lock();
        Thread t = new Thread(new Runnable() {

            public void run() {
                try {
                    threadAssertFalse(lock.writeLock().tryLock(1, TimeUnit.MILLISECONDS));
                } catch (Exception ex) {
                    threadUnexpectedException();
                }
            }
        });
        try {
            t.start();
            t.join();
            lock.writeLock().unlock();
        } catch (Exception e) {
            unexpectedException();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56485.java,361,368
default,11981.java,606,613
----------------------------------------
    private byte[] remEpgWatchList(HTTPurl urlData) throws Exception {
        String watchlist = urlData.getParameter("watchlist");
        store.removeEpgWatchList(watchlist);
        StringBuffer buff = new StringBuffer();
        buff.append("HTTP/1.0 302 Moved Temporarily\n");
        buff.append("Location: /servlet/EpgAutoAddDataRes?action=33\n\n");
        return buff.toString().getBytes();
    }
----------------------------------------
    private byte[] deleteNamePattern(HTTPurl urlData) throws Exception {
        int index = Integer.parseInt(urlData.getParameter("id"));
        store.deleteNamePattern(index);
        StringBuffer buff = new StringBuffer();
        buff.append("HTTP/1.0 302 Moved Temporarily\n");
        buff.append("Location: /servlet/SystemDataRes?action=27\n\n");
        return buff.toString().getBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,66600.java,43,52
default,96830.java,43,52
----------------------------------------
    public void testCommas() {
        String sequence = "1,2,3,4,5";
        assertEquals(sequence, sequenceUsingDo(1, 5));
        assertEquals(sequence, sequenceUsingFor(1, 5));
        assertEquals(sequence, sequenceUsingWhile(1, 5));
        sequence = "8";
        assertEquals(sequence, sequenceUsingDo(8, 8));
        assertEquals(sequence, sequenceUsingFor(8, 8));
        assertEquals(sequence, sequenceUsingWhile(8, 8));
    }
----------------------------------------
    public void testCommas() {
        String sequence = "1,2,3,4,5";
        assertEquals(sequence, sequenceUsingDo(1, 5));
        assertEquals(sequence, sequenceUsingFor(1, 5));
        assertEquals(sequence, sequenceUsingWhile(1, 5));
        sequence = "8";
        assertEquals(sequence, sequenceUsingDo(8, 8));
        assertEquals(sequence, sequenceUsingFor(8, 8));
        assertEquals(sequence, sequenceUsingWhile(8, 8));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98834.java,247,267
default,98834.java,774,794
----------------------------------------
    public void testReadTryLock_Interrupted() {
        final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
        lock.writeLock().lock();
        Thread t = new Thread(new Runnable() {

            public void run() {
                try {
                    lock.readLock().tryLock(1000, TimeUnit.MILLISECONDS);
                    threadShouldThrow();
                } catch (InterruptedException success) {
                }
            }
        });
        try {
            t.start();
            t.interrupt();
            t.join();
        } catch (Exception e) {
            unexpectedException();
        }
    }
----------------------------------------
    public void testReadTryLock_Timeout() {
        final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
        lock.writeLock().lock();
        Thread t = new Thread(new Runnable() {

            public void run() {
                try {
                    threadAssertFalse(lock.readLock().tryLock(1, TimeUnit.MILLISECONDS));
                } catch (Exception ex) {
                    threadUnexpectedException();
                }
            }
        });
        try {
            t.start();
            t.join();
            lock.writeLock().unlock();
        } catch (Exception e) {
            unexpectedException();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,56674.java,27,46
default,23674.java,27,46
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,97360.java,297,306
default,124843.java,260,270
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126614.java,406,441
default,48666.java,413,448
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45549.java,394,404
default,64200.java,394,404
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,101935.java,900,909
default,94364.java,900,909
----------------------------------------
    public String listGCThreads() {
        String queueName = "collectorQueue";
        try {
            VM_Field field = bmap.findVMField("VM_Scheduler", queueName);
            int queuePointer = mem.readTOC(field.getOffset());
            return "GC threads: \n" + threadQueueToString(queuePointer);
        } catch (BmapNotFoundException e) {
            return "ERROR: cannot find VM_Scheduler." + queueName + ", has VM_Scheduler been changed?";
        }
    }
----------------------------------------
    public String listGCThreads() {
        String queueName = "collectorQueue";
        try {
            VM_Field field = bmap.findVMField("VM_Scheduler", queueName);
            int queuePointer = mem.readTOC(field.getOffset());
            return "GC threads: \n" + threadQueueToString(queuePointer);
        } catch (BmapNotFoundException e) {
            return "ERROR: cannot find VM_Scheduler." + queueName + ", has VM_Scheduler been changed?";
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45930.java,48,62
default,126732.java,48,62
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("PixelDataTest: Error: Too few parameters");
            System.out.println("Usage: PixelDataTest <dicom-file>");
            System.exit(1);
        }
        for (int i = 0; i < args.length; i++) {
            try {
                File inFile = new File(args[i]), outFile = new File(inFile.getAbsolutePath() + ".TEST");
                readAndRewrite(inFile, outFile);
            } catch (IOException ioe) {
                System.err.println("FAILED: " + ioe);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,89968.java,346,377
default,19811.java,346,377
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,118595.java,496,500
default,50607.java,503,507
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126614.java,293,304
default,50607.java,295,307
----------------------------------------
    private void send(ActiveAssociation active, File file) throws InterruptedException, IOException {
        if (!file.isDirectory()) {
            for (int i = 0; i < repeatSingle; ++i) {
                sendFile(active, file);
            }
            return;
        }
        File[] list = file.listFiles();
        for (int i = 0; i < list.length; ++i) {
            send(active, list[i]);
        }
    }
----------------------------------------
    private void send(ActiveAssociation active, File file, Dataset ds) throws InterruptedException, IOException {
        if (!file.isDirectory()) {
            for (int i = 0; i < repeatSingle; ++i) {
                if (ds != null && random) ds.putUI(Tags.SOPInstanceUID, uidGen.createUID());
                sendFile(active, file, ds);
            }
            return;
        }
        File[] list = file.listFiles();
        for (int i = 0; i < list.length; ++i) {
            send(active, list[i], ds);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,17076.java,6,11
default,96513.java,6,11
----------------------------------------
    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
----------------------------------------
    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129984.java,941,972
default,40759.java,943,974
----------------------------------------
    String substitute(String input, String var, String[] fields, String[] fieldData) throws IOException {
        StringBuffer out = new StringBuffer();
        int varlen = var.length();
        int oidx = 0;
        for (; ; ) {
            if (DEBUG) System.out.println("checking for occurrence of " + var + " in :" + input.substring(oidx));
            int idx = input.indexOf(var, oidx);
            if (idx == -1) break;
            out.append(input.substring(oidx, idx));
            idx += varlen;
            if (input.charAt(idx) != '.') throw new IOException("no field");
            idx++;
            int idx_save = idx;
            for (int i = 0; i < fields.length; i++) {
                String fld = fields[i];
                int flen = fld.length();
                if (DEBUG) System.out.println("checking if it is field " + fld);
                if (input.regionMatches(idx, fld, 0, flen)) {
                    String value = fieldData[i];
                    if (DEBUG) System.out.println("field matches. outputting data :" + value);
                    out.append(value);
                    idx += flen;
                    break;
                }
            }
            if (idx == idx_save) throw new IOException("unknown field");
            oidx = idx;
        }
        if (DEBUG) System.out.println("no more variables left on this line");
        out.append(input.substring(oidx));
        return out.toString();
    }
----------------------------------------
    String substitute(String input, String var, String[] fields, String[] fieldData) throws IOException {
        StringBuffer out = new StringBuffer();
        int varlen = var.length();
        int oidx = 0;
        for (; ; ) {
            if (DEBUG) System.out.println("checking for occurrence of " + var + " in :" + input.substring(oidx));
            int idx = input.indexOf(var, oidx);
            if (idx == -1) break;
            out.append(input.substring(oidx, idx));
            idx += varlen;
            if (input.charAt(idx) != '.') throw new IOException("no field");
            idx++;
            int idx_save = idx;
            for (int i = 0; i < fields.length; i++) {
                String fld = fields[i];
                int flen = fld.length();
                if (DEBUG) System.out.println("checking if it is field " + fld);
                if (input.regionMatches(idx, fld, 0, flen)) {
                    String value = fieldData[i];
                    if (DEBUG) System.out.println("field matches. outputting data :" + value);
                    out.append(value);
                    idx += flen;
                    break;
                }
            }
            if (idx == idx_save) throw new IOException("unknown field");
            oidx = idx;
        }
        if (DEBUG) System.out.println("no more variables left on this line");
        out.append(input.substring(oidx));
        return out.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96830.java,54,62
default,57755.java,73,82
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,135777.java,54,62
default,57755.java,73,82
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96513.java,36,41
default,70893.java,36,41
----------------------------------------
    public void testForSkip() {
        StringBuilder builder = new StringBuilder();
        String string = "123456";
        for (int i = 0; i < string.length(); i += 2) builder.append(string.charAt(i));
        assertEquals("135", builder.toString());
    }
----------------------------------------
    public void testForSkip() {
        StringBuilder builder = new StringBuilder();
        String string = "123456";
        for (int i = 0; i < string.length(); i += 2) builder.append(string.charAt(i));
        assertEquals("135", builder.toString());
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,116202.java,406,441
default,48666.java,413,448
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,111086.java,30,44
default,117437.java,30,44
----------------------------------------
    public Configuration(URL url) {
        InputStream in = null;
        try {
            load(in = url.openStream());
        } catch (Exception e) {
            throw new RuntimeException("Could not load configuration from " + url, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
----------------------------------------
    public Configuration(URL url) {
        InputStream in = null;
        try {
            load(in = url.openStream());
        } catch (Exception e) {
            throw new RuntimeException("Could not load configuration from " + url, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98684.java,629,646
default,95647.java,570,590
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49246.java,226,243
default,40553.java,226,243
----------------------------------------
    static byte[][] multi_upload_test(int threads, int total_iterations) {
        MultiUploadThread t[] = new MultiUploadThread[threads];
        byte blobs[][];
        int iterations;
        iterations = (total_iterations + threads - 1) / threads;
        blobs = new byte[iterations * threads][];
        for (int i = 0; i < threads; i++) t[i] = new MultiUploadThread(blobs, i * iterations, iterations);
        try {
            long start = System.currentTimeMillis();
            for (int i = 0; i < threads; i++) t[i].start();
            for (int i = 0; i < threads; i++) t[i].join();
            long stop = System.currentTimeMillis();
            printTime(start, stop, iterations * threads);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return blobs;
    }
----------------------------------------
    static byte[][] multi_upload_test(int threads, int total_iterations) {
        MultiUploadThread t[] = new MultiUploadThread[threads];
        byte blobs[][];
        int iterations;
        iterations = (total_iterations + threads - 1) / threads;
        blobs = new byte[iterations * threads][];
        for (int i = 0; i < threads; i++) t[i] = new MultiUploadThread(blobs, i * iterations, iterations);
        try {
            long start = System.currentTimeMillis();
            for (int i = 0; i < threads; i++) t[i].start();
            for (int i = 0; i < threads; i++) t[i].join();
            long stop = System.currentTimeMillis();
            printTime(start, stop, iterations * threads);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return blobs;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65413.java,442,454
default,64200.java,459,472
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32654.java,474,483
default,64200.java,474,483
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96513.java,54,62
default,96830.java,54,62
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96513.java,54,62
default,10736.java,73,82
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49246.java,51,82
default,94308.java,51,82
----------------------------------------
    static void write_file_test(boolean displayTime, boolean withSubDirs, boolean createDirs, int first, int iterations) {
        File f;
        FileOutputStream s;
        int i = 0, num;
        try {
            if (createDirs) {
                f = new File("tmp");
                if (!f.exists()) f.mkdir();
                f = new File("tmp/blobs");
                if (!f.exists()) f.mkdir();
                if (withSubDirs) {
                    for (i = 0; i < 100; i++) {
                        f = new File("tmp/blobs/dir" + i + "/");
                        if (!f.exists()) f.mkdir();
                    }
                }
            }
            long start = System.currentTimeMillis();
            for (i = 0; i < iterations; i++) {
                num = first + i;
                if (withSubDirs) f = new File("tmp/blobs/dir" + (num % 100) + "/blob" + num); else f = new File("tmp/blobs/blob" + num);
                f.createNewFile();
                s = new FileOutputStream(f);
                s.write("This is an example of an uploaded BLOB".getBytes());
                s.close();
            }
            long stop = System.currentTimeMillis();
            if (displayTime) printTime(start, stop, iterations);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
----------------------------------------
    static void write_file_test(boolean displayTime, boolean withSubDirs, boolean createDirs, int first, int iterations) {
        File f;
        FileOutputStream s;
        int i = 0, num;
        try {
            if (createDirs) {
                f = new File("tmp");
                if (!f.exists()) f.mkdir();
                f = new File("tmp/blobs");
                if (!f.exists()) f.mkdir();
                if (withSubDirs) {
                    for (i = 0; i < 100; i++) {
                        f = new File("tmp/blobs/dir" + i + "/");
                        if (!f.exists()) f.mkdir();
                    }
                }
            }
            long start = System.currentTimeMillis();
            for (i = 0; i < iterations; i++) {
                num = first + i;
                if (withSubDirs) f = new File("tmp/blobs/dir" + (num % 100) + "/blob" + num); else f = new File("tmp/blobs/blob" + num);
                f.createNewFile();
                s = new FileOutputStream(f);
                s.write("This is an example of an uploaded BLOB".getBytes());
                s.close();
            }
            long stop = System.currentTimeMillis();
            if (displayTime) printTime(start, stop, iterations);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,22134.java,183,197
default,97464.java,183,197
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
    public int mconvert(File src, File dest) throws IOException {
        if (src.isFile()) {
            convert(src, dest);
            return 1;
        }
        File[] files = src.listFiles();
        if (files.length > 0 && !dest.exists()) {
            dest.mkdirs();
        }
        int count = 0;
        for (int i = 0; i < files.length; ++i) {
            count += mconvert(files[i], new File(dest, files[i].getName()));
        }
        return count;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19573.java,546,568
default,64200.java,629,646
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,120094.java,6,11
default,97910.java,6,11
----------------------------------------
    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
----------------------------------------
    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33872.java,667,685
default,64200.java,648,665
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,97360.java,572,592
default,64200.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,25053.java,260,270
default,137594.java,260,270
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,87849.java,50,59
default,42519.java,1060,1069
----------------------------------------
    Brush(String name, String group, String color, int slice, String supergroupname, String supergroupcolor, int[] x, int[] y) {
        this.name = name;
        this.group = group;
        this.slice = slice;
        this.color = color;
        this.supergroupname = supergroupname;
        this.supergroupcolor = supergroupcolor;
        this.x = x;
        this.y = y;
    }
----------------------------------------
        public KeyPressThread(int charCode, int keyCode, boolean alt, boolean ctrl, boolean shift, boolean meta, int delay) {
            log("KeyPressThread constructor " + charCode + ", " + keyCode);
            this.charCode = charCode;
            this.keyCode = keyCode;
            this.alt = alt;
            this.ctrl = ctrl;
            this.shift = shift;
            this.meta = meta;
            this.delay = delay;
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24621.java,493,507
default,64200.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,118405.java,260,270
default,44026.java,297,306
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,113166.java,54,62
default,39091.java,73,82
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109585.java,463,505
default,19811.java,443,485
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59031.java,31,46
default,46978.java,31,46
----------------------------------------
    public static void doVersionCheck(View view, String stableBuild, String develBuild) {
        String myBuild = jEdit.getBuild();
        String pre = myBuild.substring(6, 7);
        String variant;
        String build;
        if (pre.equals("99")) {
            variant = "stable";
            build = stableBuild;
        } else {
            variant = "devel";
            build = develBuild;
        }
        if (develBuild.compareTo(stableBuild) < 0) variant += "-nodevel";
        int retVal = GUIUtilities.confirm(view, "version-check." + variant, new String[] { MiscUtilities.buildToVersion(myBuild), MiscUtilities.buildToVersion(stableBuild), MiscUtilities.buildToVersion(develBuild) }, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (retVal == JOptionPane.YES_OPTION) jEdit.openFile(view, jEdit.getProperty("version-check.url"));
    }
----------------------------------------
    public static void doVersionCheck(View view, String stableBuild, String develBuild) {
        String myBuild = jEdit.getBuild();
        String pre = myBuild.substring(6, 7);
        String variant;
        String build;
        if (pre.equals("99")) {
            variant = "stable";
            build = stableBuild;
        } else {
            variant = "devel";
            build = develBuild;
        }
        if (develBuild.compareTo(stableBuild) < 0) variant += "-nodevel";
        int retVal = GUIUtilities.confirm(view, "version-check." + variant, new String[] { MiscUtilities.buildToVersion(myBuild), MiscUtilities.buildToVersion(stableBuild), MiscUtilities.buildToVersion(develBuild) }, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (retVal == JOptionPane.YES_OPTION) jEdit.openFile(view, jEdit.getProperty("version-check.url"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,548,570
default,36322.java,629,646
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,46669.java,579,587
default,56485.java,361,368
----------------------------------------
    private byte[] addAgentToThemeMap(HTTPurl urlData) throws Exception {
        String agent = urlData.getParameter("agent");
        String theme = urlData.getParameter("theme");
        store.addAgentToThemeMap(agent, theme);
        StringBuffer buff = new StringBuffer();
        buff.append("HTTP/1.0 302 Moved Temporarily\n");
        buff.append("Location: /servlet/SystemDataRes?action=19\n\n");
        return buff.toString().getBytes();
    }
----------------------------------------
    private byte[] remEpgWatchList(HTTPurl urlData) throws Exception {
        String watchlist = urlData.getParameter("watchlist");
        store.removeEpgWatchList(watchlist);
        StringBuffer buff = new StringBuffer();
        buff.append("HTTP/1.0 302 Moved Temporarily\n");
        buff.append("Location: /servlet/EpgAutoAddDataRes?action=33\n\n");
        return buff.toString().getBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,104755.java,126,138
default,100171.java,126,138
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,117763.java,126,138
default,104755.java,126,138
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,111141.java,73,89
default,8986.java,73,89
----------------------------------------
                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
----------------------------------------
                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103146.java,394,404
default,118405.java,394,404
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98834.java,293,309
default,98834.java,663,680
----------------------------------------
    public void testReadTryLockWhenLocked() {
        final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
        lock.writeLock().lock();
        Thread t = new Thread(new Runnable() {

            public void run() {
                threadAssertFalse(lock.readLock().tryLock());
            }
        });
        try {
            t.start();
            t.join();
            lock.writeLock().unlock();
        } catch (Exception e) {
            unexpectedException();
        }
    }
----------------------------------------
    public void testTryLockWhenReadLocked() {
        final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
        lock.readLock().lock();
        Thread t = new Thread(new Runnable() {

            public void run() {
                threadAssertTrue(lock.readLock().tryLock());
                lock.readLock().unlock();
            }
        });
        try {
            t.start();
            t.join();
            lock.readLock().unlock();
        } catch (Exception e) {
            unexpectedException();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14709.java,292,301
default,79012.java,260,270
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,78674.java,126,138
default,57755.java,126,138
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
    public void testCasting() {
        List students = new ArrayList();
        students.add(new Student("a"));
        students.add(new Student("b"));
        List names = new ArrayList();
        Iterator it = students.iterator();
        while (it.hasNext()) {
            Student student = (Student) it.next();
            names.add(student.getLastName());
        }
        assertEquals("a", names.get(0));
        assertEquals("b", names.get(1));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,137594.java,414,433
default,64200.java,414,433
----------------------------------------
    public void append(DirBuilder builder, File file, int[] counter) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                append(builder, files[i], counter);
            }
        } else {
            try {
                counter[1] += builder.addFileRef(file);
                ++counter[0];
                System.out.print('.');
            } catch (DcmParseException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            } catch (IllegalArgumentException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            }
        }
    }
----------------------------------------
    public void append(DirBuilder builder, File file, int[] counter) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                append(builder, files[i], counter);
            }
        } else {
            try {
                counter[1] += builder.addFileRef(file);
                ++counter[0];
                System.out.print('.');
            } catch (DcmParseException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            } catch (IllegalArgumentException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49646.java,1670,1676
default,30953.java,22,29
----------------------------------------
        public TextField(String text, Color color, int xpos, int ypos, int z) {
            this.text = text;
            this.color = color;
            this.xpos = xpos;
            this.ypos = ypos;
            this.z = z;
        }
----------------------------------------
    public OPT_CompilationState(OPT_Instruction call, int mcSizeEstimate, VM_Method computedTarget, boolean isExtant, OPT_Options options, int cmid) {
        this.call = call;
        this.mcSizeEstimate = mcSizeEstimate;
        this.computedTarget = computedTarget;
        this.isExtant = isExtant;
        this.options = options;
        this.cmid = cmid;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4439.java,459,472
default,118405.java,440,452
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,97360.java,606,619
default,79012.java,604,617
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,275,284
default,79012.java,280,289
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            System.out.println(POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]");
            ds.writeDataset(getTransformerHandler(tf, xslt), dict);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
    private void list(String prefix, DirRecord first, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (DirRecord rec = first; rec != null; rec = rec.getNextSibling(onlyInUse)) {
            Dataset ds = rec.getDataset();
            String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + rec.getType() + "]";
            ds.writeDataset2(getTransformerHandler(tf, xslt, prompt), dict, null, 128, null);
            list(prefix + count + '.', rec.getFirstChild(onlyInUse), tf, xslt);
            ++count;
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,121654.java,159,173
default,39836.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109369.java,199,206
default,98990.java,199,206
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,548,570
default,36322.java,648,665
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,124843.java,546,568
default,79012.java,629,646
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,135495.java,522,544
default,95647.java,648,665
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,118405.java,459,472
default,5621.java,440,452
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void compact() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        try {
            writer = writer.compact();
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("compactDone"), new Object[] { dirFile, String.valueOf(len1), String.valueOf(len2), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,100171.java,73,82
default,97910.java,54,62
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79128.java,125,141
default,48453.java,125,141
----------------------------------------
                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
----------------------------------------
                public void run() {
                    int exitCode = -99;
                    boolean exited = false;
                    do {
                        try {
                            exitCode = tac.exitValue();
                            exited = true;
                        } catch (IllegalThreadStateException e) {
                            System.out.println("still alive!");
                            try {
                                Thread.sleep(1000);
                            } catch (Exception ee) {
                            }
                        }
                    } while (!exited);
                    System.out.println("exitValue(): Process exited with code " + exitCode);
                }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,34614.java,1344,1364
default,76704.java,1344,1364
----------------------------------------
    public void doSetPreference(String command, String[] args) {
        StringBuffer ret = new StringBuffer();
        if (args.length == 0) {
            ret.append("Current preferences: \n");
            ret.append("  integer = " + integerPreference + "\n");
            ret.append("  stack = " + stackPreference + "\n");
            ret.append("  fpr = " + fprPreference + "\n");
            jdp_console.writeOutput(ret.toString());
        } else if (args[0].equals("int")) {
            if (args[1].equals("hexadecimal") || args[1].equals("hex") || args[1].equals("x")) integerPreference = 'x'; else if (args[1].equals("decimal") || args[1].equals("dec") || args[1].equals("d")) integerPreference = 'd'; else printHelp(command);
            return;
        } else if (args[0].equals("stack")) {
            if (args[1].equals("hexadecimal") || args[1].equals("hex") || args[1].equals("x")) stackPreference = 'x'; else if (args[1].equals("decimal") || args[1].equals("dec") || args[1].equals("d")) stackPreference = 'd'; else printHelp(command);
            return;
        } else if (args[0].equals("fpr")) {
            if (args[1].equals("hexadecimal") || args[1].equals("hex") || args[1].equals("x")) fprPreference = 'x'; else if (args[1].equals("float") || args[1].equals("f")) fprPreference = 'f'; else printHelp(command);
            return;
        } else {
            printHelp(command);
        }
    }
----------------------------------------
    public void doSetPreference(String command, String[] args) {
        StringBuffer ret = new StringBuffer();
        if (args.length == 0) {
            ret.append("Current preferences: \n");
            ret.append("  integer = " + integerPreference + "\n");
            ret.append("  stack = " + stackPreference + "\n");
            ret.append("  fpr = " + fprPreference + "\n");
            jdp_console.writeOutput(ret.toString());
        } else if (args[0].equals("int")) {
            if (args[1].equals("hexadecimal") || args[1].equals("hex") || args[1].equals("x")) integerPreference = 'x'; else if (args[1].equals("decimal") || args[1].equals("dec") || args[1].equals("d")) integerPreference = 'd'; else printHelp(command);
            return;
        } else if (args[0].equals("stack")) {
            if (args[1].equals("hexadecimal") || args[1].equals("hex") || args[1].equals("x")) stackPreference = 'x'; else if (args[1].equals("decimal") || args[1].equals("dec") || args[1].equals("d")) stackPreference = 'd'; else printHelp(command);
            return;
        } else if (args[0].equals("fpr")) {
            if (args[1].equals("hexadecimal") || args[1].equals("hex") || args[1].equals("x")) fprPreference = 'x'; else if (args[1].equals("float") || args[1].equals("f")) fprPreference = 'f'; else printHelp(command);
            return;
        } else {
            printHelp(command);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,46669.java,1192,1204
default,94873.java,1191,1203
----------------------------------------
    private String checkName(String name) {
        StringBuffer finalName = null;
        try {
            finalName = new StringBuffer(256);
            for (int x = 0; x < name.length(); x++) {
                char charAt = name.charAt(x);
                if ((charAt >= 'a' && charAt <= 'z') || (charAt >= 'A' && charAt <= 'Z') || (charAt >= '0' && charAt <= '9') || charAt == ' ') finalName.append(charAt); else finalName.append('-');
            }
        } catch (Exception e) {
            name = "error";
        }
        return finalName.toString();
    }
----------------------------------------
    private String checkName(String name) {
        StringBuffer finalName = null;
        try {
            finalName = new StringBuffer(256);
            for (int x = 0; x < name.length(); x++) {
                char charAt = name.charAt(x);
                if ((charAt >= 'a' && charAt <= 'z') || (charAt >= 'A' && charAt <= 'Z') || (charAt >= '0' && charAt <= '9') || charAt == ' ') finalName.append(charAt); else finalName.append('-');
            }
        } catch (Exception e) {
            name = "error";
        }
        return finalName.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,123634.java,43,52
default,109133.java,43,52
----------------------------------------
    public void testCommas() {
        String sequence = "1,2,3,4,5";
        assertEquals(sequence, sequenceUsingDo(1, 5));
        assertEquals(sequence, sequenceUsingFor(1, 5));
        assertEquals(sequence, sequenceUsingWhile(1, 5));
        sequence = "8";
        assertEquals(sequence, sequenceUsingDo(8, 8));
        assertEquals(sequence, sequenceUsingFor(8, 8));
        assertEquals(sequence, sequenceUsingWhile(8, 8));
    }
----------------------------------------
    public void testCommas() {
        String sequence = "1,2,3,4,5";
        assertEquals(sequence, sequenceUsingDo(1, 5));
        assertEquals(sequence, sequenceUsingFor(1, 5));
        assertEquals(sequence, sequenceUsingWhile(1, 5));
        sequence = "8";
        assertEquals(sequence, sequenceUsingDo(8, 8));
        assertEquals(sequence, sequenceUsingFor(8, 8));
        assertEquals(sequence, sequenceUsingWhile(8, 8));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,87653.java,370,377
default,46669.java,1206,1215
----------------------------------------
    private byte[] remEpgWatchList(HTTPurl urlData) throws Exception {
        String watchlist = urlData.getParameter("watchlist");
        store.removeEpgWatchList(watchlist);
        StringBuffer buff = new StringBuffer();
        buff.append("HTTP/1.0 302 Moved Temporarily\n");
        buff.append("Location: /servlet/EpgAutoAddDataRes?action=33\n\n");
        return buff.toString().getBytes();
    }
----------------------------------------
    private byte[] exportTaskList(HTTPurl urlData) throws Exception {
        StringBuffer buff = new StringBuffer();
        buff.append("HTTP/1.0 200 OK\nContent-Type: text/xml\n");
        buff.append("Content-Disposition: attachment; filename=\"Tasks.xml\"\n");
        buff.append("Pragma: no-cache\n");
        buff.append("Cache-Control: no-cache\n");
        buff.append("\n");
        store.saveTaskList(buff);
        return buff.toString().getBytes();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,81085.java,84,91
default,55192.java,84,91
----------------------------------------
    public void testEndTrim() {
        assertEquals("", endTrim(""));
        assertEquals("  x", endTrim("  x  "));
        assertEquals("y", endTrim("y"));
        assertEquals("xaxa", endTrim("xaxa"));
        assertEquals("", endTrim(" "));
        assertEquals("xxx", endTrim("xxx      "));
    }
----------------------------------------
    public void testEndTrim() {
        assertEquals("", endTrim(""));
        assertEquals("  x", endTrim("  x  "));
        assertEquals("y", endTrim("y"));
        assertEquals("xaxa", endTrim("xaxa"));
        assertEquals("", endTrim(" "));
        assertEquals("xxx", endTrim("xxx      "));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,92220.java,667,685
default,79012.java,648,665
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,367,379
default,118405.java,367,379
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
    private void addDirBuilderPrefElem(HashMap map, String key) {
        if (!key.startsWith("dir.")) {
            return;
        }
        int pos2 = key.lastIndexOf('.');
        String type = key.substring(4, pos2).replace('_', ' ');
        Dataset ds = (Dataset) map.get(type);
        if (ds == null) {
            map.put(type, ds = dof.newDataset());
        }
        int tag = Tags.forName(key.substring(pos2 + 1));
        ds.putXX(tag, VRMap.DEFAULT.lookup(tag));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,86457.java,64,71
default,10736.java,73,82
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,27366.java,36,41
default,11030.java,36,41
----------------------------------------
    public void testForSkip() {
        StringBuilder builder = new StringBuilder();
        String string = "123456";
        for (int i = 0; i < string.length(); i += 2) builder.append(string.charAt(i));
        assertEquals("135", builder.toString());
    }
----------------------------------------
    public void testForSkip() {
        StringBuilder builder = new StringBuilder();
        String string = "123456";
        for (int i = 0; i < string.length(); i += 2) builder.append(string.charAt(i));
        assertEquals("135", builder.toString());
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,24621.java,648,665
default,14709.java,643,660
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45549.java,667,685
default,14709.java,643,660
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,631,648
default,98990.java,629,646
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,109369.java,648,665
default,27552.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,41408.java,175,180
default,104755.java,175,180
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,65413.java,669,687
default,98990.java,629,646
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19543.java,228,241
default,50381.java,238,251
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43887.java,247,263
default,19543.java,243,259
----------------------------------------
    public void echo() throws InterruptedException, IOException, GeneralSecurityException {
        long t1 = System.currentTimeMillis();
        int count = 0;
        for (int i = 0; i < repeatWhole; ++i) {
            ActiveAssociation active = openAssoc();
            if (active != null) {
                if (active.getAssociation().getAcceptedTransferSyntaxUID(PCID_ECHO) == null) {
                    log.error(messages.getString("noPCEcho"));
                } else for (int j = 0; j < repeatSingle; ++j, ++count) {
                    active.invoke(aFact.newDimse(PCID_ECHO, oFact.newCommand().initCEchoRQ(j)), null);
                }
                active.release(true);
            }
        }
        long dt = System.currentTimeMillis() - t1;
        log.info(MessageFormat.format(messages.getString("echoDone"), new Object[] { new Integer(count), new Long(dt) }));
    }
----------------------------------------
    public void echo() throws InterruptedException, IOException, GeneralSecurityException {
        long t1 = System.currentTimeMillis();
        int count = 0;
        for (int i = 0; i < repeatWhole; ++i) {
            ActiveAssociation active = openAssoc();
            if (active != null) {
                if (active.getAssociation().getAcceptedTransferSyntaxUID(PCID_ECHO) == null) {
                    log.error(messages.getString("noPCEcho"));
                } else for (int j = 0; j < repeatSingle; ++j, ++count) {
                    active.invoke(aFact.newDimse(PCID_ECHO, oFact.newCommand().initCEchoRQ(j)), null);
                }
                active.release(true);
            }
        }
        long dt = System.currentTimeMillis() - t1;
        log.info(MessageFormat.format(messages.getString("echoDone"), new Object[] { new Integer(count), new Long(dt) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63132.java,73,82
default,86457.java,64,71
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5621.java,459,472
default,49247.java,459,472
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90330.java,404,426
default,27552.java,546,568
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,104755.java,194,203
default,16496.java,194,203
----------------------------------------
    public void testRetroCollections() {
        {
            List names = new Vector();
            Map dictionary = new Hashtable();
        }
        {
            List<String> names = new Vector<String>();
            Map<String, String> dictionary = new Hashtable<String, String>();
        }
    }
----------------------------------------
    public void testRetroCollections() {
        {
            List names = new Vector();
            Map dictionary = new Hashtable();
        }
        {
            List<String> names = new Vector<String>();
            Map<String, String> dictionary = new Hashtable<String, String>();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49247.java,474,483
default,95647.java,474,483
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28859.java,413,448
default,552.java,413,448
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
        public void writeTo(OutputStream out, String tsUID) throws IOException {
            DcmEncodeParam netParam = (DcmEncodeParam) DcmDecodeParam.valueOf(tsUID);
            if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            if (parser.getReadTag() == Tags.PixelData) {
                DcmDecodeParam fileParam = parser.getDcmDecodeParam();
                ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                if (netParam.encapsulated) {
                    parser.parseHeader();
                    while (parser.getReadTag() == Tags.Item) {
                        ds.writeHeader(out, netParam, parser.getReadTag(), parser.getReadVR(), parser.getReadLength());
                        writeValueTo(out, false);
                        parser.parseHeader();
                    }
                    if (parser.getReadTag() != Tags.SeqDelimitationItem) {
                        throw new DcmParseException("Unexpected Tag:" + Tags.toString(parser.getReadTag()));
                    }
                    if (parser.getReadLength() != 0) {
                        throw new DcmParseException("(fffe,e0dd), Length:" + parser.getReadLength());
                    }
                    ds.writeHeader(out, netParam, Tags.SeqDelimitationItem, VRs.NONE, 0);
                } else {
                    boolean swap = fileParam.byteOrder != netParam.byteOrder && parser.getReadVR() == VRs.OW;
                    writeValueTo(out, swap);
                }
                if (truncPostPixelData) {
                    return;
                }
                ds.clear();
                try {
                    parser.parseDataset(fileParam, -1);
                } catch (IOException e) {
                    log.warn("Error reading post-pixeldata attributes:", e);
                }
                if (excludePrivate) ds.excludePrivate().writeDataset(out, netParam); else ds.writeDataset(out, netParam);
            }
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,21860.java,322,360
default,109803.java,281,314
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32710.java,239,291
default,113275.java,239,291
----------------------------------------
    static Object createRJavaLoader(String rhome, String[] cp, boolean addJRI) {
        String rJavaRoot = null;
        if (rs_libs != null && rs_libs.length() > 0) rJavaRoot = findInPath(rs_libs, "rJava", false);
        if (rJavaRoot == null) rJavaRoot = u2w(rhome + "/library/rJava");
        if (!(new File(rJavaRoot)).exists()) {
            lastError = "Unable to find rJava";
            return null;
        }
        File f = new File(u2w(rJavaRoot + "/java/boot"));
        if (!f.exists()) {
            lastError = "rJava too old";
            return null;
        }
        String rJavaHome = u2w(rJavaRoot);
        File lf = null;
        if (rs_arch != null && rs_arch.length() > 0) lf = new File(u2w(rJavaRoot + "/libs" + rs_arch));
        if (lf == null || !lf.exists()) lf = new File(u2w(rJavaRoot + "/libs/" + arch()));
        if (!lf.exists()) lf = new File(u2w(rJavaRoot + "/libs"));
        String rJavaLibs = lf.toString();
        JRIClassLoader mcl = JRIClassLoader.getMainLoader();
        mcl.addClassPath(f.toString());
        try {
            Class rjlclass = mcl.findAndLinkClass("RJavaClassLoader");
            Constructor c = rjlclass.getConstructor(new Class[] { String.class, String.class });
            Object rjcl = c.newInstance(new Object[] { rJavaHome, rJavaLibs });
            System.out.println("RJavaClassLoader: " + rjcl);
            if (addJRI) {
                if (cp == null || cp.length == 0) cp = new String[] { u2w(rJavaRoot + "/jri/JRI.jar") }; else {
                    String[] ncp = new String[cp.length + 1];
                    System.arraycopy(cp, 0, ncp, 1, cp.length);
                    ncp[0] = u2w(rJavaRoot + "/jri/JRI.jar");
                    cp = ncp;
                }
            }
            if (cp == null || cp.length == 0) cp = new String[] { u2w(rJavaRoot + "/java/boot") }; else {
                String[] ncp = new String[cp.length + 1];
                System.arraycopy(cp, 0, ncp, 1, cp.length);
                ncp[0] = u2w(rJavaRoot + "/java/boot");
                cp = ncp;
            }
            if (cp != null) {
                System.out.println(" - adding class paths");
                Method m = rjlclass.getMethod("addClassPath", new Class[] { String[].class });
                m.invoke(rjcl, new Object[] { cp });
            }
            return rjcl;
        } catch (Exception rtx) {
            System.err.println("ERROR: Unable to create new RJavaClassLoader in JRIBootstrap! (" + rtx + ")");
            rtx.printStackTrace();
            System.exit(2);
        }
        return null;
    }
----------------------------------------
    static Object createRJavaLoader(String rhome, String[] cp, boolean addJRI) {
        String rJavaRoot = null;
        if (rs_libs != null && rs_libs.length() > 0) rJavaRoot = findInPath(rs_libs, "rJava", false);
        if (rJavaRoot == null) rJavaRoot = u2w(rhome + "/library/rJava");
        if (!(new File(rJavaRoot)).exists()) {
            lastError = "Unable to find rJava";
            return null;
        }
        File f = new File(u2w(rJavaRoot + "/java/boot"));
        if (!f.exists()) {
            lastError = "rJava too old";
            return null;
        }
        String rJavaHome = u2w(rJavaRoot);
        File lf = null;
        if (rs_arch != null && rs_arch.length() > 0) lf = new File(u2w(rJavaRoot + "/libs" + rs_arch));
        if (lf == null || !lf.exists()) lf = new File(u2w(rJavaRoot + "/libs/" + arch()));
        if (!lf.exists()) lf = new File(u2w(rJavaRoot + "/libs"));
        String rJavaLibs = lf.toString();
        JRIClassLoader mcl = JRIClassLoader.getMainLoader();
        mcl.addClassPath(f.toString());
        try {
            Class rjlclass = mcl.findAndLinkClass("RJavaClassLoader");
            Constructor c = rjlclass.getConstructor(new Class[] { String.class, String.class });
            Object rjcl = c.newInstance(new Object[] { rJavaHome, rJavaLibs });
            System.out.println("RJavaClassLoader: " + rjcl);
            if (addJRI) {
                if (cp == null || cp.length == 0) cp = new String[] { u2w(rJavaRoot + "/jri/JRI.jar") }; else {
                    String[] ncp = new String[cp.length + 1];
                    System.arraycopy(cp, 0, ncp, 1, cp.length);
                    ncp[0] = u2w(rJavaRoot + "/jri/JRI.jar");
                    cp = ncp;
                }
            }
            if (cp == null || cp.length == 0) cp = new String[] { u2w(rJavaRoot + "/java/boot") }; else {
                String[] ncp = new String[cp.length + 1];
                System.arraycopy(cp, 0, ncp, 1, cp.length);
                ncp[0] = u2w(rJavaRoot + "/java/boot");
                cp = ncp;
            }
            if (cp != null) {
                System.out.println(" - adding class paths");
                Method m = rjlclass.getMethod("addClassPath", new Class[] { String[].class });
                m.invoke(rjcl, new Object[] { cp });
            }
            return rjcl;
        } catch (Exception rtx) {
            System.err.println("ERROR: Unable to create new RJavaClassLoader in JRIBootstrap! (" + rtx + ")");
            rtx.printStackTrace();
            System.exit(2);
        }
        return null;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,96830.java,64,71
default,11030.java,64,71
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingFor(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        for (int i = start; i <= stop; i++) {
            if (i > start) builder.append(',');
            builder.append(i);
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,111141.java,55,69
default,48453.java,73,89
----------------------------------------
                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
----------------------------------------
                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,19573.java,648,665
default,98990.java,629,646
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,23689.java,695,703
default,94364.java,695,703
----------------------------------------
    public boolean isValidVMThread(int threadPointer) throws Exception {
        int vmthreads[] = getAllThreads();
        for (int i = 0; i < vmthreads.length; i++) {
            if (threadPointer == vmthreads[i]) {
                return true;
            }
        }
        return false;
    }
----------------------------------------
    public boolean isValidVMThread(int threadPointer) throws Exception {
        int vmthreads[] = getAllThreads();
        for (int i = 0; i < vmthreads.length; i++) {
            if (threadPointer == vmthreads[i]) {
                return true;
            }
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,9693.java,197,213
default,37347.java,200,214
----------------------------------------
    DcmGen(Configuration cfg, DcmURL url, int argc) {
        this.url = url;
        this.priority = Integer.parseInt(cfg.getProperty("prior", "0"));
        this.packPDVs = "true".equalsIgnoreCase(cfg.getProperty("pack-pdvs", "false"));
        this.truncPostPixelData = "true".equalsIgnoreCase(cfg.getProperty("trunc-post-pixeldata", "false"));
        this.excludePrivate = "true".equalsIgnoreCase(cfg.getProperty("exclude-private", "false"));
        this.bufferSize = Integer.parseInt(cfg.getProperty("buf-len", "2048")) & 0xfffffffe;
        this.repeatWhole = Integer.parseInt(cfg.getProperty("repeat-assoc", "1"));
        this.repeatSingle = Integer.parseInt(cfg.getProperty("repeat-dimse", "1"));
        this.uidSuffix = cfg.getProperty("uid-suffix");
        this.mode = argc > 1 ? SEND : ECHO;
        this.random = "true".equalsIgnoreCase(cfg.getProperty("set-random", "false"));
        this.complete = "true".equalsIgnoreCase(cfg.getProperty("set-complete", "false"));
        initAssocParam(cfg, url, mode == ECHO);
        initTLS(cfg);
        initOverwrite(cfg);
    }
----------------------------------------
    DcmSnd(Configuration cfg, DcmURL url, int argc) {
        this.url = url;
        this.priority = Integer.parseInt(cfg.getProperty("prior", "0"));
        this.packPDVs = "true".equalsIgnoreCase(cfg.getProperty("pack-pdvs", "false"));
        this.truncPostPixelData = "true".equalsIgnoreCase(cfg.getProperty("trunc-post-pixeldata", "false"));
        this.excludePrivate = "true".equalsIgnoreCase(cfg.getProperty("exclude-private", "false"));
        this.bufferSize = Integer.parseInt(cfg.getProperty("buf-len", "2048")) & 0xfffffffe;
        this.repeatWhole = Integer.parseInt(cfg.getProperty("repeat-assoc", "1"));
        this.repeatSingle = Integer.parseInt(cfg.getProperty("repeat-dimse", "1"));
        this.uidSuffix = cfg.getProperty("uid-suffix");
        this.mode = argc > 1 ? SEND : initPollDirSrv(cfg) ? POLL : ECHO;
        initAssocParam(cfg, url, mode == ECHO);
        initTLS(cfg);
        initOverwrite(cfg);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,26124.java,197,213
default,37347.java,200,214
----------------------------------------
    DcmGen(Configuration cfg, DcmURL url, int argc) {
        this.url = url;
        this.priority = Integer.parseInt(cfg.getProperty("prior", "0"));
        this.packPDVs = "true".equalsIgnoreCase(cfg.getProperty("pack-pdvs", "false"));
        this.truncPostPixelData = "true".equalsIgnoreCase(cfg.getProperty("trunc-post-pixeldata", "false"));
        this.excludePrivate = "true".equalsIgnoreCase(cfg.getProperty("exclude-private", "false"));
        this.bufferSize = Integer.parseInt(cfg.getProperty("buf-len", "2048")) & 0xfffffffe;
        this.repeatWhole = Integer.parseInt(cfg.getProperty("repeat-assoc", "1"));
        this.repeatSingle = Integer.parseInt(cfg.getProperty("repeat-dimse", "1"));
        this.uidSuffix = cfg.getProperty("uid-suffix");
        this.mode = argc > 1 ? SEND : ECHO;
        this.random = "true".equalsIgnoreCase(cfg.getProperty("set-random", "false"));
        this.complete = "true".equalsIgnoreCase(cfg.getProperty("set-complete", "false"));
        initAssocParam(cfg, url, mode == ECHO);
        initTLS(cfg);
        initOverwrite(cfg);
    }
----------------------------------------
    DcmSnd(Configuration cfg, DcmURL url, int argc) {
        this.url = url;
        this.priority = Integer.parseInt(cfg.getProperty("prior", "0"));
        this.packPDVs = "true".equalsIgnoreCase(cfg.getProperty("pack-pdvs", "false"));
        this.truncPostPixelData = "true".equalsIgnoreCase(cfg.getProperty("trunc-post-pixeldata", "false"));
        this.excludePrivate = "true".equalsIgnoreCase(cfg.getProperty("exclude-private", "false"));
        this.bufferSize = Integer.parseInt(cfg.getProperty("buf-len", "2048")) & 0xfffffffe;
        this.repeatWhole = Integer.parseInt(cfg.getProperty("repeat-assoc", "1"));
        this.repeatSingle = Integer.parseInt(cfg.getProperty("repeat-dimse", "1"));
        this.uidSuffix = cfg.getProperty("uid-suffix");
        this.mode = argc > 1 ? SEND : initPollDirSrv(cfg) ? POLL : ECHO;
        initAssocParam(cfg, url, mode == ECHO);
        initTLS(cfg);
        initOverwrite(cfg);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70505.java,572,592
default,14709.java,565,585
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35885.java,63,67
default,84908.java,63,67
----------------------------------------
    public String[] tokenize(String s) {
        if (s == null) return null;
        List l = tokenize(s, new LinkedList());
        return (String[]) l.toArray(new String[l.size()]);
    }
----------------------------------------
    public String[] tokenize(String s) {
        if (s == null) return null;
        List l = tokenize(s, new LinkedList());
        return (String[]) l.toArray(new String[l.size()]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63132.java,149,157
default,99468.java,149,157
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
    public void testTwoDimensionalArrays() {
        final int rows = 3;
        final int cols = 4;
        int count = 0;
        int[][] matrix = new int[rows][cols];
        for (int x = 0; x < rows; x++) for (int y = 0; y < cols; y++) matrix[x][y] = count++;
        assertEquals(11, matrix[2][3]);
        assertEquals(6, matrix[1][2]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,45549.java,546,568
default,98990.java,667,685
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,116202.java,496,500
default,552.java,503,507
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59570.java,6,11
default,86457.java,6,11
----------------------------------------
    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
----------------------------------------
    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40375.java,340,349
default,87896.java,474,483
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
    private void addFileIDs(DirWriter w, File file) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                addFileIDs(w, files[i]);
            }
        } else {
            fileIDs.add(w.toFileIDs(file));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,51702.java,526,534
default,92411.java,542,550
----------------------------------------
    private final void initPresContext(int pcid, List val) {
        Iterator it = val.iterator();
        String as = UIDs.forName((String) it.next());
        String[] tsUIDs = new String[val.size() - 1];
        for (int i = 0; i < tsUIDs.length; ++i) {
            tsUIDs[i] = UIDs.forName((String) it.next());
        }
        assocRQ.addPresContext(aFact.newPresContext(pcid, as, tsUIDs));
    }
----------------------------------------
    private final void initPresContext(int pcid, List val) {
        Iterator it = val.iterator();
        String as = UIDs.forName((String) it.next());
        String[] tsUIDs = new String[val.size() - 1];
        for (int i = 0; i < tsUIDs.length; ++i) {
            tsUIDs[i] = UIDs.forName((String) it.next());
        }
        assocRQ.addPresContext(aFact.newPresContext(pcid, as, tsUIDs));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,297,306
default,93531.java,260,270
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79290.java,210,223
default,5224.java,228,241
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28707.java,99,111
default,55192.java,99,111
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
    public void testLabeledBreak() {
        List<List<String>> table = new ArrayList<List<String>>();
        List<String> row1 = new ArrayList<String>();
        row1.add("5");
        row1.add("2");
        List<String> row2 = new ArrayList<String>();
        row2.add("3");
        row2.add("4");
        table.add(row1);
        table.add(row2);
        assertTrue(found(table, "3"));
        assertFalse(found(table, "8"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,137594.java,570,590
default,44026.java,648,665
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,115106.java,151,167
default,110133.java,151,167
----------------------------------------
    public static Sequence prepareFastaRead(String fastafile) {
        Sequence s = null;
        try {
            BufferedReader is = new BufferedReader(new FileReader(fastafile));
            SequenceIterator si = SeqIOTools.readFastaDNA(is);
            if (si.hasNext()) {
                s = si.nextSequence();
            }
        } catch (BioException ex) {
            ex.printStackTrace();
        } catch (NoSuchElementException ex) {
            ex.printStackTrace();
        } catch (FileNotFoundException ex) {
            ex.printStackTrace();
        }
        return s;
    }
----------------------------------------
    public static Sequence prepareFastaRead(String fastafile) {
        Sequence s = null;
        try {
            BufferedReader is = new BufferedReader(new FileReader(fastafile));
            SequenceIterator si = SeqIOTools.readFastaDNA(is);
            if (si.hasNext()) {
                s = si.nextSequence();
            }
        } catch (BioException ex) {
            ex.printStackTrace();
        } catch (NoSuchElementException ex) {
            ex.printStackTrace();
        } catch (FileNotFoundException ex) {
            ex.printStackTrace();
        }
        return s;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,49247.java,546,568
default,95647.java,667,685
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53104.java,546,568
default,49247.java,546,568
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,60222.java,230,246
default,92411.java,265,281
----------------------------------------
    public void send(String[] args, int offset) throws InterruptedException, IOException, GeneralSecurityException {
        if (bufferSize > 0) {
            buffer = new byte[bufferSize];
        }
        long t1 = System.currentTimeMillis();
        for (int i = 0; i < repeatWhole; ++i) {
            ActiveAssociation active = openAssoc();
            if (active != null) {
                for (int k = offset; k < args.length; ++k) {
                    send(active, new File(args[k]));
                }
                active.release(true);
            }
        }
        long dt = System.currentTimeMillis() - t1;
        log.info(MessageFormat.format(messages.getString("sendDone"), new Object[] { new Integer(sentCount), new Long(sentBytes), new Long(dt), new Float(sentBytes / (1.024f * dt)) }));
    }
----------------------------------------
    public void send(String[] args, int offset) throws InterruptedException, IOException, GeneralSecurityException {
        if (bufferSize > 0) {
            buffer = new byte[bufferSize];
        }
        long t1 = System.currentTimeMillis();
        for (int i = 0; i < repeatWhole; ++i) {
            ActiveAssociation active = openAssoc();
            if (active != null) {
                for (int k = offset; k < args.length; ++k) {
                    send(active, new File(args[k]));
                }
                active.release(true);
            }
        }
        long dt = System.currentTimeMillis() - t1;
        log.info(MessageFormat.format(messages.getString("sendDone"), new Object[] { new Integer(sentCount), new Long(sentBytes), new Long(dt), new Float(sentBytes / (1.024f * dt)) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,199,206
default,86184.java,126,133
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void set(Configuration cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("set." + s, "");
        } else {
            cfg.put("set." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,116906.java,381,392
default,62365.java,381,392
----------------------------------------
    private DirBuilderPref getDirBuilderPref() {
        HashMap map = new HashMap();
        for (Enumeration en = cfg.keys(); en.hasMoreElements(); ) {
            addDirBuilderPrefElem(map, (String) en.nextElement());
        }
        DirBuilderPref pref = fact.newDirBuilderPref();
        for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry entry = (Map.Entry) it.next();
            pref.setFilterForRecordType((String) entry.getKey(), (Dataset) entry.getValue());
        }
        return pref;
    }
----------------------------------------
    private DirBuilderPref getDirBuilderPref() {
        HashMap map = new HashMap();
        for (Enumeration en = cfg.keys(); en.hasMoreElements(); ) {
            addDirBuilderPrefElem(map, (String) en.nextElement());
        }
        DirBuilderPref pref = fact.newDirBuilderPref();
        for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry entry = (Map.Entry) it.next();
            pref.setFilterForRecordType((String) entry.getKey(), (Dataset) entry.getValue());
        }
        return pref;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,41408.java,159,173
default,97910.java,159,173
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
    public void testPartialDimensions() {
        final int rows = 3;
        int[][] matrix = new int[rows][];
        matrix[0] = new int[] { 0 };
        matrix[1] = new int[] { 1, 2 };
        matrix[2] = new int[] { 3, 4, 5 };
        assertEquals(1, matrix[1][0]);
        assertEquals(5, matrix[2][2]);
        int[][] matrix2 = { { 0 }, { 1, 2 }, { 3, 4, 5 } };
        assertEquals(1, matrix2[1][0]);
        assertEquals(5, matrix2[2][2]);
        int[] z1 = { 3, 4, 5 };
        int[] z2 = { 3, 4, 5 };
        assertTrue(Arrays.equals(z1, z2));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,39986.java,175,180
default,97910.java,175,180
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
    public void testArrayEquality() {
        int[] a = { 1, 2, 3 };
        int[] b = { 1, 2, 3 };
        assertFalse(a.equals(b));
        assertFalse(a == b);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44026.java,648,665
default,64200.java,570,590
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,629,646
default,49247.java,648,665
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,53104.java,522,544
default,98990.java,667,685
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,75105.java,73,89
default,98852.java,55,69
----------------------------------------
                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
----------------------------------------
                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,57607.java,232,245
default,57136.java,228,241
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,67537.java,309,347
default,86184.java,306,344
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file, Dataset mergeDataset) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                try {
                    FileFormat format = parser.detectFileFormat();
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } catch (DcmParseException e) {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, merge(ds, mergeDataset));
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
    private boolean sendFile(ActiveAssociation active, File file) throws InterruptedException, IOException {
        InputStream in = null;
        DcmParser parser = null;
        Dataset ds = null;
        try {
            try {
                in = new BufferedInputStream(new FileInputStream(file));
                parser = pFact.newDcmParser(in);
                FileFormat format = parser.detectFileFormat();
                if (format != null) {
                    ds = oFact.newDataset();
                    parser.setDcmHandler(ds.getDcmHandler());
                    parser.parseDcmFile(format, Tags.PixelData);
                    if (parser.getReadTag() == Tags.PixelData) {
                        if (parser.getStreamPosition() + parser.getReadLength() > file.length()) {
                            throw new EOFException("Pixel Data Length: " + parser.getReadLength() + " exceeds file length: " + file.length());
                        }
                    }
                    log.info(MessageFormat.format(messages.getString("readDone"), new Object[] { file }));
                } else {
                    log.error(MessageFormat.format(messages.getString("failformat"), new Object[] { file }));
                    return false;
                }
            } catch (IOException e) {
                log.error(MessageFormat.format(messages.getString("failread"), new Object[] { file, e }));
                return false;
            }
            sendDataset(active, file, parser, ds);
            return true;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
                ;
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,32654.java,570,590
default,40375.java,506,523
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,94821.java,624,641
default,49247.java,648,665
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,88095.java,496,500
default,132039.java,496,500
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,102852.java,11,28
default,14511.java,11,28
----------------------------------------
    public static void main(String[] argv) {
        try {
            int num = 1;
            if (argv.length > 0) {
                num = Integer.parseInt(argv[0]);
            }
            Thread[] threadList = new Thread[num];
            for (int i = 0; i < num; ++i) {
                threadList[i] = new TestRuntimeExec(i);
                threadList[i].start();
            }
            for (int i = 0; i < num; ++i) threadList[i].join();
            System.out.println("All test threads finished");
        } catch (Exception e) {
            System.out.println("TestRuntimeExec: FAILED");
            System.exit(1);
        }
    }
----------------------------------------
    public static void main(String[] argv) {
        try {
            int num = 1;
            if (argv.length > 0) {
                num = Integer.parseInt(argv[0]);
            }
            Thread[] threadList = new Thread[num];
            for (int i = 0; i < num; ++i) {
                threadList[i] = new TestRuntimeExec(i);
                threadList[i].start();
            }
            for (int i = 0; i < num; ++i) threadList[i].join();
            System.out.println("All test threads finished");
        } catch (Exception e) {
            System.out.println("TestRuntimeExec: FAILED");
            System.exit(1);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,60222.java,327,355
default,5224.java,349,379
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        doOverwrite(ds);
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
    private boolean sendDataset(ActiveAssociation active, File file, DcmParser parser, Dataset ds) throws InterruptedException, IOException {
        if (uidSuffix != null && uidSuffix.length() > 0) {
            applyUIDSuffix(ds);
        }
        String sopInstUID = ds.getString(Tags.SOPInstanceUID);
        if (sopInstUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPinst"), new Object[] { file }));
            return false;
        }
        String sopClassUID = ds.getString(Tags.SOPClassUID);
        if (sopClassUID == null) {
            log.error(MessageFormat.format(messages.getString("noSOPclass"), new Object[] { file }));
            return false;
        }
        PresContext pc = null;
        Association assoc = active.getAssociation();
        if (parser.getDcmDecodeParam().encapsulated) {
            String tsuid = ds.getFileMetaInfo().getTransferSyntaxUID();
            if ((pc = assoc.getAcceptedPresContext(sopClassUID, tsuid)) == null) {
                log.error(MessageFormat.format(messages.getString("noPCStore3"), new Object[] { uidDict.lookup(sopClassUID), uidDict.lookup(tsuid), file }));
                return false;
            }
        } else if ((pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ImplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRLittleEndian)) == null && (pc = assoc.getAcceptedPresContext(sopClassUID, UIDs.ExplicitVRBigEndian)) == null) {
            log.error(MessageFormat.format(messages.getString("noPCStore2"), new Object[] { uidDict.lookup(sopClassUID), file }));
            return false;
        }
        active.invoke(aFact.newDimse(pc.pcid(), oFact.newCommand().initCStoreRQ(assoc.nextMsgID(), sopClassUID, sopInstUID, priority), new MyDataSource(parser, ds, buffer)), null);
        sentBytes += parser.getStreamPosition();
        ++sentCount;
        return true;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,8952.java,648,665
default,40375.java,380,402
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,27366.java,19,34
default,42254.java,19,34
----------------------------------------
    public void testPalindrome() {
        assertFalse(isPalindrome("abcdef"));
        assertFalse(isPalindrome("abccda"));
        assertTrue(isPalindrome("abccba"));
        assertFalse(isPalindrome("abcxba"));
        assertTrue(isPalindrome("a"));
        assertTrue(isPalindrome("aa"));
        assertFalse(isPalindrome("ab"));
        assertTrue(isPalindrome(""));
        assertTrue(isPalindrome("aaa"));
        assertTrue(isPalindrome("aba"));
        assertTrue(isPalindrome("abbba"));
        assertTrue(isPalindrome("abba"));
        assertFalse(isPalindrome("abbaa"));
        assertFalse(isPalindrome("abcda"));
    }
----------------------------------------
    public void testPalindrome() {
        assertFalse(isPalindrome("abcdef"));
        assertFalse(isPalindrome("abccda"));
        assertTrue(isPalindrome("abccba"));
        assertFalse(isPalindrome("abcxba"));
        assertTrue(isPalindrome("a"));
        assertTrue(isPalindrome("aa"));
        assertFalse(isPalindrome("ab"));
        assertTrue(isPalindrome(""));
        assertTrue(isPalindrome("aaa"));
        assertTrue(isPalindrome("aba"));
        assertTrue(isPalindrome("abbba"));
        assertTrue(isPalindrome("abba"));
        assertFalse(isPalindrome("abbaa"));
        assertFalse(isPalindrome("abcda"));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,26187.java,573,587
default,86184.java,573,587
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70515.java,43,52
default,104630.java,43,52
----------------------------------------
    public void testCommas() {
        String sequence = "1,2,3,4,5";
        assertEquals(sequence, sequenceUsingDo(1, 5));
        assertEquals(sequence, sequenceUsingFor(1, 5));
        assertEquals(sequence, sequenceUsingWhile(1, 5));
        sequence = "8";
        assertEquals(sequence, sequenceUsingDo(8, 8));
        assertEquals(sequence, sequenceUsingFor(8, 8));
        assertEquals(sequence, sequenceUsingWhile(8, 8));
    }
----------------------------------------
    public void testCommas() {
        String sequence = "1,2,3,4,5";
        assertEquals(sequence, sequenceUsingDo(1, 5));
        assertEquals(sequence, sequenceUsingFor(1, 5));
        assertEquals(sequence, sequenceUsingWhile(1, 5));
        sequence = "8";
        assertEquals(sequence, sequenceUsingDo(8, 8));
        assertEquals(sequence, sequenceUsingFor(8, 8));
        assertEquals(sequence, sequenceUsingWhile(8, 8));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,4439.java,667,685
default,49247.java,667,685
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,5621.java,381,392
default,40375.java,265,276
----------------------------------------
    private DirBuilderPref getDirBuilderPref() {
        HashMap map = new HashMap();
        for (Enumeration en = cfg.keys(); en.hasMoreElements(); ) {
            addDirBuilderPrefElem(map, (String) en.nextElement());
        }
        DirBuilderPref pref = fact.newDirBuilderPref();
        for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry entry = (Map.Entry) it.next();
            pref.setFilterForRecordType((String) entry.getKey(), (Dataset) entry.getValue());
        }
        return pref;
    }
----------------------------------------
    private DirBuilderPref getDirBuilderPref() {
        HashMap map = new HashMap();
        for (Enumeration en = cfg.keys(); en.hasMoreElements(); ) {
            addDirBuilderPrefElem(map, (String) en.nextElement());
        }
        DirBuilderPref pref = fact.newDirBuilderPref();
        for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry entry = (Map.Entry) it.next();
            pref.setFilterForRecordType((String) entry.getKey(), (Dataset) entry.getValue());
        }
        return pref;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,55419.java,80,107
default,134338.java,50,78
----------------------------------------
    public static AudioInputStream getConvertedStream(AudioInputStream sourceStream, AudioFormat.Encoding targetEncoding) throws Exception {
        AudioFormat sourceFormat = sourceStream.getFormat();
        if (!quiet) {
            System.out.println("Input format: " + sourceFormat);
        }
        AudioInputStream targetStream = null;
        if (!AudioSystem.isConversionSupported(targetEncoding, sourceFormat)) {
            if (DEBUG && !quiet) {
                System.out.println("Direct conversion not possible.");
                System.out.println("Trying with intermediate PCM format.");
            }
            AudioFormat intermediateFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, sourceFormat.getSampleRate(), 16, sourceFormat.getChannels(), 2 * sourceFormat.getChannels(), sourceFormat.getSampleRate(), false);
            if (AudioSystem.isConversionSupported(intermediateFormat, sourceFormat)) {
                sourceStream = AudioSystem.getAudioInputStream(intermediateFormat, sourceStream);
            }
        }
        targetStream = AudioSystem.getAudioInputStream(targetEncoding, sourceStream);
        if (targetStream == null) {
            throw new Exception("conversion not supported");
        }
        if (!quiet) {
            if (DEBUG) {
                System.out.println("Got converted AudioInputStream: " + targetStream.getClass().getName());
            }
            System.out.println("Output format: " + targetStream.getFormat());
        }
        return targetStream;
    }
----------------------------------------
    public static AudioInputStream getConvertedStream2(AudioInputStream sourceStream, AudioFormat.Encoding targetEncoding) throws Exception {
        AudioFormat sourceFormat = sourceStream.getFormat();
        if (!quiet) {
            System.out.println("Input format: " + sourceFormat);
        }
        AudioFormat targetFormat = new AudioFormat(targetEncoding, sourceFormat.getSampleRate(), AudioSystem.NOT_SPECIFIED, sourceFormat.getChannels(), AudioSystem.NOT_SPECIFIED, AudioSystem.NOT_SPECIFIED, false);
        AudioInputStream targetStream = null;
        if (!AudioSystem.isConversionSupported(targetFormat, sourceFormat)) {
            if (DEBUG && !quiet) {
                System.out.println("Direct conversion not possible.");
                System.out.println("Trying with intermediate PCM format.");
            }
            AudioFormat intermediateFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, sourceFormat.getSampleRate(), 16, sourceFormat.getChannels(), 2 * sourceFormat.getChannels(), sourceFormat.getSampleRate(), false);
            if (AudioSystem.isConversionSupported(intermediateFormat, sourceFormat)) {
                sourceStream = AudioSystem.getAudioInputStream(intermediateFormat, sourceStream);
            }
        }
        targetStream = AudioSystem.getAudioInputStream(targetFormat, sourceStream);
        if (targetStream == null) {
            throw new Exception("conversion not supported");
        }
        if (!quiet) {
            if (DEBUG) {
                System.out.println("Got converted AudioInputStream: " + targetStream.getClass().getName());
            }
            System.out.println("Output format: " + targetStream.getFormat());
        }
        return targetStream;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,63057.java,503,507
default,40375.java,563,567
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,36322.java,260,270
default,87896.java,260,270
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,37347.java,512,516
default,109803.java,443,447
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,118405.java,570,590
default,8952.java,522,544
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,40375.java,404,426
default,36322.java,667,685
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,42254.java,73,82
default,70893.java,73,82
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingWhile(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        while (i <= stop) {
            if (i > start) builder.append(',');
            builder.append(i);
            i++;
        }
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,552.java,571,585
default,21860.java,589,603
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmGen.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmGen.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
    private void initTLS(Configuration cfg) {
        try {
            cipherSuites = url.getCipherSuites();
            if (cipherSuites == null) {
                return;
            }
            tls = SSLContextAdapter.getInstance();
            char[] keypasswd = cfg.getProperty("tls-key-passwd", "secret").toCharArray();
            tls.setKey(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-key", "identity.p12")), keypasswd), keypasswd);
            tls.setTrust(tls.loadKeyStore(DcmSnd.class.getResource(cfg.getProperty("tls-cacerts", "cacerts.jks")), cfg.getProperty("tls-cacerts-passwd", "secret").toCharArray()));
            tls.init();
        } catch (Exception ex) {
            throw new RuntimeException("Could not initalize TLS configuration: ", ex);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,111141.java,55,69
default,14511.java,73,89
----------------------------------------
                public void run() {
                    DataOutputStream stdin = new DataOutputStream(tac.getOutputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                charsWritten += testData[i].length();
                                stdin.writeUTF(testData[i]);
                            }
                        }
                        stdin.flush();
                        stdin.close();
                    } catch (IOException e) {
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
----------------------------------------
                public void run() {
                    DataInputStream stdout = new DataInputStream(tac.getInputStream());
                    try {
                        for (int x = 0; x < 10000; x++) {
                            for (int i = 0; i < testData.length; i++) {
                                String in = stdout.readUTF();
                                charsRead += in.length();
                                if (!in.equals(testData[i])) throw new Error("TestRuntimeExec FAILED: bad input " + in);
                            }
                        }
                        int exitCode = tac.waitFor();
                        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println("TestRuntimeExec SUCCESS"); else System.err.println("TestRuntimeExec FAILED");
                    } catch (Throwable e) {
                        e.printStackTrace();
                        throw new Error("TestRuntimeExec FAILED");
                    }
                }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,208,241
default,62365.java,208,241
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
    DcmDir(File dirfile, Properties cfg) {
        this.dirFile = dirfile;
        this.cfg = cfg;
        String rm = replace(cfg.getProperty("readme"), "<none>", null);
        if (rm != null) {
            this.readMeFile = new File(rm);
            this.readMeCharset = replace(cfg.getProperty("readme-charset"), "<none>", null);
        }
        this.id = replace(cfg.getProperty("fs-id", ""), "<none>", "");
        this.uid = replace(cfg.getProperty("fs-uid", ""), "<auto>", "");
        this.maxlen = new Integer(cfg.getProperty("maxlen", "79"));
        this.vallen = new Integer(cfg.getProperty("maxlen", "64"));
        this.skipGroupLen = !"<yes>".equals(cfg.getProperty("grouplen"));
        this.undefSeqLen = !"<yes>".equals(cfg.getProperty("seqlen"));
        this.undefItemLen = !"<yes>".equals(cfg.getProperty("itemlen"));
        this.onlyInUse = "<yes>".equals(cfg.getProperty("onlyInUse"));
        this.ignoreCase = "<yes>".equals(cfg.getProperty("ignoreCase"));
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("key.")) {
                try {
                    keys.putXX(Tags.forName(key.substring(4)), cfg.getProperty(key));
                } catch (Exception e) {
                    throw new IllegalArgumentException("Illegal key - " + key + "=" + cfg.getProperty(key));
                }
            }
        }
        String qrl = keys.getString(Tags.QueryRetrieveLevel, QRLEVEL[1]);
        this.qrLevel = Arrays.asList(QRLEVEL).indexOf(qrl);
        if (qrLevel == -1) {
            throw new IllegalArgumentException("Illegal Query Retrieve Level - " + qrl);
        }
        keys.remove(Tags.QueryRetrieveLevel);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,28083.java,85,97
default,92262.java,88,101
----------------------------------------
    public VM_JNIEnvironment(int threadSlot) {
        JNIFunctionPointers[threadSlot] = VM_Magic.objectAsAddress(JNIFunctions);
        JNIEnvAddress = VM_Magic.objectAsAddress(JNIFunctionPointers) + threadSlot * 4;
        JNIFunctionPointers[threadSlot * 2] = VM_Magic.objectAsAddress(JNIFunctions);
        JNIFunctionPointers[(threadSlot * 2) + 1] = 0;
        JNIEnvAddress = VM_Magic.objectAsAddress(JNIFunctionPointers) + threadSlot * 8;
        JNIRefs = new int[JNIREFS_ARRAY_LENGTH];
        JNIRefs[0] = 0;
        JNIRefsTop = 0;
        JNIRefsSavedFP = 0;
        JNIRefsMax = (JNIRefs.length - 1) * 4;
        alwaysHasNativeFrame = false;
    }
----------------------------------------
    public VM_JNIEnvironment(int threadSlot) {
        JNIFunctionPointers[threadSlot * 2] = VM_Magic.objectAsAddress(JNIFunctions);
        JNIFunctionPointers[(threadSlot * 2) + 1] = VM_Magic.objectAsAddress(VM_Statics.getSlots());
        JNIEnvAddress = VM_Magic.objectAsAddress(JNIFunctionPointers) + threadSlot * 8;
        JNIFunctionPointers[threadSlot * 2] = VM_Magic.objectAsAddress(JNIFunctions);
        JNIFunctionPointers[(threadSlot * 2) + 1] = 0;
        JNIEnvAddress = VM_Magic.objectAsAddress(JNIFunctionPointers) + threadSlot * 8;
        JNIRefs = new int[JNIREFS_ARRAY_LENGTH];
        JNIRefs[0] = 0;
        JNIRefsTop = 0;
        JNIRefsSavedFP = 0;
        JNIRefsMax = (JNIRefs.length - 1) * 4;
        alwaysHasNativeFrame = false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,297,306
default,85127.java,260,270
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35785.java,194,203
default,11030.java,194,203
----------------------------------------
    public void testRetroCollections() {
        {
            List names = new Vector();
            Map dictionary = new Hashtable();
        }
        {
            List<String> names = new Vector<String>();
            Map<String, String> dictionary = new Hashtable<String, String>();
        }
    }
----------------------------------------
    public void testRetroCollections() {
        {
            List names = new Vector();
            Map dictionary = new Hashtable();
        }
        {
            List<String> names = new Vector<String>();
            Map<String, String> dictionary = new Hashtable<String, String>();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,43887.java,216,230
default,5224.java,215,226
----------------------------------------
    public void execute(String[] args, int offset) throws InterruptedException, IOException, GeneralSecurityException {
        switch(mode) {
            case ECHO:
                echo();
                break;
            case SEND:
                send(args, offset);
                break;
            case POLL:
                poll();
                break;
            default:
                throw new RuntimeException("Illegal mode: " + mode);
        }
    }
----------------------------------------
    public void execute(String[] args, int offset) throws InterruptedException, IOException, GeneralSecurityException {
        switch(mode) {
            case ECHO:
                echo();
                break;
            case SEND:
                send(args, offset);
                break;
            default:
                throw new RuntimeException("Illegal mode: " + mode);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6320.java,493,507
default,132787.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,76337.java,93,97
default,42254.java,93,97
----------------------------------------
    public String endTrim(String source) {
        int i = source.length();
        while (--i >= 0) if (source.charAt(i) != ' ') break;
        return source.substring(0, i + 1);
    }
----------------------------------------
    public String endTrim(String source) {
        int i = source.length();
        while (--i >= 0) if (source.charAt(i) != ' ') break;
        return source.substring(0, i + 1);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,118405.java,629,646
default,87896.java,546,568
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,260,270
default,85127.java,297,306
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,44208.java,493,507
default,132787.java,493,507
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void remove(String[] args, int off, boolean delFiles) throws IOException {
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirWriter w = fact.newDirWriter(dirFile, encodeParam());
        try {
            for (int i = off; i < args.length; ++i) {
                addFileIDs(w, new File(args[i]));
            }
            doRemove(w, counter, delFiles);
        } finally {
            w.close();
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("removeDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103146.java,308,322
default,85127.java,308,322
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62365.java,509,520
default,56216.java,509,520
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
    private void doRemove(DirWriter w, int[] counter, boolean delFiles) throws IOException {
        for (DirRecord rec = w.getFirstRecord(true); rec != null; rec = rec.getNextSibling(true)) {
            if (patientIDs.contains(rec.getDataset().getString(Tags.PatientID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                counter[1] += w.remove(rec);
            } else if (doRemoveStudy(w, rec, counter, delFiles)) {
                counter[1] += w.remove(rec);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,116906.java,522,544
default,118405.java,629,646
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeStudy(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeSeries(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,129715.java,461,474
default,44026.java,459,472
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    public void purge() throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        long t1 = System.currentTimeMillis();
        long len1 = dirFile.length();
        int count = 0;
        try {
            count = doPurge(writer);
        } finally {
            writer.close();
        }
        long t2 = System.currentTimeMillis();
        long len2 = dirFile.length();
        System.out.println(MessageFormat.format(messages.getString("purgeDone"), new Object[] { String.valueOf(count), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,103146.java,667,685
default,62365.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,68839.java,443,485
default,21186.java,450,492
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14709.java,353,360
default,5621.java,358,365
----------------------------------------
    public void append(String[] args, int off) throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        try {
            build(writer, args, off);
        } finally {
            writer.close();
        }
    }
----------------------------------------
    public void append(String[] args, int off) throws IOException {
        DirWriter writer = fact.newDirWriter(dirFile, encodeParam());
        try {
            build(writer, args, off);
        } finally {
            writer.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,64797.java,134,155
default,58563.java,105,132
----------------------------------------
    private void inlineMakeObject(String rType, String rTypeObject) {
        _insert("\n");
        if (!rType.equals(rTypeObject)) {
            _insert("    ");
            _insert(rTypeObject);
            _insert(" object_");
            _insert(rType);
            _insert(" = new ");
            _insert(rTypeObject);
            _insert("( value_");
            _insert(rType);
            _insert(" );\n");
        } else {
            _insert("    ");
            _insert(rTypeObject);
            _insert(" object_");
            _insert(rType);
            _insert(" = value_");
            _insert(rType);
            _insert(";\n");
        }
    }
----------------------------------------
    private void inlineObjectValue(String rType, String rTypeObject) {
        _insert("\n    ");
        _insert(rTypeObject);
        _insert(" object_");
        _insert(rType);
        _insert(" = (");
        _insert(rTypeObject);
        _insert(") object;\n");
        if (!rType.equals(rTypeObject)) {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(".");
            _insert(rType);
            _insert("Value();\n");
        } else {
            _insert("    ");
            _insert(rType);
            _insert(" value_");
            _insert(rType);
            _insert(" = object_");
            _insert(rType);
            _insert(";\n");
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,2058.java,496,500
default,19543.java,503,507
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
    private static void exit(String prompt, boolean error) {
        if (prompt != null) System.err.println(prompt);
        if (error) System.err.println(messages.getString("try"));
        System.exit(1);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,93531.java,260,270
default,42993.java,292,301
----------------------------------------
    public void list() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        reader.getFileSetInfo().writeFile2(getTransformerHandler(tf, xslt, FILE_SET_INFO), dict, null, 128, null);
        try {
            list("", reader.getFirstRecord(onlyInUse), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,118344.java,297,306
default,42993.java,292,301
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
    public void query() throws IOException, TransformerConfigurationException {
        SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
        Templates xslt = loadDcmDirXSL(tf);
        DirReader reader = fact.newDirReader(dirFile);
        try {
            query("", 1, 0, reader.getFirstRecordBy(null, keys, ignoreCase), tf, xslt);
        } finally {
            reader.close();
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,15343.java,414,433
default,14709.java,409,428
----------------------------------------
    public void append(DirBuilder builder, File file, int[] counter) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                append(builder, files[i], counter);
            }
        } else {
            try {
                counter[1] += builder.addFileRef(file);
                ++counter[0];
                System.out.print('.');
            } catch (DcmParseException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            } catch (IllegalArgumentException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            }
        }
    }
----------------------------------------
    public void append(DirBuilder builder, File file, int[] counter) throws IOException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; ++i) {
                append(builder, files[i], counter);
            }
        } else {
            try {
                counter[1] += builder.addFileRef(file);
                ++counter[0];
                System.out.print('.');
            } catch (DcmParseException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            } catch (IllegalArgumentException e) {
                System.out.println(MessageFormat.format(messages.getString("insertFailed"), new Object[] { file }));
                e.printStackTrace(System.out);
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,59194.java,56,63
default,103538.java,126,133
----------------------------------------
    private static void add(Configuration cfg, String s) {
        int pos = s.indexOf('=');
        if (pos == -1) {
            cfg.put(s, "");
        } else {
            cfg.put(s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void set(Configuration cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("set." + s, "");
        } else {
            cfg.put("set." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,132272.java,126,133
default,38445.java,56,63
----------------------------------------
    private static void set(Configuration cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("set." + s, "");
        } else {
            cfg.put("set." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void add(Configuration cfg, String s) {
        int pos = s.indexOf('=');
        if (pos == -1) {
            cfg.put(s, "");
        } else {
            cfg.put(s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,14338.java,495,504
default,41669.java,349,358
----------------------------------------
    public void writer__handleException(String rMessage, Exception rException) {
        StringBuffer userMsg = new StringBuffer(111);
        userMsg.append(writer__UITEXT_ErrorHeader);
        userMsg.append(writer__describeState() + rMessage + writer__UITEXT_ColonNewLine);
        StringWriter stringWriter = new StringWriter();
        rException.printStackTrace(new PrintWriter(stringWriter));
        userMsg.append(stringWriter.toString());
        userMsg.append(writer__UITEXT_ErrorFooter);
        writer__userMessage(userMsg.toString());
    }
----------------------------------------
    public void writer__handleException(String rMessage, Exception rException) {
        StringBuffer userMsg = new StringBuffer(111);
        userMsg.append(writer__UITEXT_ErrorHeader);
        userMsg.append(writer__describeState() + rMessage + writer__UITEXT_ColonNewLine);
        StringWriter stringWriter = new StringWriter();
        rException.printStackTrace(new PrintWriter(stringWriter));
        userMsg.append(stringWriter.toString());
        userMsg.append(writer__UITEXT_ErrorFooter);
        writer__userMessage(userMsg.toString());
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,3128.java,375,381
default,24692.java,375,381
----------------------------------------
    private String getNextLine(BufferedReader data) throws IOException {
        String line = data.readLine();
        if (line == null || line.length() == 0) return line;
        while (line.startsWith(commentMarker)) line = data.readLine();
        while (line.endsWith("\\")) line = line.substring(0, line.length() - 1) + data.readLine();
        return line;
    }
----------------------------------------
    private String getNextLine(BufferedReader data) throws IOException {
        String line = data.readLine();
        if (line == null || line.length() == 0) return line;
        while (line.startsWith(commentMarker)) line = data.readLine();
        while (line.endsWith("\\")) line = line.substring(0, line.length() - 1) + data.readLine();
        return line;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35053.java,648,665
default,93531.java,667,685
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,90330.java,428,448
default,132787.java,570,590
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,92220.java,648,665
default,44026.java,546,568
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,107017.java,77,83
default,71677.java,72,78
----------------------------------------
    public void addPrimaryZone(String zname, String zonefile) throws IOException {
        Name origin = null;
        Cache cache = getCache(DClass.IN);
        if (zname != null) origin = Name.fromString(zname, Name.root);
        Zone newzone = new Zone(zonefile, cache, origin);
        znames.put(newzone.getOrigin(), newzone);
    }
----------------------------------------
    public void addPrimaryZone(String zname, String zonefile) throws IOException {
        Name origin = null;
        Cache cache = getCache(DClass.IN);
        if (zname != null) origin = Name.fromString(zname, Name.root);
        Zone newzone = new Zone(zonefile, cache, origin);
        znames.put(newzone.getOrigin(), newzone);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,137408.java,443,485
default,5541.java,463,505
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79012.java,570,590
default,5621.java,546,568
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveSeries(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (seriesUIDs.contains(rec.getDataset().getString(Tags.SeriesInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveInstances(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70088.java,669,687
default,79012.java,570,590
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,50381.java,463,505
default,92411.java,459,501
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
        private void writeValueTo(OutputStream out, boolean swap) throws IOException {
            InputStream in = parser.getInputStream();
            int len = parser.getReadLength();
            if (swap && (len & 1) != 0) {
                throw new DcmParseException("Illegal length of OW Pixel Data: " + len);
            }
            if (buffer == null) {
                if (swap) {
                    int tmp;
                    for (int i = 0; i < len; ++i, ++i) {
                        tmp = in.read();
                        out.write(in.read());
                        out.write(tmp);
                    }
                } else {
                    for (int i = 0; i < len; ++i) {
                        out.write(in.read());
                    }
                }
            } else {
                byte tmp;
                int c, remain = len;
                while (remain > 0) {
                    c = in.read(buffer, 0, Math.min(buffer.length, remain));
                    if (c == -1) {
                        throw new EOFException("EOF during read of pixel data");
                    }
                    if (swap) {
                        if ((c & 1) != 0) {
                            buffer[c++] = (byte) in.read();
                        }
                        for (int i = 0; i < c; ++i, ++i) {
                            tmp = buffer[i];
                            buffer[i] = buffer[i + 1];
                            buffer[i + 1] = tmp;
                        }
                    }
                    out.write(buffer, 0, c);
                    remain -= c;
                }
            }
            parser.setStreamPosition(parser.getStreamPosition() + len);
        }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,39836.java,54,62
default,46050.java,54,62
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
    String sequenceUsingDo(int start, int stop) {
        StringBuilder builder = new StringBuilder();
        int i = start;
        do {
            if (i > start) builder.append(',');
            builder.append(i);
        } while (++i <= stop);
        return builder.toString();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,70088.java,606,619
default,44026.java,604,617
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
    private void deleteRefFiles(DirWriter w, DirRecord rec, int[] counter) throws IOException {
        String[] fileIDs = rec.getRefFileIDs();
        if (fileIDs != null) {
            File f = w.getRefFile(fileIDs);
            if (!f.delete()) {
                System.out.println(MessageFormat.format(messages.getString("deleteFailed"), new Object[] { f }));
            } else {
                ++counter[0];
            }
        }
        for (DirRecord child = rec.getFirstChild(true); child != null; child = child.getNextSibling(true)) {
            deleteRefFiles(w, child, counter);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,60222.java,198,210
default,103538.java,216,229
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
    private ActiveAssociation openAssoc() throws IOException, GeneralSecurityException {
        Association assoc = aFact.newRequestor(newSocket(url.getHost(), url.getPort()));
        assoc.setAcTimeout(acTimeout);
        assoc.setDimseTimeout(dimseTimeout);
        assoc.setSoCloseDelay(soCloseDelay);
        assoc.setPackPDVs(packPDVs);
        PDU assocAC = assoc.connect(assocRQ);
        if (!(assocAC instanceof AAssociateAC)) {
            return null;
        }
        ActiveAssociation retval = aFact.newActiveAssociation(assoc, null);
        retval.start();
        return retval;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,35053.java,570,590
default,98990.java,570,590
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,33310.java,295,307
default,103538.java,293,304
----------------------------------------
    private void send(ActiveAssociation active, File file, Dataset ds) throws InterruptedException, IOException {
        if (!file.isDirectory()) {
            for (int i = 0; i < repeatSingle; ++i) {
                if (ds != null && random) ds.putUI(Tags.SOPInstanceUID, uidGen.createUID());
                sendFile(active, file, ds);
            }
            return;
        }
        File[] list = file.listFiles();
        for (int i = 0; i < list.length; ++i) {
            send(active, list[i], ds);
        }
    }
----------------------------------------
    private void send(ActiveAssociation active, File file) throws InterruptedException, IOException {
        if (!file.isDirectory()) {
            for (int i = 0; i < repeatSingle; ++i) {
                sendFile(active, file);
            }
            return;
        }
        File[] list = file.listFiles();
        for (int i = 0; i < list.length; ++i) {
            send(active, list[i]);
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,79012.java,394,404
default,42993.java,389,399
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95647.java,199,206
default,40654.java,199,206
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
    private static void putKey(Properties cfg, String s) {
        int pos = s.indexOf(':');
        if (pos == -1) {
            cfg.put("key." + s, "");
        } else {
            cfg.put("key." + s.substring(0, pos), s.substring(pos + 1));
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,99163.java,506,524
default,57136.java,513,531
----------------------------------------
    private final void initAssocParam(Configuration cfg, DcmURL url, boolean echo) {
        acTimeout = Integer.parseInt(cfg.getProperty("ac-timeout", "5000"));
        dimseTimeout = Integer.parseInt(cfg.getProperty("dimse-timeout", "0"));
        soCloseDelay = Integer.parseInt(cfg.getProperty("so-close-delay", "500"));
        assocRQ.setCalledAET(url.getCalledAET());
        assocRQ.setCallingAET(maskNull(url.getCallingAET()));
        assocRQ.setMaxPDULength(Integer.parseInt(cfg.getProperty("max-pdu-len", "16352")));
        assocRQ.setAsyncOpsWindow(aFact.newAsyncOpsWindow(Integer.parseInt(cfg.getProperty("max-op-invoked", "0")), 1));
        if (echo) {
            assocRQ.addPresContext(aFact.newPresContext(PCID_ECHO, UIDs.Verification, DEF_TS));
            return;
        }
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("pc.")) {
                initPresContext(Integer.parseInt(key.substring(3)), cfg.tokenize(cfg.getProperty(key), new LinkedList()));
            }
        }
    }
----------------------------------------
    private final void initAssocParam(Configuration cfg, DcmURL url, boolean echo) {
        acTimeout = Integer.parseInt(cfg.getProperty("ac-timeout", "5000"));
        dimseTimeout = Integer.parseInt(cfg.getProperty("dimse-timeout", "0"));
        soCloseDelay = Integer.parseInt(cfg.getProperty("so-close-delay", "500"));
        assocRQ.setCalledAET(url.getCalledAET());
        assocRQ.setCallingAET(maskNull(url.getCallingAET()));
        assocRQ.setMaxPDULength(Integer.parseInt(cfg.getProperty("max-pdu-len", "16352")));
        assocRQ.setAsyncOpsWindow(aFact.newAsyncOpsWindow(Integer.parseInt(cfg.getProperty("max-op-invoked", "0")), 1));
        if (echo) {
            assocRQ.addPresContext(aFact.newPresContext(PCID_ECHO, UIDs.Verification, DEF_TS));
            return;
        }
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("pc.")) {
                initPresContext(Integer.parseInt(key.substring(3)), cfg.tokenize(cfg.getProperty(key), new LinkedList()));
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,137594.java,570,590
default,87896.java,667,685
----------------------------------------
    private boolean doRemoveInstances(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (sopInstUIDs.contains(rec.getRefSOPInstanceUID()) || matchFileIDs(rec.getRefFileIDs())) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeInstances(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            File file = w.getRefFile(rec.getRefFileIDs());
            if (!file.exists()) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,128156.java,506,524
default,5541.java,526,544
----------------------------------------
    private final void initAssocParam(Configuration cfg, DcmURL url, boolean echo) {
        acTimeout = Integer.parseInt(cfg.getProperty("ac-timeout", "5000"));
        dimseTimeout = Integer.parseInt(cfg.getProperty("dimse-timeout", "0"));
        soCloseDelay = Integer.parseInt(cfg.getProperty("so-close-delay", "500"));
        assocRQ.setCalledAET(url.getCalledAET());
        assocRQ.setCallingAET(maskNull(url.getCallingAET()));
        assocRQ.setMaxPDULength(Integer.parseInt(cfg.getProperty("max-pdu-len", "16352")));
        assocRQ.setAsyncOpsWindow(aFact.newAsyncOpsWindow(Integer.parseInt(cfg.getProperty("max-op-invoked", "0")), 1));
        if (echo) {
            assocRQ.addPresContext(aFact.newPresContext(PCID_ECHO, UIDs.Verification, DEF_TS));
            return;
        }
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("pc.")) {
                initPresContext(Integer.parseInt(key.substring(3)), cfg.tokenize(cfg.getProperty(key), new LinkedList()));
            }
        }
    }
----------------------------------------
    private final void initAssocParam(Configuration cfg, DcmURL url, boolean echo) {
        acTimeout = Integer.parseInt(cfg.getProperty("ac-timeout", "5000"));
        dimseTimeout = Integer.parseInt(cfg.getProperty("dimse-timeout", "0"));
        soCloseDelay = Integer.parseInt(cfg.getProperty("so-close-delay", "500"));
        assocRQ.setCalledAET(url.getCalledAET());
        assocRQ.setCallingAET(maskNull(url.getCallingAET()));
        assocRQ.setMaxPDULength(Integer.parseInt(cfg.getProperty("max-pdu-len", "16352")));
        assocRQ.setAsyncOpsWindow(aFact.newAsyncOpsWindow(Integer.parseInt(cfg.getProperty("max-op-invoked", "0")), 1));
        if (echo) {
            assocRQ.addPresContext(aFact.newPresContext(PCID_ECHO, UIDs.Verification, DEF_TS));
            return;
        }
        for (Enumeration it = cfg.keys(); it.hasMoreElements(); ) {
            String key = (String) it.nextElement();
            if (key.startsWith("pc.")) {
                initPresContext(Integer.parseInt(key.substring(3)), cfg.tokenize(cfg.getProperty(key), new LinkedList()));
            }
        }
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,62365.java,648,665
default,79012.java,522,544
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,6937.java,522,544
default,62365.java,648,665
----------------------------------------
    private boolean doRemoveStudy(DirWriter w, DirRecord parent, int[] counter, boolean delFiles) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (studyUIDs.contains(rec.getDataset().getString(Tags.StudyInstanceUID))) {
                if (delFiles) {
                    deleteRefFiles(w, rec, counter);
                }
                toRemove.add(rec);
            } else if (doRemoveSeries(w, rec, counter, delFiles)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[1] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
    private boolean doPurgeSeries(DirWriter w, DirRecord parent, int[] counter) throws IOException {
        boolean matchAll = true;
        LinkedList toRemove = new LinkedList();
        for (DirRecord rec = parent.getFirstChild(true); rec != null; rec = rec.getNextSibling(true)) {
            if (doPurgeInstances(w, rec, counter)) {
                toRemove.add(rec);
            } else {
                matchAll = false;
            }
        }
        if (matchAll) {
            return true;
        }
        for (Iterator it = toRemove.iterator(); it.hasNext(); ) {
            counter[0] += w.remove((DirRecord) it.next());
        }
        return false;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,36085.java,63,67
default,124790.java,63,67
----------------------------------------
    public String[] tokenize(String s) {
        if (s == null) return null;
        List l = tokenize(s, new LinkedList());
        return (String[]) l.toArray(new String[l.size()]);
    }
----------------------------------------
    public String[] tokenize(String s) {
        if (s == null) return null;
        List l = tokenize(s, new LinkedList());
        return (String[]) l.toArray(new String[l.size()]);
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,126833.java,90,98
default,61252.java,46,54
----------------------------------------
    private static boolean delete(File resource) throws IOException {
        if (resource.isDirectory()) {
            File[] childFiles = resource.listFiles();
            for (File child : childFiles) {
                delete(child);
            }
        }
        return resource.delete();
    }
----------------------------------------
    public static boolean delete(File resource) throws IOException {
        if (resource.isDirectory()) {
            File[] childFiles = resource.listFiles();
            for (File child : childFiles) {
                delete(child);
            }
        }
        return resource.delete();
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,120094.java,84,91
default,46050.java,84,91
----------------------------------------
    public void testEndTrim() {
        assertEquals("", endTrim(""));
        assertEquals("  x", endTrim("  x  "));
        assertEquals("y", endTrim("y"));
        assertEquals("xaxa", endTrim("xaxa"));
        assertEquals("", endTrim(" "));
        assertEquals("xxx", endTrim("xxx      "));
    }
----------------------------------------
    public void testEndTrim() {
        assertEquals("", endTrim(""));
        assertEquals("  x", endTrim("  x  "));
        assertEquals("y", endTrim("y"));
        assertEquals("xaxa", endTrim("xaxa"));
        assertEquals("", endTrim(" "));
        assertEquals("xxx", endTrim("xxx      "));
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,31361.java,27,46
default,34597.java,27,46
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,95647.java,308,322
default,76192.java,308,322
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
    private int query(String prefix, int no, int level, DirRecord dr, SAXTransformerFactory tf, Templates xslt) throws IOException, TransformerConfigurationException {
        int count = 1;
        for (; dr != null; dr = dr.getNextSiblingBy(null, keys, ignoreCase)) {
            if (level >= qrLevel) {
                Dataset ds = dr.getDataset();
                String prompt = POS_FORMAT.format(ds.getItemOffset()) + prefix + count + " [" + dr.getType() + "] #" + no;
                ds.writeDataset(getTransformerHandler(tf, xslt, prompt), dict);
                ++no;
            } else {
                no = query(prefix + count + '.', no, level + 1, dr.getFirstChildBy(null, keys, ignoreCase), tf, xslt);
            }
            ++count;
        }
        return no;
    }
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
default,98981.java,394,404
default,76192.java,394,404
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
    private void build(DirWriter w, String[] args, int off) throws IOException {
        DirBuilderPref pref = getDirBuilderPref();
        long t1 = System.currentTimeMillis();
        int[] counter = new int[2];
        DirBuilder builder = fact.newDirBuilder(w, pref);
        for (int i = off; i < args.length; ++i) {
            append(builder, new File(args[i]), counter);
        }
        long t2 = System.currentTimeMillis();
        System.out.println(MessageFormat.format(messages.getString("insertDone"), new Object[] { String.valueOf(counter[1]), String.valueOf(counter[0]), String.valueOf((t2 - t1) / 1000f) }));
    }
----------------------------------------
